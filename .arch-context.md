# Architecture Context Inventory

Generated: 2026-02-14

---

## 1. ARCHITECTURE.md Section Headers

File: `architecture/ARCHITECTURE.md`

```
## 1. Overview                                        (line 3)
## 2. Architecture Decision Records                   (line 50)
## 3. Component Architecture                          (line 409)
## 4. Sequence Diagrams                               (line 704)
## 5. Data Flow Diagrams                              (line 874)
## 6. Security Architecture                           (line 980)
## 7. Infrastructure Architecture                     (line 1083)
## 8. Database Architecture                           (line 1236)
## 9. Phase 2 -- Billing & Tiered Tenancy             (line 1344)
## 10. Phase 4 -- Customers, Document Scopes & Tasks  (line 1874)
## Appendix A: Clerk JWT Claims                       (line 2446)
## Appendix B: Environment Variables Reference        (line 2460)
```

- **Last numbered section**: 10 (Phase 4)
- **Next available section number**: 11
- Note: Phases 5, 6, 6.5, 7, 8 have separate architecture docs (not inlined in ARCHITECTURE.md)

---

## 2. ADR Numbering

Directory: `adr/`

| Range | Phase |
|-------|-------|
| ADR-010 to ADR-016 | Phase 2 (Billing & Tiered Tenancy) |
| ADR-017 to ADR-020 | Phase 4 (Customers, Document Scopes & Tasks) |
| ADR-021 to ADR-024 | Phase 5 (Task & Time Lifecycle) |
| ADR-025 to ADR-029 | Phase 6 (Audit & Compliance) |
| ADR-030 to ADR-033 | Phase 7 (Customer Portal Backend) |
| ADR-034 to ADR-038 | Phase 6.5 (Notifications, Comments & Activity) |
| ADR-039 to ADR-043 | Phase 8 (Rate Cards, Budgets & Profitability) |
| ADR-044 to ADR-047 | Phase 9 (Dashboard) |
| ADR-048 to ADR-051 | Phase 10 (Invoicing & Billing) -- code reverted, ADRs still on disk |
| ADR-052 to ADR-055 | Phase 11 (Tags, Custom Fields & Views) -- code not yet implemented, ADRs still on disk |

- **Highest ADR number**: ADR-055 (saved-view-filter-execution.md)
- **Next available ADR number**: ADR-056
- Note: ADRs 001-009 are inline in architecture/ARCHITECTURE.md

---

## 3. Migration Numbering

### Global migrations (`db/migration/global/`)

| Migration | Description |
|-----------|-------------|
| V1 | create_org_schema_mapping |
| V2 | create_organizations |
| V3 | create_processed_webhooks |
| V4 | add_org_tier |
| V5 | drop_schema_name_unique |
| V6 | add_subscriptions |
| V7 | create_portal_schema |

- **Highest global migration**: V7
- **Next available global migration**: V8

### Tenant migrations (`db/migration/tenant/`)

| Migration | Description |
|-----------|-------------|
| V1 | create_projects |
| V2 | create_documents |
| V3 | create_members |
| V4 | migrate_ownership_to_members |
| V5 | create_project_members |
| V6 | add_missing_fk_indexes |
| V7 | add_tenant_id_for_shared |
| V8 | shared_schema_member_unique |
| V9 | create_customers |
| V10 | create_customer_projects |
| V11 | create_tasks |
| V12 | extend_documents_scope |
| V13 | create_time_entries |
| V14 | create_audit_events |
| V15 | create_comments |
| V16 | create_notifications |
| V17 | create_notification_preferences |
| V18 | create_portal_contacts_and_magic_link_tokens |
| V19 | create_rate_budget_tables |
| V20 | add_time_entry_rate_snapshots |
| V21 | add_project_budget_version |
| V22 | add_dashboard_indexes |

- **Highest tenant migration**: V22
- **Next available tenant migration**: V23

---

## 4. Entity Inventory

21 `@Entity` classes in the codebase:

| Entity | Package | File |
|--------|---------|------|
| Project | project | `project/Project.java` |
| Document | document | `document/Document.java` |
| Member | member | `member/Member.java` |
| ProjectMember | member | `member/ProjectMember.java` |
| Customer | customer | `customer/Customer.java` |
| CustomerProject | customer | `customer/CustomerProject.java` |
| Task | task | `task/Task.java` |
| TimeEntry | timeentry | `timeentry/TimeEntry.java` |
| AuditEvent | audit | `audit/AuditEvent.java` |
| Comment | comment | `comment/Comment.java` |
| Notification | notification | `notification/Notification.java` |
| NotificationPreference | notification | `notification/NotificationPreference.java` |
| PortalContact | portal | `portal/PortalContact.java` |
| MagicLinkToken | portal | `portal/MagicLinkToken.java` |
| BillingRate | billingrate | `billingrate/BillingRate.java` |
| CostRate | costrate | `costrate/CostRate.java` |
| ProjectBudget | budget | `budget/ProjectBudget.java` |
| OrgSettings | settings | `settings/OrgSettings.java` |
| Organization | provisioning | `provisioning/Organization.java` |
| OrgSchemaMapping | multitenancy | `multitenancy/OrgSchemaMapping.java` |
| Subscription | billing | `billing/Subscription.java` |

All paths relative to `backend/src/main/java/io/b2mash/b2b/b2bstrawman/`.

---

## 5. Backend Package Structure

Base: `src/main/java/io/b2mash/b2b/b2bstrawman/`

```
activity/          -- Activity feed service (queries audit events)
audit/             -- AuditEvent entity, repository, service, builder, controller
billing/           -- Subscription entity, plan sync
billingrate/       -- BillingRate entity, repository, service, controller
budget/            -- ProjectBudget entity, repository, service, controller
comment/           -- Comment entity, repository, service, controller
config/            -- Spring configuration beans (Security, Hibernate, S3, etc.)
costrate/          -- CostRate entity, repository, service, controller
customer/          -- Customer + CustomerProject entities, repos, services, controllers
customerbackend/   -- Portal backend: domain events, read-model sync, portal APIs
dashboard/         -- Dashboard aggregation service, controller
dev/               -- Dev portal harness (Thymeleaf, local/dev profile only)
document/          -- Document entity, repository, service, controller
event/             -- DomainEvent sealed interface + all event records
exception/         -- Shared semantic exceptions (ResourceNotFoundException, etc.)
member/            -- Member + ProjectMember entities, repos, services, controllers
multitenancy/      -- RequestScopes (ScopedValue), identifier resolver, connection provider, filters
mywork/            -- "My Work" cross-project view service, controller
notification/      -- Notification + NotificationPreference entities, repos, service, controller
                     + channel/ (dispatcher, email channel)
                     + template/ (email templates)
portal/            -- PortalContact + MagicLinkToken entities, repos, services
project/           -- Project entity, repository, service, controller
provisioning/      -- Tenant provisioning: Organization entity, service, controller
report/            -- Profitability report service, controller
s3/                -- S3 presigned URL service
security/          -- JWT auth filter, API key filter, role converter
settings/          -- OrgSettings entity, repository, service, controller
task/              -- Task entity, repository, service, controller
timeentry/         -- TimeEntry entity, repository, service, controller
BackendApplication.java
```

---

## 6. Frontend Route Structure

Routes under `frontend/app/(app)/org/[slug]/`:

```
layout.tsx                        -- Org layout (sidebar, header)
dashboard/page.tsx                -- Dashboard page
projects/page.tsx                 -- Projects list
projects/[id]/page.tsx            -- Project detail (tabs: overview, tasks, documents, time, activity, financials)
customers/page.tsx                -- Customers list
customers/[id]/page.tsx           -- Customer detail
documents/page.tsx                -- Documents list
my-work/page.tsx                  -- My Work cross-project view
notifications/page.tsx            -- Notifications page
profitability/page.tsx            -- Profitability reports
team/page.tsx                     -- Team members
settings/page.tsx                 -- General settings
settings/billing/page.tsx         -- Billing settings
settings/notifications/page.tsx   -- Notification preferences
settings/rates/page.tsx           -- Rate card management
```

---

## 7. Entity Reference Patterns

### TimeEntry (full source)

```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "time_entries")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class TimeEntry implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "task_id", nullable = false)
  private UUID taskId;

  @Column(name = "member_id", nullable = false)
  private UUID memberId;

  @Column(name = "date", nullable = false)
  private LocalDate date;

  @Column(name = "duration_minutes", nullable = false)
  private int durationMinutes;

  @Column(name = "billable", nullable = false)
  private boolean billable;

  @Deprecated
  @Column(name = "rate_cents")
  private Integer rateCents;

  @Column(name = "billing_rate_snapshot", precision = 12, scale = 2)
  private BigDecimal billingRateSnapshot;

  @Column(name = "billing_rate_currency", length = 3)
  private String billingRateCurrency;

  @Column(name = "cost_rate_snapshot", precision = 12, scale = 2)
  private BigDecimal costRateSnapshot;

  @Column(name = "cost_rate_currency", length = 3)
  private String costRateCurrency;

  @Column(name = "description", columnDefinition = "TEXT")
  private String description;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected TimeEntry() {}

  public TimeEntry(
      UUID taskId,
      UUID memberId,
      LocalDate date,
      int durationMinutes,
      boolean billable,
      Integer rateCents,
      String description) {
    this.taskId = taskId;
    this.memberId = memberId;
    this.date = date;
    this.durationMinutes = durationMinutes;
    this.billable = billable;
    this.rateCents = rateCents;
    this.description = description;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public UUID getId() { return id; }
  public UUID getTaskId() { return taskId; }
  public UUID getMemberId() { return memberId; }
  public LocalDate getDate() { return date; }
  public int getDurationMinutes() { return durationMinutes; }
  public boolean isBillable() { return billable; }
  @Deprecated
  public Integer getRateCents() { return rateCents; }
  public String getDescription() { return description; }

  @Override
  public String getTenantId() { return tenantId; }
  @Override
  public void setTenantId(String tenantId) { this.tenantId = tenantId; }

  public Instant getCreatedAt() { return createdAt; }
  public Instant getUpdatedAt() { return updatedAt; }

  public void setDate(LocalDate date) { this.date = date; }
  public void setDurationMinutes(int durationMinutes) { this.durationMinutes = durationMinutes; }
  public void setBillable(boolean billable) { this.billable = billable; }
  @Deprecated
  public void setRateCents(Integer rateCents) { this.rateCents = rateCents; }

  public BigDecimal getBillingRateSnapshot() { return billingRateSnapshot; }
  public String getBillingRateCurrency() { return billingRateCurrency; }
  public BigDecimal getCostRateSnapshot() { return costRateSnapshot; }
  public String getCostRateCurrency() { return costRateCurrency; }

  public void snapshotBillingRate(BigDecimal rate, String currency) {
    this.billingRateSnapshot = rate;
    this.billingRateCurrency = currency;
  }

  public void snapshotCostRate(BigDecimal rate, String currency) {
    this.costRateSnapshot = rate;
    this.costRateCurrency = currency;
  }

  /**
   * Computed billable value: (durationMinutes / 60) * billingRateSnapshot.
   * Returns null if not billable or no billing rate snapshot.
   */
  public BigDecimal getBillableValue() {
    if (!billable || billingRateSnapshot == null) {
      return null;
    }
    return BigDecimal.valueOf(durationMinutes)
        .divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP)
        .multiply(billingRateSnapshot)
        .setScale(2, RoundingMode.HALF_UP);
  }

  /**
   * Computed cost value: (durationMinutes / 60) * costRateSnapshot.
   * Returns null if no cost rate snapshot.
   */
  public BigDecimal getCostValue() {
    if (costRateSnapshot == null) {
      return null;
    }
    return BigDecimal.valueOf(durationMinutes)
        .divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP)
        .multiply(costRateSnapshot)
        .setScale(2, RoundingMode.HALF_UP);
  }

  public void setDescription(String description) { this.description = description; }
  public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
}
```

### Customer (full source)

```java
package io.b2mash.b2b.b2bstrawman.customer;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "customers")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class Customer implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "name", nullable = false, length = 255)
  private String name;

  @Column(name = "email", nullable = false, length = 255)
  private String email;

  @Column(name = "phone", length = 50)
  private String phone;

  @Column(name = "id_number", length = 100)
  private String idNumber;

  @Column(name = "status", nullable = false, length = 20)
  private String status;

  @Column(name = "notes", columnDefinition = "TEXT")
  private String notes;

  @Column(name = "created_by", nullable = false)
  private UUID createdBy;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected Customer() {}

  public Customer(
      String name, String email, String phone, String idNumber, String notes, UUID createdBy) {
    this.name = name;
    this.email = email;
    this.phone = phone;
    this.idNumber = idNumber;
    this.status = "ACTIVE";
    this.notes = notes;
    this.createdBy = createdBy;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void update(String name, String email, String phone, String idNumber, String notes) {
    this.name = name;
    this.email = email;
    this.phone = phone;
    this.idNumber = idNumber;
    this.notes = notes;
    this.updatedAt = Instant.now();
  }

  public void archive() {
    this.status = "ARCHIVED";
    this.updatedAt = Instant.now();
  }

  public UUID getId() { return id; }
  public String getName() { return name; }
  public String getEmail() { return email; }
  public String getPhone() { return phone; }
  public String getIdNumber() { return idNumber; }
  public String getStatus() { return status; }
  public String getNotes() { return notes; }
  public UUID getCreatedBy() { return createdBy; }

  @Override
  public String getTenantId() { return tenantId; }
  @Override
  public void setTenantId(String tenantId) { this.tenantId = tenantId; }

  public Instant getCreatedAt() { return createdAt; }
  public Instant getUpdatedAt() { return updatedAt; }
}
```

### Key entity conventions

- **Tenant isolation**: `implements TenantAware` + `@FilterDef`/`@Filter` + `@EntityListeners(TenantAwareEntityListener.class)`
- **UUID PK**: `@GeneratedValue(strategy = GenerationType.UUID)`
- **Timestamps**: `createdAt` (updatable=false) + `updatedAt`, set in constructor and update methods (not `@PrePersist`)
- **No Lombok**: Plain Java, protected no-arg constructor
- **Domain methods**: Mutation via named methods (e.g., `update()`, `archive()`), not raw setters
- **`@Version`**: Used selectively (e.g., `ProjectBudget`), not universally
- **JSONB**: `@JdbcTypeCode(SqlTypes.JSON)` + `columnDefinition = "jsonb"` (see AuditEvent)

---

## 8. Recent ADR Format Template

Source: `adr/ADR-055-saved-view-filter-execution.md`

```markdown
# ADR-055: Saved View Filter Execution

**Status**: Accepted

**Context**: Phase 11 introduces saved views -- named filter+column configurations
that users apply to list pages (projects, tasks, customers). A saved view's
`filters` JSONB contains structured filter criteria:

[JSON example of filter structure]

The design question is *where* and *how* these filters are executed...

Key constraints:
- [bullet list of specific constraints]

**Options Considered**:

1. **Option name** -- [One-sentence description.]
   - Pros:
     - [bullet list]
   - Cons:
     - [bullet list]

2. **Option name** -- [One-sentence description.]
   - Pros: [...]
   - Cons: [...]

3. **Option name** -- [One-sentence description.]
   - Pros: [...]
   - Cons: [...]

**Decision**: [Selected option] (Option N).

**Rationale**: [1-2 paragraphs explaining why this option was chosen,
including migration/evolution path for future needs. May include code examples.]

**Consequences**:
- [Concrete implementation artifact -- package, class, config]
- [What changes and what stays the same]
- [Future migration path / what would need to change]
```

---

## 9. Notification Integration Pattern

### Notification Types (defined as constants in NotificationService)

```java
public static final List<String> NOTIFICATION_TYPES =
    List.of(
        "TASK_ASSIGNED",
        "TASK_CLAIMED",
        "TASK_UPDATED",
        "COMMENT_ADDED",
        "DOCUMENT_SHARED",
        "MEMBER_INVITED",
        "BUDGET_ALERT");
```

### DomainEvent Sealed Interface (`event/DomainEvent.java`)

```java
public sealed interface DomainEvent
    permits BudgetThresholdEvent,
        CommentCreatedEvent,
        CommentUpdatedEvent,
        CommentDeletedEvent,
        CommentVisibilityChangedEvent,
        TaskAssignedEvent,
        TaskClaimedEvent,
        TaskStatusChangedEvent,
        DocumentUploadedEvent,
        MemberAddedToProjectEvent {

  String eventType();
  String entityType();
  UUID entityId();
  UUID projectId();
  UUID actorMemberId();
  String actorName();
  String tenantId();
  String orgId();
  Instant occurredAt();
  Map<String, Object> details();
}
```

### Example Domain Event Records

```java
// TaskAssignedEvent -- extra fields: assigneeMemberId, taskTitle
public record TaskAssignedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    String orgId,
    Instant occurredAt,
    Map<String, Object> details,
    UUID assigneeMemberId,
    String taskTitle)
    implements DomainEvent {}

// CommentCreatedEvent -- extra fields: targetEntityType, targetEntityId, visibility
public record CommentCreatedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    String orgId,
    Instant occurredAt,
    Map<String, Object> details,
    String targetEntityType,
    UUID targetEntityId,
    String visibility)
    implements DomainEvent {}
```

### Notification Fan-Out Pattern (NotificationService)

Each handler method:
1. Determines recipients from event data + DB queries
2. Excludes the actor (no self-notifications)
3. Calls `createIfEnabled()` which checks `NotificationPreference` (opt-out model: enabled by default)
4. Uses `@Transactional(propagation = Propagation.REQUIRES_NEW)` for isolation

Handler methods:
- `handleTaskAssigned(TaskAssignedEvent)` -- notifies assignee
- `handleTaskClaimed(TaskClaimedEvent)` -- notifies previous assignee + project leads
- `handleTaskStatusChanged(TaskStatusChangedEvent)` -- notifies assignee
- `handleCommentCreated(CommentCreatedEvent)` -- notifies entity owner + prior commenters
- `handleDocumentUploaded(DocumentUploadedEvent)` -- notifies project members
- `handleMemberAddedToProject(MemberAddedToProjectEvent)` -- notifies added member
- `handleBudgetThreshold(BudgetThresholdEvent)` -- notifies project leads + admins/owners

Events are published via Spring `ApplicationEventPublisher` and consumed by a `NotificationEventHandler` (listener).

### Adding a new notification type requires:
1. Add the type string to `NOTIFICATION_TYPES` list
2. Create a new `DomainEvent` record in `event/` package
3. Add it to the `DomainEvent` sealed `permits` clause
4. Add a handler method in `NotificationService`
5. Register the handler in `NotificationEventHandler` (the `@EventListener`)
6. Publish the event from the service that triggers it

---

## 10. Audit Integration Pattern

### AuditEvent Entity

Append-only entity with no `updatedAt`, no setters (except `setTenantId`). Uses JSONB `details` column.

```java
@Entity
@Table(name = "audit_events")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class AuditEvent implements TenantAware {
  UUID id;
  String eventType;      // "{entity}.{action}" convention (e.g., "task.claimed")
  String entityType;     // "project", "task", "document", etc.
  UUID entityId;
  UUID actorId;          // member ID, null for system events
  String actorType;      // "USER", "SYSTEM", "WEBHOOK"
  String source;         // "API", "INTERNAL", "WEBHOOK", "SCHEDULED"
  String ipAddress;
  String userAgent;
  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "details", columnDefinition = "jsonb")
  Map<String, Object> details;
  String tenantId;
  Instant occurredAt;
}
```

### AuditEventRecord (DTO -- passed to AuditService.log())

```java
public record AuditEventRecord(
    String eventType,
    String entityType,
    UUID entityId,
    UUID actorId,
    String actorType,
    String source,
    String ipAddress,
    String userAgent,
    Map<String, Object> details) {}
```

### AuditEventBuilder (convenience builder)

Auto-populates actor, source, and HTTP request metadata from `RequestScopes` and `RequestContextHolder`:

```java
auditService.log(AuditEventBuilder.builder()
    .eventType("task.claimed")
    .entityType("task")
    .entityId(taskId)
    .details(Map.of("assignee_id", memberId.toString()))
    .build());
```

Builder auto-resolves:
- `actorId` from `RequestScopes.MEMBER_ID` (if bound)
- `actorType` = "USER" if MEMBER_ID bound, "SYSTEM" otherwise
- `source` = "API" if in HTTP context, "INTERNAL" otherwise
- `ipAddress` from `HttpServletRequest.getRemoteAddr()`
- `userAgent` from User-Agent header (truncated to 500 chars)

### AuditService Interface

```java
public interface AuditService {
  void log(AuditEventRecord record);
  Page<AuditEvent> findEvents(AuditEventFilter filter, Pageable pageable);
  List<AuditEventRepository.EventTypeCount> countEventsByType();
}
```

### Adding audit logging to a new feature requires:
1. Inject `AuditService` into the service class
2. Call `auditService.log(AuditEventBuilder.builder().eventType("entity.action").entityType("entity").entityId(id).details(...).build())` after mutations
3. Event types follow `{entity}.{action}` convention: e.g., `"invoice.created"`, `"invoice.status_changed"`

---

## 11. Invoice-Related Remnants After Reverts

### Code (backend/src)
- **No invoice Java code exists.** The `invoice/` package was fully reverted and does not exist.
- **No invoice migrations exist.** V23 was reverted and does not exist in `db/migration/tenant/`.

### Architecture & Task Files (staged deletes)
- `architecture/phase10-invoicing-billing.md` -- **DELETED** (staged delete in git)
- `tasks/phase10-invoicing-billing.md` -- **DELETED** (staged delete in git)
- `architecture/phase11-tags-custom-fields-views.md` -- **DELETED** (staged delete in git)
- `tasks/phase11-tags-custom-fields-views.md` -- **DELETED** (staged delete in git)

### ADR Files (still exist on disk)
- `adr/ADR-048-invoice-numbering-strategy.md`
- `adr/ADR-049-line-item-granularity.md`
- `adr/ADR-050-double-billing-prevention.md`
- `adr/ADR-051-psp-adapter-design.md`
- `adr/ADR-052-jsonb-vs-eav-custom-field-storage.md` (Phase 11)
- `adr/ADR-053-field-pack-seeding-strategy.md` (Phase 11)
- `adr/ADR-054-tag-storage-join-table-vs-array.md` (Phase 11)
- `adr/ADR-055-saved-view-filter-execution.md` (Phase 11)

### Requirements Files (still exist on disk)
- `requirements/claude-code-prompt-phase10.md`
- `requirements/claude-code-prompt-phase11.md`

### References in Other Files
- `architecture/phase8-rate-cards-budgets-profitability.md` -- mentions "invoice" in context of rate snapshotting rationale
- `frontend/__tests__/components/documents/customer-documents-panel.test.tsx` -- uses "invoice.xlsx" as test fixture filename (unrelated to invoice feature)

### Summary
The Phase 10 invoice code was fully reverted (5 revert commits visible in recent git log). Architecture docs and task files are staged for deletion. ADRs and requirements prompts still exist on disk. No invoice entities, migrations, or backend code remain in the working tree.

---

## 12. BillingRate Entity (Full Source)

Critical for understanding rate snapshots on TimeEntry. BillingRate uses a 3-level scope hierarchy: MEMBER_DEFAULT < CUSTOMER_OVERRIDE < PROJECT_OVERRIDE.

```java
package io.b2mash.b2b.b2bstrawman.billingrate;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "billing_rates")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class BillingRate implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "member_id", nullable = false)
  private UUID memberId;

  @Column(name = "project_id")
  private UUID projectId;

  @Column(name = "customer_id")
  private UUID customerId;

  @Column(name = "currency", nullable = false, length = 3)
  private String currency;

  @Column(name = "hourly_rate", nullable = false, precision = 12, scale = 2)
  private BigDecimal hourlyRate;

  @Column(name = "effective_from", nullable = false)
  private LocalDate effectiveFrom;

  @Column(name = "effective_to")
  private LocalDate effectiveTo;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected BillingRate() {}

  public BillingRate(
      UUID memberId,
      UUID projectId,
      UUID customerId,
      String currency,
      BigDecimal hourlyRate,
      LocalDate effectiveFrom,
      LocalDate effectiveTo) {
    this.memberId = memberId;
    this.projectId = projectId;
    this.customerId = customerId;
    this.currency = currency;
    this.hourlyRate = hourlyRate;
    this.effectiveFrom = effectiveFrom;
    this.effectiveTo = effectiveTo;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void update(
      BigDecimal hourlyRate, String currency, LocalDate effectiveFrom, LocalDate effectiveTo) {
    this.hourlyRate = hourlyRate;
    this.currency = currency;
    this.effectiveFrom = effectiveFrom;
    this.effectiveTo = effectiveTo;
    this.updatedAt = Instant.now();
  }

  /**
   * Returns the scope level of this billing rate based on which optional fields are set.
   *
   * @return "PROJECT_OVERRIDE" if projectId is set, "CUSTOMER_OVERRIDE" if customerId is set,
   *     "MEMBER_DEFAULT" otherwise
   */
  public String getScope() {
    if (projectId != null) {
      return "PROJECT_OVERRIDE";
    }
    if (customerId != null) {
      return "CUSTOMER_OVERRIDE";
    }
    return "MEMBER_DEFAULT";
  }

  public UUID getId() { return id; }
  public UUID getMemberId() { return memberId; }
  public UUID getProjectId() { return projectId; }
  public UUID getCustomerId() { return customerId; }
  public String getCurrency() { return currency; }
  public BigDecimal getHourlyRate() { return hourlyRate; }
  public LocalDate getEffectiveFrom() { return effectiveFrom; }
  public LocalDate getEffectiveTo() { return effectiveTo; }
  public Instant getCreatedAt() { return createdAt; }
  public Instant getUpdatedAt() { return updatedAt; }

  @Override
  public String getTenantId() { return tenantId; }
  @Override
  public void setTenantId(String tenantId) { this.tenantId = tenantId; }
}
```

### Rate Resolution Hierarchy (from ADR-039)
- **Level 1**: PROJECT_OVERRIDE -- rate for member + specific project (highest priority)
- **Level 2**: CUSTOMER_OVERRIDE -- rate for member + specific customer
- **Level 3**: MEMBER_DEFAULT -- base rate for member (fallback)

### Rate Snapshot on TimeEntry (from ADR-040)
When a TimeEntry is created, the resolved billing rate and cost rate are snapshotted onto the TimeEntry fields:
- `billing_rate_snapshot` (BigDecimal 12,2) + `billing_rate_currency` (3-char)
- `cost_rate_snapshot` (BigDecimal 12,2) + `cost_rate_currency` (3-char)

This ensures historical accuracy -- changing a rate later does not retroactively affect past time entries.

---

## Quick Reference Summary

| Item | Current Highest | Next Available |
|------|----------------|----------------|
| Architecture section | 10 | 11 |
| ADR number | 055 | 056 |
| Global migration | V7 | V8 |
| Tenant migration | V22 | V23 |
| Entity count | 21 | -- |
| Frontend routes | 15 pages | -- |
| Backend packages | 29 packages | -- |
| Base package | `io.b2mash.b2b.b2bstrawman` | -- |
| Entity superinterface | `TenantAware` (in `multitenancy/`) | -- |
| Entity listener | `TenantAwareEntityListener` | -- |
| Filter name | `tenantFilter` (all entities use same name) | -- |
| Migration path | `backend/src/main/resources/db/migration/tenant/` | -- |
| Migration naming | `V{N}__{description}.sql` (double underscore) | -- |
| ID strategy | UUID (generated) | -- |
| JSONB Hibernate | `@JdbcTypeCode(SqlTypes.JSON)` + `columnDefinition = "jsonb"` | -- |
