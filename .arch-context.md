# Architecture Context Inventory

Generated: 2026-02-19

---

## 1. ARCHITECTURE.md Section Headers

```
## 1. Overview                                    (line 3)
## 2. Architecture Decision Records               (line 50)
## 3. Component Architecture                      (line 409)
## 4. Sequence Diagrams                            (line 704)
## 5. Data Flow Diagrams                           (line 874)
## 6. Security Architecture                        (line 980)
## 7. Infrastructure Architecture                  (line 1083)
## 8. Database Architecture                        (line 1236)
## 9. Phase 2 — Billing & Tiered Tenancy           (line 1344)
## 10. Phase 4 — Customers, Document Scopes & Tasks (line 1874)
## Appendix A: Clerk JWT Claims                    (line 2446)
## Appendix B: Environment Variables Reference     (line 2460)
```

- **Last numbered section**: 10 (Phase 4)
- **Next available section number**: 11
- Note: Phases 5+ have their own architecture docs in `architecture/phase*-*.md`

---

## 2. ADR Numbering

Highest ADR: **ADR-067** (`ADR-067-entity-detail-page-action-surface.md`)

Next available ADR: **ADR-068**

Full list (67 ADRs):
- ADR-001 through ADR-009: inline in ARCHITECTURE.md
- ADR-010 through ADR-067: individual files in `adr/`

---

## 3. Migration Numbering

### Global migrations (`db/migration/global/`)
- V1 through V7
- **Highest**: V7 (`V7__create_portal_schema.sql`)
- **Next available**: V8

### Tenant migrations (`db/migration/tenant/`)
- V1 through V29
- **Highest**: V29 (`V29__customer_compliance_lifecycle.sql`)
- **Next available**: V30

---

## 4. Entity Inventory (38 @Entity classes)

| Entity | File |
|--------|------|
| AuditEvent | `audit/AuditEvent.java` |
| BillingRate | `billingrate/BillingRate.java` |
| ProjectBudget | `budget/ProjectBudget.java` |
| ChecklistInstance | `checklist/ChecklistInstance.java` |
| ChecklistInstanceItem | `checklist/ChecklistInstanceItem.java` |
| ChecklistTemplate | `checklist/ChecklistTemplate.java` |
| ChecklistTemplateItem | `checklist/ChecklistTemplateItem.java` |
| Comment | `comment/Comment.java` |
| CostRate | `costrate/CostRate.java` |
| Customer | `customer/Customer.java` |
| CustomerProject | `customer/CustomerProject.java` |
| DataSubjectRequest | `datarequest/DataSubjectRequest.java` |
| Document | `document/Document.java` |
| FieldDefinition | `fielddefinition/FieldDefinition.java` |
| FieldGroup | `fielddefinition/FieldGroup.java` |
| FieldGroupMember | `fielddefinition/FieldGroupMember.java` |
| Invoice | `invoice/Invoice.java` |
| InvoiceCounter | `invoice/InvoiceCounter.java` |
| InvoiceLine | `invoice/InvoiceLine.java` |
| Member | `member/Member.java` |
| ProjectMember | `member/ProjectMember.java` |
| Notification | `notification/Notification.java` |
| NotificationPreference | `notification/NotificationPreference.java` |
| MagicLinkToken | `portal/MagicLinkToken.java` |
| PortalContact | `portal/PortalContact.java` |
| Project | `project/Project.java` |
| Organization | `provisioning/Organization.java` |
| RetentionPolicy | `retention/RetentionPolicy.java` |
| OrgSettings | `settings/OrgSettings.java` |
| Tag | `tag/Tag.java` |
| EntityTag | `tag/EntityTag.java` |
| Task | `task/Task.java` |
| DocumentTemplate | `template/DocumentTemplate.java` |
| GeneratedDocument | `template/GeneratedDocument.java` |
| TimeEntry | `timeentry/TimeEntry.java` |
| SavedView | `view/SavedView.java` |
| Subscription | `billing/Subscription.java` |
| OrgSchemaMapping | `multitenancy/OrgSchemaMapping.java` |

All paths relative to `backend/src/main/java/io/b2mash/b2b/b2bstrawman/`

---

## 5. Backend Package Structure

```
io.b2mash.b2b.b2bstrawman/
├── activity/          # Activity feed
├── audit/             # AuditEvent, AuditService, AuditEventBuilder
├── billing/           # Subscription entity
├── billingrate/       # BillingRate entity, rate resolution
├── budget/            # ProjectBudget entity, budget service
├── checklist/         # ChecklistTemplate, ChecklistInstance + items
├── comment/           # Comment entity, service, controller
├── compliance/        # Compliance dashboard, setup checks
├── config/            # Spring config beans (Security, Hibernate, S3, etc.)
├── costrate/          # CostRate entity
├── customer/          # Customer, CustomerProject entities
├── customerbackend/   # Customer-facing backend APIs
├── dashboard/         # Dashboard aggregation
├── datarequest/       # DataSubjectRequest, export/anonymization
├── dev/               # Dev portal harness (local/dev only)
├── document/          # Document entity, S3 upload/download
├── event/             # Spring application events (domain events)
├── exception/         # Shared semantic exceptions
├── fielddefinition/   # FieldDefinition, FieldGroup, custom fields
├── invoice/           # Invoice, InvoiceLine, InvoiceCounter
├── member/            # Member, ProjectMember, ProjectAccessService
├── multitenancy/      # RequestScopes, connection provider, schema mapping
├── mywork/            # Cross-project "My Work" view
├── notification/      # Notification, preferences, event handler, dispatcher
├── portal/            # PortalContact, MagicLinkToken, portal auth
├── project/           # Project entity, service, controller
├── provisioning/      # Tenant provisioning, TenantMigrationRunner, Organization
├── report/            # Profitability reports
├── retention/         # RetentionPolicy entity
├── s3/                # S3 presigned URL service
├── security/          # JWT auth, API key filter, Roles
├── settings/          # OrgSettings (branding, currency)
├── tag/               # Tag, EntityTag (polymorphic join table)
├── task/              # Task entity, service, controller
├── template/          # DocumentTemplate, GeneratedDocument, rendering
├── timeentry/         # TimeEntry entity, service, controller
└── view/              # SavedView entity
```

---

## 6. Frontend Route Structure

```
frontend/app/(app)/org/[slug]/
├── compliance/
│   ├── page.tsx                    # Compliance dashboard
│   └── requests/
│       ├── page.tsx                # Data requests list
│       └── [id]/page.tsx           # Data request detail
├── customers/
│   ├── page.tsx                    # Customer list
│   └── [id]/page.tsx               # Customer detail
├── dashboard/page.tsx              # Company dashboard
├── documents/page.tsx              # Documents list
├── invoices/
│   ├── page.tsx                    # Invoice list
│   └── [id]/page.tsx               # Invoice detail
├── my-work/page.tsx                # My Work (personal)
├── notifications/page.tsx          # Notifications page
├── profitability/page.tsx          # Profitability reports
├── projects/
│   ├── page.tsx                    # Project list
│   └── [id]/page.tsx               # Project detail (11 tabs)
├── settings/
│   ├── page.tsx                    # General settings
│   ├── billing/page.tsx            # Billing/subscription
│   ├── checklists/page.tsx         # Checklist templates
│   ├── compliance/page.tsx         # Compliance settings
│   ├── custom-fields/page.tsx      # Custom field management
│   ├── notifications/page.tsx      # Notification preferences
│   ├── rates/page.tsx              # Rate card management
│   ├── tags/page.tsx               # Tag management
│   └── templates/
│       ├── page.tsx                # Document template list
│       ├── new/page.tsx            # New template
│       └── [id]/edit/page.tsx      # Edit template
└── team/page.tsx                   # Team members
```

---

## 7. Entity Reference Patterns

### Project Entity (full source)

```java
package io.b2mash.b2b.b2bstrawman.project;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

@Entity
@Table(name = "projects")
public class Project {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "name", nullable = false, length = 255)
  private String name;

  @Column(name = "description", columnDefinition = "TEXT")
  private String description;

  @Column(name = "created_by", nullable = false)
  private UUID createdBy;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "custom_fields", columnDefinition = "jsonb")
  private Map<String, Object> customFields = new HashMap<>();

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "applied_field_groups", columnDefinition = "jsonb")
  private List<UUID> appliedFieldGroups;

  protected Project() {}

  public Project(String name, String description, UUID createdBy) {
    this.name = name;
    this.description = description;
    this.createdBy = createdBy;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  // getters, update(), setCustomFields(), setAppliedFieldGroups() ...
}
```

### Task Entity (full source)

```java
package io.b2mash.b2b.b2bstrawman.task;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import java.time.Instant;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

@Entity
@Table(name = "tasks")
public class Task {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "project_id", nullable = false)
  private UUID projectId;

  @Column(name = "title", nullable = false, length = 500)
  private String title;

  @Column(name = "description", columnDefinition = "TEXT")
  private String description;

  @Column(name = "status", nullable = false, length = 20)
  private String status;

  @Column(name = "priority", nullable = false, length = 20)
  private String priority;

  @Column(name = "type", length = 100)
  private String type;

  @Column(name = "assignee_id")
  private UUID assigneeId;

  @Column(name = "created_by", nullable = false)
  private UUID createdBy;

  @Column(name = "due_date")
  private LocalDate dueDate;

  @Version
  @Column(name = "version", nullable = false)
  private int version;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "custom_fields", columnDefinition = "jsonb")
  private Map<String, Object> customFields = new HashMap<>();

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "applied_field_groups", columnDefinition = "jsonb")
  private List<UUID> appliedFieldGroups;

  protected Task() {}

  public Task(UUID projectId, String title, String description, String priority,
      String type, LocalDate dueDate, UUID createdBy) {
    this.projectId = projectId;
    this.title = title;
    this.description = description;
    this.status = "OPEN";
    this.priority = priority != null ? priority : "MEDIUM";
    this.type = type;
    this.dueDate = dueDate;
    this.createdBy = createdBy;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void update(String title, String description, String priority,
      String status, String type, LocalDate dueDate, UUID assigneeId) { ... }
  public void claim(UUID memberId) { ... }
  public void release() { ... }
  // getters ...
}
```

### Tag Entity (full source)

```java
package io.b2mash.b2b.b2bstrawman.tag;

import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "tags")
public class Tag {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "name", nullable = false, length = 50)
  private String name;

  @Column(name = "slug", nullable = false, length = 50)
  private String slug;

  @Column(name = "color", length = 7)
  private String color;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected Tag() {}

  public Tag(String name, String color) {
    this.name = name;
    this.slug = generateSlug(name);
    this.color = color;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public static String generateSlug(String name) {
    if (name == null || name.isBlank()) {
      throw new InvalidStateException("Invalid name", "Name must not be blank");
    }
    String slug = name.toLowerCase().replaceAll("[\\s-]+", "_").replaceAll("[^a-z0-9_]", "");
    if (slug.isEmpty() || !Character.isLetter(slug.charAt(0))) {
      throw new InvalidStateException("Invalid slug", "Generated slug must start with a letter: " + slug);
    }
    if (!slug.matches("^[a-z][a-z0-9_]*$")) {
      throw new InvalidStateException("Invalid slug", "Slug must match ^[a-z][a-z0-9_]*$: " + slug);
    }
    return slug;
  }

  public void updateMetadata(String name, String color) {
    this.name = name;
    this.color = color;
    this.updatedAt = Instant.now();
  }

  public void setSlug(String slug) { this.slug = slug; }
  // getters ...
}
```

### EntityTag Entity (full source)

```java
package io.b2mash.b2b.b2bstrawman.tag;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "entity_tags")
public class EntityTag {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "tag_id", nullable = false)
  private UUID tagId;

  @Column(name = "entity_type", nullable = false, length = 20)
  private String entityType;

  @Column(name = "entity_id", nullable = false)
  private UUID entityId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  protected EntityTag() {}

  public EntityTag(UUID tagId, String entityType, UUID entityId) {
    this.tagId = tagId;
    this.entityType = entityType;
    this.entityId = entityId;
    this.createdAt = Instant.now();
  }

  // getters ...
}
```

### Customer Entity (key fields)

```java
@Entity
@Table(name = "customers")
public class Customer {
  UUID id;
  String name, email, phone, idNumber, status, notes;
  UUID createdBy;
  Instant createdAt, updatedAt;
  Map<String, Object> customFields;      // JSONB
  List<UUID> appliedFieldGroups;          // JSONB
  CustomerType customerType;              // INDIVIDUAL, COMPANY (enum)
  LifecycleStatus lifecycleStatus;        // ACTIVE, ONBOARDING, OFFBOARDED, etc. (enum)
  Instant lifecycleStatusChangedAt;
  UUID lifecycleStatusChangedBy;
  Instant offboardedAt;

  // Methods: update(), archive(), transitionLifecycleStatus(), anonymize()
}
```

### ChecklistTemplate Entity (full source)

```java
package io.b2mash.b2b.b2bstrawman.checklist;

import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;
import java.util.regex.Pattern;

@Entity
@Table(name = "checklist_templates")
public class ChecklistTemplate {

  private static final Pattern SLUG_PATTERN = Pattern.compile("^[a-z][a-z0-9-]*$");

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "name", nullable = false, length = 200)
  private String name;

  @Column(name = "slug", nullable = false, length = 200)
  private String slug;

  @Column(name = "description", columnDefinition = "TEXT")
  private String description;

  @Column(name = "customer_type", nullable = false, length = 20)
  private String customerType;

  @Column(name = "source", nullable = false, length = 20)
  private String source;

  @Column(name = "pack_id", length = 100)
  private String packId;

  @Column(name = "pack_template_key", length = 100)
  private String packTemplateKey;

  @Column(name = "active", nullable = false)
  private boolean active;

  @Column(name = "auto_instantiate", nullable = false)
  private boolean autoInstantiate;

  @Column(name = "sort_order", nullable = false)
  private int sortOrder;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected ChecklistTemplate() {}

  public ChecklistTemplate(String name, String description, String slug,
      String customerType, String source, boolean autoInstantiate) {
    this.name = name;
    this.description = description;
    this.slug = slug;
    this.customerType = customerType;
    this.source = source;
    this.active = true;
    this.autoInstantiate = autoInstantiate;
    this.sortOrder = 0;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public static String generateSlug(String name) { ... }
  public void update(String name, String description, boolean autoInstantiate) { ... }
  public void deactivate() { ... }
  // pack seeder setters: setPackId(), setPackTemplateKey(), setSortOrder(), setSource(), setActive()
  // getters ...
}
```

---

## 8. Recent ADR Format Template (ADR-067)

```markdown
# ADR-067: Entity Detail Pages as Contextual Action Surface

**Status**: Accepted

**Context**:

[2-3 paragraphs describing the problem space and what prompted this decision]

**Options Considered**:

1. **Option name (chosen)** — Brief description.
   - Pros: ...
   - Cons: ...

2. **Option name** — Brief description.
   - Pros: ...
   - Cons: ...

3. **Option name** — Brief description.
   - Pros: ...
   - Cons: ...

**Decision**: Option N — [short summary].

**Rationale**:

[2-4 paragraphs explaining why this option was selected]

**Consequences**:

- Positive:
  - [bullet points]
- Negative:
  - [bullet points with mitigations]
```

---

## 9. Scheduler Patterns

Only one `@Scheduled` annotation in the codebase:

```java
// portal/MagicLinkCleanupService.java
@Scheduled(fixedRate = 3600000) // hourly
public void cleanupExpiredTokens() {
    Instant cutoff = Instant.now().minus(1, ChronoUnit.DAYS);
    // ...
}
```

Pattern: `fixedRate` in milliseconds. The service iterates all tenant schemas using the same pattern as TenantMigrationRunner.

---

## 10. TenantMigrationRunner (full source)

```java
package io.b2mash.b2b.b2bstrawman.provisioning;

import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import javax.sql.DataSource;
import org.flywaydb.core.Flyway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class TenantMigrationRunner implements ApplicationRunner {

  private static final Logger log = LoggerFactory.getLogger(TenantMigrationRunner.class);

  private final OrgSchemaMappingRepository mappingRepository;
  private final DataSource migrationDataSource;

  public TenantMigrationRunner(
      OrgSchemaMappingRepository mappingRepository,
      @Qualifier("migrationDataSource") DataSource migrationDataSource) {
    this.mappingRepository = mappingRepository;
    this.migrationDataSource = migrationDataSource;
  }

  @Override
  public void run(ApplicationArguments args) {
    var allMappings = mappingRepository.findAll();
    if (allMappings.isEmpty()) {
      log.info("No tenant schemas found — skipping per-tenant migrations");
      return;
    }

    log.info("Running tenant migrations for {} schemas", allMappings.size());
    for (var mapping : allMappings) {
      try {
        migrateSchema(mapping.getSchemaName());
      } catch (Exception e) {
        log.error("Failed to migrate schema {}", mapping.getSchemaName(), e);
      }
    }
    log.info("Tenant migration runner completed");
  }

  private void migrateSchema(String schemaName) {
    var result =
        Flyway.configure()
            .dataSource(migrationDataSource)
            .locations("classpath:db/migration/tenant")
            .schemas(schemaName)
            .baselineOnMigrate(true)
            .load()
            .migrate();
    log.info("Migrated schema {} — {} migrations applied", schemaName, result.migrationsExecuted);
  }
}
```

**Tenant iteration pattern**: `mappingRepository.findAll()` returns all `OrgSchemaMapping` rows. Each has `.getSchemaName()`. Use `ScopedValue.where(RequestScopes.TENANT_ID, schemaName).run(...)` for tenant-scoped operations.

---

## 11. Notification + Audit Event Publishing Pattern

From `CommentService.createComment()` — the canonical example of a service method that does both:

```java
@Service
public class CommentService {

  private final AuditService auditService;
  private final ApplicationEventPublisher eventPublisher;
  // ... other deps injected via constructor

  @Transactional
  public Comment createComment(UUID projectId, String entityType, UUID entityId,
      String body, String visibility, UUID memberId, String orgRole) {

    // 1. Business logic + save
    var comment = new Comment(entityType, entityId, projectId, memberId, body, resolvedVisibility);
    comment = commentRepository.save(comment);

    // 2. Audit event (synchronous, within transaction)
    auditService.log(
        AuditEventBuilder.builder()
            .eventType("comment.created")
            .entityType("comment")
            .entityId(comment.getId())
            .details(Map.of(
                "body", body,
                "project_id", projectId.toString(),
                "entity_type", entityType,
                "entity_id", entityId.toString(),
                "visibility", resolvedVisibility))
            .build());

    // 3. Domain event (triggers notification via @TransactionalEventListener AFTER_COMMIT)
    String actorName = resolveActorName(memberId);
    String tenantId = RequestScopes.TENANT_ID.isBound() ? RequestScopes.TENANT_ID.get() : null;
    String orgId = RequestScopes.ORG_ID.isBound() ? RequestScopes.ORG_ID.get() : null;
    eventPublisher.publishEvent(
        new CommentCreatedEvent(
            "comment.created", "comment", comment.getId(), projectId,
            memberId, actorName, tenantId, orgId, Instant.now(),
            Map.of("body", body), entityType, entityId, resolvedVisibility));

    return comment;
  }
}
```

**Key patterns**:
- `AuditService.log()` takes an `AuditEventRecord` built via `AuditEventBuilder` (auto-populates actorId, actorType, source, IP, user-agent from request context)
- Domain events use Spring `ApplicationEventPublisher.publishEvent()` with custom event records from the `event/` package
- `NotificationEventHandler` listens with `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)` and calls `NotificationService.handleXxx()` then `NotificationDispatcher.dispatchAll()`
- Events carry `tenantId` and `orgId` because the `@TransactionalEventListener` runs outside the original request scope

---

## 12. Tag + EntityTag Reference (for TemplateTag pattern)

See Section 7 above for full source of both entities.

**Key design decisions (ADR-054)**:
- Tags use a join table (`entity_tags`) rather than a JSONB array
- `EntityTag` is polymorphic: `entity_type` (e.g., "PROJECT", "TASK", "CUSTOMER") + `entity_id`
- Tags are tenant-scoped (no `tenant_id` column needed — schema boundary provides isolation)
- Slugs are immutable after creation (external references may depend on them)
- Tag slugs use underscores: `^[a-z][a-z0-9_]*$`
- ChecklistTemplate slugs use hyphens: `^[a-z][a-z0-9-]*$`

---

## Quick Reference Summary

| Item | Current | Next Available |
|------|---------|----------------|
| ARCHITECTURE.md section | 10 | 11 |
| ADR number | 067 | 068 |
| Global migration (V) | V7 | V8 |
| Tenant migration (V) | V29 | V30 |
| Entity count | 38 | - |
| Backend packages | 37 | - |
| Frontend routes | 26 pages | - |
