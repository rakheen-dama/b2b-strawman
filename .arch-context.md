# Architecture Context Inventory

Generated: 2026-02-18

---

## 1. ARCHITECTURE.md Section Headers

File: `architecture/ARCHITECTURE.md`

```
## 1. Overview
## 2. Architecture Decision Records
## 3. Component Architecture
## 4. Sequence Diagrams
## 5. Data Flow Diagrams
## 6. Security Architecture
## 7. Infrastructure Architecture
## 8. Database Architecture
## 9. Phase 2 -- Billing & Tiered Tenancy
## 10. Phase 4 -- Customers, Document Scopes & Tasks
## Appendix A: Clerk JWT Claims
## Appendix B: Environment Variables Reference
```

- **Last numbered section**: 10 (Phase 4)
- **Next available section number**: 11
- Note: Phases 5+ have standalone architecture docs in `architecture/phase{N}-*.md`

---

## 2. ADR Numbering

Highest ADR number: **063** (`ADR-063-compliance-packs-bundled-seed-data.md`)

Next available ADR number: **064**

Full list (53 ADRs in `adr/` directory, plus ADRs 001-009 inline in ARCHITECTURE.md):

```
ADR-010-billing-integration.md
ADR-011-tiered-tenancy.md
ADR-012-row-level-isolation.md
ADR-013-plan-state-propagation.md
ADR-014-plan-enforcement.md
ADR-015-provisioning-per-tier.md
ADR-016-tier-upgrade-migration.md
ADR-017-customer-as-org-child.md
ADR-018-document-scope-model.md
ADR-019-task-claim-workflow.md
ADR-020-customer-portal-approach.md
ADR-021-time-tracking-model.md
ADR-022-time-aggregation-strategy.md
ADR-023-my-work-cross-project-query.md
ADR-024-portal-task-time-seams.md
ADR-025-audit-storage-location.md
ADR-026-audit-event-granularity.md
ADR-027-audit-retention-strategy.md
ADR-028-audit-integrity-approach.md
ADR-029-audit-logging-abstraction.md
ADR-030-magic-link-auth-for-customers.md
ADR-031-separate-portal-read-model-schema.md
ADR-032-spring-application-events-for-portal.md
ADR-033-local-only-thymeleaf-test-harness.md
ADR-034-flat-comments-with-threading-schema.md
ADR-035-activity-feed-direct-audit-query.md
ADR-036-synchronous-notification-fanout.md
ADR-037-comment-visibility-model.md
ADR-038-polling-for-notification-delivery.md
ADR-039-rate-resolution-hierarchy.md
ADR-040-point-in-time-rate-snapshotting.md
ADR-041-multi-currency-store-in-original.md
ADR-042-single-budget-per-project.md
ADR-043-margin-aware-profitability.md
ADR-044-dashboard-aggregation-caching.md
ADR-045-project-health-scoring.md
ADR-046-dashboard-charting-approach.md
ADR-047-dashboard-layout-strategy.md
ADR-048-invoice-numbering-strategy.md
ADR-049-line-item-granularity.md
ADR-050-double-billing-prevention.md
ADR-051-psp-adapter-design.md
ADR-052-jsonb-vs-eav-custom-field-storage.md
ADR-053-field-pack-seeding-strategy.md
ADR-054-tag-storage-join-table-vs-array.md
ADR-055-saved-view-filter-execution.md
ADR-056-pdf-engine-selection.md
ADR-057-template-storage.md
ADR-058-rendering-context-assembly.md
ADR-059-template-customization-model.md
ADR-060-lifecycle-status-core-field.md
ADR-061-checklist-first-class-entities.md
ADR-062-anonymization-over-hard-deletion.md
ADR-063-compliance-packs-bundled-seed-data.md
```

---

## 3. Migration Numbering

### Global Migrations (`db/migration/global/`)

Highest: **V7** (`V7__create_portal_schema.sql`)

Next available: **V8**

```
V1__create_org_schema_mapping.sql
V2__create_organizations.sql
V3__create_processed_webhooks.sql
V4__add_org_tier.sql
V5__drop_schema_name_unique.sql
V6__add_subscriptions.sql
V7__create_portal_schema.sql
```

### Tenant Migrations (`db/migration/tenant/`)

Highest: **V30** (`V30__add_branding_and_template_pack_status.sql`)

Next available: **V31**

```
V1__create_projects.sql
V2__create_documents.sql
V3__create_members.sql
V4__migrate_ownership_to_members.sql
V5__create_project_members.sql
V6__add_missing_fk_indexes.sql
V7__add_tenant_id_for_shared.sql
V8__shared_schema_member_unique.sql
V9__create_customers.sql
V10__create_customer_projects.sql
V11__create_tasks.sql
V12__extend_documents_scope.sql
V13__create_time_entries.sql
V14__create_audit_events.sql
V15__create_comments.sql
V16__create_notifications.sql
V17__create_notification_preferences.sql
V18__create_portal_contacts_and_magic_link_tokens.sql
V19__create_rate_budget_tables.sql
V20__add_time_entry_rate_snapshots.sql
V21__add_project_budget_version.sql
V22__add_dashboard_indexes.sql
V23__create_invoices.sql
V24__add_field_definitions_groups.sql
V25__add_tags.sql
V26__add_field_pack_status.sql
V27__add_custom_field_columns.sql
V28__add_saved_views.sql
V29__create_document_templates.sql
V30__add_branding_and_template_pack_status.sql
```

---

## 4. Entity Inventory

37 `@Entity` classes total:

| Entity | File (relative to backend/src/main/java/io/b2mash/b2b/b2bstrawman/) | Schema |
|--------|----------------------------------------------------------------------|--------|
| OrgSchemaMapping | multitenancy/OrgSchemaMapping.java | public |
| Organization | provisioning/Organization.java | public |
| Subscription | billing/Subscription.java | public |
| Project | project/Project.java | tenant (TenantAware) |
| Document | document/Document.java | tenant (TenantAware) |
| Member | member/Member.java | tenant (TenantAware) |
| ProjectMember | member/ProjectMember.java | tenant (TenantAware) |
| Customer | customer/Customer.java | tenant (TenantAware) |
| CustomerProject | customer/CustomerProject.java | tenant (TenantAware) |
| Task | task/Task.java | tenant (TenantAware) |
| TimeEntry | timeentry/TimeEntry.java | tenant (TenantAware) |
| AuditEvent | audit/AuditEvent.java | tenant (TenantAware) |
| Comment | comment/Comment.java | tenant (TenantAware) |
| Notification | notification/Notification.java | tenant (TenantAware) |
| NotificationPreference | notification/NotificationPreference.java | tenant (TenantAware) |
| PortalContact | portal/PortalContact.java | tenant (TenantAware) |
| MagicLinkToken | portal/MagicLinkToken.java | tenant (no TenantAware) |
| OrgSettings | settings/OrgSettings.java | tenant (TenantAware) |
| BillingRate | billingrate/BillingRate.java | tenant (TenantAware) |
| CostRate | costrate/CostRate.java | tenant (TenantAware) |
| ProjectBudget | budget/ProjectBudget.java | tenant (TenantAware) |
| Invoice | invoice/Invoice.java | tenant (TenantAware) |
| InvoiceLine | invoice/InvoiceLine.java | tenant (TenantAware) |
| InvoiceCounter | invoice/InvoiceCounter.java | tenant (no TenantAware) |
| FieldDefinition | fielddefinition/FieldDefinition.java | tenant (TenantAware) |
| FieldGroup | fielddefinition/FieldGroup.java | tenant (TenantAware) |
| FieldGroupMember | fielddefinition/FieldGroupMember.java | tenant (TenantAware) |
| Tag | tag/Tag.java | tenant (TenantAware) |
| EntityTag | tag/EntityTag.java | tenant (TenantAware) |
| SavedView | view/SavedView.java | tenant (TenantAware) |
| DocumentTemplate | template/DocumentTemplate.java | tenant (TenantAware) |
| GeneratedDocument | template/GeneratedDocument.java | tenant (TenantAware) |

---

## 5. Backend Package Structure

Base: `io.b2mash.b2b.b2bstrawman`

```
activity/          -- Activity feed service (reads audit events)
audit/             -- AuditEvent entity, repository, service, controller, builder
billing/           -- Subscription entity, SubscriptionService, PlanSyncService
billingrate/       -- BillingRate entity, repository, service, controller
budget/            -- ProjectBudget entity, repository, service, BudgetCheckService
comment/           -- Comment entity, repository, service, controller
config/            -- Spring config beans (Security, S3, Cors, DevPortal, etc.)
costrate/          -- CostRate entity, repository, service, controller
customer/          -- Customer + CustomerProject entities, services, controllers
customerbackend/   -- Customer-facing backend APIs (portal backend)
dashboard/         -- Dashboard aggregation service, controller
dev/               -- Dev portal controller (Thymeleaf test harness)
document/          -- Document entity, repository, service, controller
event/             -- Spring application event classes
exception/         -- Shared semantic exceptions
fielddefinition/   -- FieldDefinition, FieldGroup, FieldGroupMember, FieldPackSeeder
invoice/           -- Invoice, InvoiceLine, InvoiceCounter, InvoiceNumberService
member/            -- Member, ProjectMember entities, MemberSyncService
multitenancy/      -- RequestScopes, OrgSchemaMapping, TenantFilter, ConnectionProvider, Config
mywork/            -- "My Work" cross-project service, controller
notification/      -- Notification, NotificationPreference, channel/, template/
portal/            -- PortalContact, MagicLinkToken, magic link service
project/           -- Project entity, ProjectAccessService, controller
provisioning/      -- TenantProvisioningService, TenantUpgradeService, TenantMigrationRunner
report/            -- Profitability report service, controller
s3/                -- S3 presigned URL service
security/          -- ClerkJwtAuthFilter, ApiKeyAuthFilter, ClerkJwtUtils
settings/          -- OrgSettings entity, repository, service, controller
tag/               -- Tag, EntityTag entities, services, controllers
task/              -- Task entity, repository, service, controller
template/          -- DocumentTemplate, GeneratedDocument, TemplatePackSeeder, rendering
timeentry/         -- TimeEntry entity, repository, service, controller
view/              -- SavedView entity, ViewFilterService, filter handlers
```

---

## 6. Shared-Schema Infrastructure (Full Source)

### 6.1 TenantAware.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

/**
 * Marker interface for entities that participate in shared-schema row-level isolation. Entities
 * implementing this interface have a {@code tenant_id} column that is populated by {@link
 * TenantAwareEntityListener} on persist when operating within the {@code tenant_shared} schema.
 */
public interface TenantAware {

  String getTenantId();

  void setTenantId(String tenantId);
}
```

### 6.2 TenantInfo.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import io.b2mash.b2b.b2bstrawman.provisioning.Tier;

/**
 * Cached tenant resolution result. Replaces the plain String (schema name) in TenantFilter's
 * Caffeine cache, adding tier awareness for Phase 2.
 *
 * @param schemaName the Postgres schema name (e.g., "tenant_a1b2c3d4e5f6" or "tenant_shared")
 * @param tier the organization's current tier (STARTER or PRO)
 */
public record TenantInfo(String schemaName, Tier tier) {}
```

### 6.3 TenantAwareEntityListener.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import jakarta.persistence.PrePersist;

/**
 * JPA entity listener that sets {@code tenant_id} on new entities when operating in the shared
 * schema ({@code tenant_shared}). For dedicated schemas, this is a no-op -- {@code tenant_id} stays
 * null.
 *
 * <p>Reads {@link RequestScopes#TENANT_ID} to determine if the current request targets the shared
 * schema, and {@link RequestScopes#ORG_ID} for the Clerk org ID to use as the row discriminator.
 *
 * @see TenantAware
 */
public class TenantAwareEntityListener {

  private static final String SHARED_SCHEMA = "tenant_shared";

  @PrePersist
  public void setTenantId(Object entity) {
    if (entity instanceof TenantAware tenantAware
        && RequestScopes.TENANT_ID.isBound()
        && SHARED_SCHEMA.equals(RequestScopes.TENANT_ID.get())
        && RequestScopes.ORG_ID.isBound()) {
      tenantAware.setTenantId(RequestScopes.ORG_ID.get());
    }
  }
}
```

### 6.4 TenantFilterTransactionManager.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import org.hibernate.Session;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.orm.jpa.EntityManagerHolder;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionSynchronizationManager;

/**
 * Custom transaction manager that activates Hibernate's {@code @Filter("tenantFilter")} for
 * shared-schema tenants. Overrides {@link #doBegin} to enable the filter on the <em>same</em>
 * Session that will execute queries -- this is the critical guarantee that AOP-based approaches
 * could not provide.
 *
 * <p>For dedicated-schema tenants (Pro tier), this is a no-op -- schema-level isolation is
 * sufficient.
 */
public class TenantFilterTransactionManager extends JpaTransactionManager {

  private static final Logger log = LoggerFactory.getLogger(TenantFilterTransactionManager.class);

  private static final String SHARED_SCHEMA = "tenant_shared";
  private static final String FILTER_NAME = "tenantFilter";
  private static final String FILTER_PARAM = "tenantId";

  public TenantFilterTransactionManager(jakarta.persistence.EntityManagerFactory emf) {
    super(emf);
  }

  @Override
  protected void doBegin(Object transaction, TransactionDefinition definition) {
    super.doBegin(transaction, definition);

    if (RequestScopes.TENANT_ID.isBound()
        && SHARED_SCHEMA.equals(RequestScopes.TENANT_ID.get())
        && RequestScopes.ORG_ID.isBound()) {
      String orgId = RequestScopes.ORG_ID.get();
      // Get the Session from the EntityManager that super.doBegin() just bound.
      // Avoids sessionFactory.getCurrentSession() which can fail due to field shadowing
      // between our class and JpaTransactionManager's internal sessionFactory reference.
      var emHolder =
          (EntityManagerHolder)
              TransactionSynchronizationManager.getResource(getEntityManagerFactory());
      if (emHolder != null) {
        Session session = emHolder.getEntityManager().unwrap(Session.class);
        session.enableFilter(FILTER_NAME).setParameter(FILTER_PARAM, orgId);
        log.debug("Enabled tenantFilter for org {} on session {}", orgId, session.hashCode());
      }
    }
  }
}
```

### 6.5 TenantFilter.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.b2mash.b2b.b2bstrawman.security.ClerkJwtUtils;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.time.Duration;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class TenantFilter extends OncePerRequestFilter {

  private final OrgSchemaMappingRepository mappingRepository;
  private final Cache<String, TenantInfo> tenantCache =
      Caffeine.newBuilder().maximumSize(10_000).expireAfterWrite(Duration.ofHours(1)).build();

  public TenantFilter(OrgSchemaMappingRepository mappingRepository) {
    this.mappingRepository = mappingRepository;
  }

  /** Evicts the cached tenant info for the given Clerk org ID. */
  public void evictSchema(String clerkOrgId) {
    tenantCache.invalidate(clerkOrgId);
  }

  @Override
  protected void doFilterInternal(
      HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

    if (authentication instanceof JwtAuthenticationToken jwtAuth) {
      Jwt jwt = jwtAuth.getToken();
      String orgId = ClerkJwtUtils.extractOrgId(jwt);

      if (orgId != null) {
        TenantInfo info = resolveTenant(orgId);
        if (info != null) {
          ScopedFilterChain.runScoped(
              ScopedValue.where(RequestScopes.TENANT_ID, info.schemaName())
                  .where(RequestScopes.ORG_ID, orgId),
              filterChain,
              request,
              response);
          return;
        } else {
          response.sendError(HttpServletResponse.SC_FORBIDDEN, "Organization not provisioned");
          return;
        }
      }
    }

    // No JWT or no org claim -- continue unbound (actuator, unauthenticated paths)
    filterChain.doFilter(request, response);
  }

  @Override
  protected boolean shouldNotFilter(HttpServletRequest request) {
    String path = request.getRequestURI();
    return path.startsWith("/internal/")
        || path.startsWith("/actuator/")
        || path.startsWith("/portal/");
  }

  private TenantInfo resolveTenant(String clerkOrgId) {
    // Caffeine's cache.get(key, loader) throws NPE if loader returns null.
    // Use getIfPresent + manual put to handle unprovisioned orgs gracefully.
    TenantInfo cached = tenantCache.getIfPresent(clerkOrgId);
    if (cached != null) {
      return cached;
    }
    TenantInfo info = lookupTenant(clerkOrgId);
    if (info != null) {
      tenantCache.put(clerkOrgId, info);
    }
    return info;
  }

  private TenantInfo lookupTenant(String clerkOrgId) {
    return mappingRepository.findTenantInfoByClerkOrgId(clerkOrgId).orElse(null);
  }
}
```

### 6.6 SchemaMultiTenantConnectionProvider.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.regex.Pattern;
import javax.sql.DataSource;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class SchemaMultiTenantConnectionProvider implements MultiTenantConnectionProvider<String> {

  private static final Logger log =
      LoggerFactory.getLogger(SchemaMultiTenantConnectionProvider.class);

  private static final String SHARED_SCHEMA = "tenant_shared";
  private static final Pattern SCHEMA_PATTERN = Pattern.compile("^tenant_[0-9a-f]{12}$");
  private static final Pattern ORG_ID_PATTERN = Pattern.compile("^org_[a-zA-Z0-9_]+$");

  private final DataSource dataSource;

  public SchemaMultiTenantConnectionProvider(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  @Override
  public Connection getAnyConnection() throws SQLException {
    return dataSource.getConnection();
  }

  @Override
  public void releaseAnyConnection(Connection connection) throws SQLException {
    connection.close();
  }

  @Override
  public Connection getConnection(String tenantIdentifier) throws SQLException {
    Connection connection = getAnyConnection();
    try {
      setSearchPath(connection, tenantIdentifier);
      setCurrentTenant(connection, tenantIdentifier);
    } catch (SQLException e) {
      // Release connection on setup failure to prevent pool leak
      releaseAnyConnection(connection);
      throw e;
    }
    return connection;
  }

  @Override
  public void releaseConnection(String tenantIdentifier, Connection connection)
      throws SQLException {
    resetCurrentTenant(connection, tenantIdentifier);
    resetSearchPath(connection);
    releaseAnyConnection(connection);
  }

  @Override
  public Connection getReadOnlyConnection(String tenantIdentifier) throws SQLException {
    Connection connection = getConnection(tenantIdentifier);
    connection.setReadOnly(true);
    return connection;
  }

  @Override
  public void releaseReadOnlyConnection(String tenantIdentifier, Connection connection)
      throws SQLException {
    connection.setReadOnly(false);
    releaseConnection(tenantIdentifier, connection);
  }

  @Override
  public boolean supportsAggressiveRelease() {
    return false;
  }

  @Override
  public boolean isUnwrappableAs(Class<?> unwrapType) {
    return MultiTenantConnectionProvider.class.isAssignableFrom(unwrapType);
  }

  @Override
  @SuppressWarnings("unchecked")
  public <T> T unwrap(Class<T> unwrapType) {
    if (isUnwrappableAs(unwrapType)) {
      return (T) this;
    }
    throw new IllegalArgumentException("Cannot unwrap to " + unwrapType);
  }

  private void setSearchPath(Connection connection, String schema) throws SQLException {
    try (var stmt = connection.createStatement()) {
      stmt.execute("SET search_path TO " + sanitizeSchema(schema));
    }
  }

  private void resetSearchPath(Connection connection) throws SQLException {
    try (var stmt = connection.createStatement()) {
      stmt.execute("SET search_path TO public");
    }
  }

  /**
   * For shared schema, sets the Postgres session variable used by RLS policies. This is
   * defense-in-depth alongside the Hibernate @Filter -- catches native SQL and direct DB access.
   */
  private void setCurrentTenant(Connection connection, String schema) throws SQLException {
    if (SHARED_SCHEMA.equals(schema) && RequestScopes.ORG_ID.isBound()) {
      String orgId = RequestScopes.ORG_ID.get();
      validateOrgId(orgId);
      // Use set_config() with parameterized query to prevent SQL injection.
      // SET does not support placeholders, but set_config() does.
      try (var stmt =
          connection.prepareStatement("SELECT set_config('app.current_tenant', ?, false)")) {
        stmt.setString(1, orgId);
        stmt.execute();
      }
    }
  }

  private void resetCurrentTenant(Connection connection, String schema) throws SQLException {
    if (SHARED_SCHEMA.equals(schema)) {
      try (var stmt = connection.createStatement()) {
        stmt.execute("RESET app.current_tenant");
      }
    }
  }

  private String sanitizeSchema(String schema) {
    if ("public".equals(schema)
        || SHARED_SCHEMA.equals(schema)
        || SCHEMA_PATTERN.matcher(schema).matches()) {
      return schema;
    }
    throw new IllegalArgumentException("Invalid schema name: " + schema);
  }

  private void validateOrgId(String orgId) {
    if (!ORG_ID_PATTERN.matcher(orgId).matches()) {
      throw new IllegalArgumentException("Invalid org ID: " + orgId);
    }
  }
}
```

### 6.7 HibernateMultiTenancyConfig.java

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import jakarta.persistence.EntityManagerFactory;
import java.util.Map;
import org.hibernate.cfg.MultiTenancySettings;
import org.springframework.boot.hibernate.autoconfigure.HibernatePropertiesCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
public class HibernateMultiTenancyConfig {

  @Bean
  HibernatePropertiesCustomizer multiTenancyCustomizer(
      SchemaMultiTenantConnectionProvider connectionProvider,
      TenantIdentifierResolver tenantResolver) {
    return (Map<String, Object> hibernateProperties) -> {
      hibernateProperties.put(
          MultiTenancySettings.MULTI_TENANT_CONNECTION_PROVIDER, connectionProvider);
      hibernateProperties.put(
          MultiTenancySettings.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantResolver);
    };
  }

  @Bean
  @Primary
  PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
    return new TenantFilterTransactionManager(emf);
  }
}
```

### 6.8 TenantProvisioningService.java

```java
package io.b2mash.b2b.b2bstrawman.provisioning;

import io.b2mash.b2b.b2bstrawman.billing.SubscriptionService;
import io.b2mash.b2b.b2bstrawman.fielddefinition.FieldPackSeeder;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMapping;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.template.TemplatePackSeeder;
import java.sql.SQLException;
import javax.sql.DataSource;
import org.flywaydb.core.Flyway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;

@Service
public class TenantProvisioningService {

  private static final Logger log = LoggerFactory.getLogger(TenantProvisioningService.class);
  private static final String SHARED_SCHEMA = "tenant_shared";

  private final OrganizationRepository organizationRepository;
  private final OrgSchemaMappingRepository mappingRepository;
  private final DataSource migrationDataSource;
  private final SubscriptionService subscriptionService;
  private final FieldPackSeeder fieldPackSeeder;
  private final TemplatePackSeeder templatePackSeeder;

  public TenantProvisioningService(
      OrganizationRepository organizationRepository,
      OrgSchemaMappingRepository mappingRepository,
      @Qualifier("migrationDataSource") DataSource migrationDataSource,
      SubscriptionService subscriptionService,
      FieldPackSeeder fieldPackSeeder,
      TemplatePackSeeder templatePackSeeder) {
    this.organizationRepository = organizationRepository;
    this.mappingRepository = mappingRepository;
    this.migrationDataSource = migrationDataSource;
    this.subscriptionService = subscriptionService;
    this.fieldPackSeeder = fieldPackSeeder;
    this.templatePackSeeder = templatePackSeeder;
  }

  @Retryable(
      retryFor = ProvisioningException.class,
      noRetryFor = IllegalArgumentException.class,
      maxAttempts = 3,
      backoff = @Backoff(delay = 1000, multiplier = 2))
  public ProvisioningResult provisionTenant(String clerkOrgId, String orgName) {
    // Idempotency check: already fully provisioned?
    var existingMapping = mappingRepository.findByClerkOrgId(clerkOrgId);
    if (existingMapping.isPresent()) {
      log.info("Tenant already provisioned for org {}", clerkOrgId);
      return ProvisioningResult.alreadyProvisioned(existingMapping.get().getSchemaName());
    }

    // Create or find organization record (default tier is STARTER)
    var org =
        organizationRepository
            .findByClerkOrgId(clerkOrgId)
            .orElseGet(() -> organizationRepository.save(new Organization(clerkOrgId, orgName)));

    org.markInProgress();
    organizationRepository.save(org);
    organizationRepository.flush();

    try {
      if (org.getTier() == Tier.STARTER) {
        return provisionStarter(clerkOrgId, org);
      } else {
        return provisionPro(clerkOrgId, org);
      }
    } catch (Exception e) {
      log.error("Failed to provision tenant for org {}", clerkOrgId, e);
      org.markFailed();
      organizationRepository.save(org);
      throw new ProvisioningException("Provisioning failed for org " + clerkOrgId, e);
    }
  }

  /**
   * Starter provisioning: map to the shared schema (already bootstrapped by TenantMigrationRunner).
   * No schema creation or migration needed.
   */
  private ProvisioningResult provisionStarter(String clerkOrgId, Organization org) {
    log.info("Provisioning Starter tenant for org {} -> {}", clerkOrgId, SHARED_SCHEMA);

    createMapping(clerkOrgId, SHARED_SCHEMA);
    fieldPackSeeder.seedPacksForTenant(SHARED_SCHEMA, clerkOrgId);
    templatePackSeeder.seedPacksForTenant(SHARED_SCHEMA, clerkOrgId);
    subscriptionService.createSubscription(org.getId(), "starter");

    org.markCompleted();
    organizationRepository.save(org);

    log.info("Successfully provisioned Starter tenant for org {}", clerkOrgId);
    return ProvisioningResult.success(SHARED_SCHEMA);
  }

  /** Pro provisioning: create a dedicated schema and run migrations. */
  private ProvisioningResult provisionPro(String clerkOrgId, Organization org) throws SQLException {
    String schemaName = SchemaNameGenerator.generateSchemaName(clerkOrgId);
    log.info("Provisioning Pro tenant schema {} for org {}", schemaName, clerkOrgId);

    // Each step is idempotent -- safe to retry after partial failure.
    // Mapping is created LAST so TenantFilter only resolves to this
    // schema once all tables exist (prevents race with first request).
    createSchema(schemaName);
    runTenantMigrations(schemaName);
    fieldPackSeeder.seedPacksForTenant(schemaName, clerkOrgId);
    templatePackSeeder.seedPacksForTenant(schemaName, clerkOrgId);
    createMapping(clerkOrgId, schemaName);
    String planSlug = org.getPlanSlug() != null ? org.getPlanSlug() : "starter";
    subscriptionService.createSubscription(org.getId(), planSlug);

    org.markCompleted();
    organizationRepository.save(org);

    log.info("Successfully provisioned Pro tenant {} for org {}", schemaName, clerkOrgId);
    return ProvisioningResult.success(schemaName);
  }

  void runTenantMigrations(String schemaName) {
    Flyway.configure()
        .dataSource(migrationDataSource)
        .locations("classpath:db/migration/tenant")
        .schemas(schemaName)
        .baselineOnMigrate(true)
        .load()
        .migrate();
    log.info("Ran tenant migrations for schema {}", schemaName);
  }

  private void createSchema(String schemaName) throws SQLException {
    validateSchemaName(schemaName);
    try (var conn = migrationDataSource.getConnection();
        var stmt = conn.createStatement()) {
      // Schema name is validated to match ^tenant_[0-9a-f]{12}$ -- safe to concatenate
      stmt.execute("CREATE SCHEMA IF NOT EXISTS \"" + schemaName + "\"");
      log.info("Created schema {}", schemaName);
    }
  }

  private void createMapping(String clerkOrgId, String schemaName) {
    if (mappingRepository.findByClerkOrgId(clerkOrgId).isEmpty()) {
      mappingRepository.save(new OrgSchemaMapping(clerkOrgId, schemaName));
      log.info("Created mapping {} -> {}", clerkOrgId, schemaName);
    }
  }

  private void validateSchemaName(String schemaName) {
    if (!schemaName.matches("^tenant_[0-9a-f]{12}$")) {
      throw new IllegalArgumentException("Invalid schema name: " + schemaName);
    }
  }

  public record ProvisioningResult(boolean success, String schemaName, boolean alreadyProvisioned) {

    public static ProvisioningResult success(String schemaName) {
      return new ProvisioningResult(true, schemaName, false);
    }

    public static ProvisioningResult alreadyProvisioned(String schemaName) {
      return new ProvisioningResult(true, schemaName, true);
    }
  }
}
```

### 6.9 TenantMigrationRunner.java

```java
package io.b2mash.b2b.b2bstrawman.provisioning;

import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import javax.sql.DataSource;
import org.flywaydb.core.Flyway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class TenantMigrationRunner implements ApplicationRunner {

  private static final Logger log = LoggerFactory.getLogger(TenantMigrationRunner.class);
  static final String SHARED_SCHEMA = "tenant_shared";

  private final OrgSchemaMappingRepository mappingRepository;
  private final DataSource migrationDataSource;

  public TenantMigrationRunner(
      OrgSchemaMappingRepository mappingRepository,
      @Qualifier("migrationDataSource") DataSource migrationDataSource) {
    this.mappingRepository = mappingRepository;
    this.migrationDataSource = migrationDataSource;
  }

  @Override
  public void run(ApplicationArguments args) {
    bootstrapSharedSchema();

    var allMappings = mappingRepository.findAll();
    if (allMappings.isEmpty()) {
      log.info("No tenant schemas found -- skipping per-tenant migrations");
      return;
    }

    log.info("Running tenant migrations for {} schemas", allMappings.size());
    for (var mapping : allMappings) {
      if (SHARED_SCHEMA.equals(mapping.getSchemaName())) {
        continue; // Already migrated above
      }
      try {
        migrateSchema(mapping.getSchemaName());
      } catch (Exception e) {
        log.error("Failed to migrate schema {}", mapping.getSchemaName(), e);
      }
    }
    log.info("Tenant migration runner completed");
  }

  /**
   * Bootstraps the shared schema used by Starter-tier organizations. Creates the schema if it
   * doesn't exist and runs all tenant migrations against it. Idempotent -- Flyway tracks applied
   * versions, so subsequent startups are no-ops.
   */
  private void bootstrapSharedSchema() {
    try (Connection conn = migrationDataSource.getConnection();
        Statement stmt = conn.createStatement()) {
      stmt.execute("CREATE SCHEMA IF NOT EXISTS " + SHARED_SCHEMA);
      log.info("Ensured shared schema '{}' exists", SHARED_SCHEMA);
    } catch (SQLException e) {
      log.error("Failed to create shared schema '{}'", SHARED_SCHEMA, e);
      throw new RuntimeException("Failed to bootstrap shared schema", e);
    }

    migrateSchema(SHARED_SCHEMA);
  }

  private void migrateSchema(String schemaName) {
    var result =
        Flyway.configure()
            .dataSource(migrationDataSource)
            .locations("classpath:db/migration/tenant")
            .schemas(schemaName)
            .baselineOnMigrate(true)
            .load()
            .migrate();
    log.info("Migrated schema {} -- {} migrations applied", schemaName, result.migrationsExecuted);
  }
}
```

### 6.10 TenantUpgradeService.java

```java
package io.b2mash.b2b.b2bstrawman.provisioning;

import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantFilter;
import java.sql.SQLException;
import javax.sql.DataSource;
import org.flywaydb.core.Flyway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Service
public class TenantUpgradeService {

  private static final Logger log = LoggerFactory.getLogger(TenantUpgradeService.class);
  private static final String SHARED_SCHEMA = "tenant_shared";

  private final OrganizationRepository organizationRepository;
  private final OrgSchemaMappingRepository mappingRepository;
  private final DataSource migrationDataSource;
  private final JdbcTemplate migrationJdbc;
  private final TransactionTemplate migrationTxTemplate;
  private final TenantFilter tenantFilter;

  public TenantUpgradeService(
      OrganizationRepository organizationRepository,
      OrgSchemaMappingRepository mappingRepository,
      @Qualifier("migrationDataSource") DataSource migrationDataSource,
      TenantFilter tenantFilter) {
    this.organizationRepository = organizationRepository;
    this.mappingRepository = mappingRepository;
    this.migrationDataSource = migrationDataSource;
    this.migrationJdbc = new JdbcTemplate(migrationDataSource);
    this.tenantFilter = tenantFilter;

    var txManager = new DataSourceTransactionManager(migrationDataSource);
    this.migrationTxTemplate = new TransactionTemplate(txManager);
    this.migrationTxTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
  }

  /**
   * Upgrades a Starter org from tenant_shared to a dedicated tenant_<hash> schema. Performs schema
   * creation, Flyway migrations, data copy, atomic cutover, and cache invalidation. All steps are
   * idempotent -- safe to retry after partial failure.
   */
  public void upgrade(String clerkOrgId) {
    var org =
        organizationRepository
            .findByClerkOrgId(clerkOrgId)
            .orElseThrow(() -> new ResourceNotFoundException("Organization", clerkOrgId));

    if (org.getTier() != Tier.PRO) {
      throw new InvalidStateException(
          "Invalid tier for upgrade", "Organization " + clerkOrgId + " is not on the Pro tier");
    }

    // Already on a dedicated schema -- idempotent no-op
    var currentMapping = mappingRepository.findByClerkOrgId(clerkOrgId);
    if (currentMapping.isPresent() && !SHARED_SCHEMA.equals(currentMapping.get().getSchemaName())) {
      log.info(
          "Organization {} already on dedicated schema {}, skipping",
          clerkOrgId,
          currentMapping.get().getSchemaName());
      return;
    }

    log.info("Starting Starter -> Pro upgrade for org {}", clerkOrgId);

    // Step 1: Mark upgrade in progress
    org.markInProgress();
    organizationRepository.save(org);
    organizationRepository.flush();

    try {
      // Step 2: Generate dedicated schema name
      String newSchema = SchemaNameGenerator.generateSchemaName(clerkOrgId);
      log.info("Target schema for org {}: {}", clerkOrgId, newSchema);

      // Step 3: Create schema (idempotent)
      createSchema(newSchema);

      // Step 4: Run Flyway V1-V8 migrations
      runTenantMigrations(newSchema);

      // Step 5: Copy data from shared to dedicated
      copyData(clerkOrgId, newSchema);

      // Step 6: Atomic cutover -- update mapping + delete shared data
      atomicCutover(clerkOrgId, newSchema);

      // Step 7: Invalidate TenantFilter cache
      tenantFilter.evictSchema(clerkOrgId);

      // Step 8: Mark completed
      org.markCompleted();
      organizationRepository.save(org);

      log.info("Successfully upgraded org {} to dedicated schema {}", clerkOrgId, newSchema);
    } catch (Exception e) {
      log.error("Upgrade failed for org {}", clerkOrgId, e);
      org.markFailed();
      organizationRepository.save(org);
      throw new ProvisioningException("Tier upgrade failed for org " + clerkOrgId, e);
    }
  }

  private void createSchema(String schemaName) throws SQLException {
    validateSchemaName(schemaName);
    try (var conn = migrationDataSource.getConnection();
        var stmt = conn.createStatement()) {
      stmt.execute("CREATE SCHEMA IF NOT EXISTS \"" + schemaName + "\"");
      log.info("Created schema {}", schemaName);
    }
  }

  private void runTenantMigrations(String schemaName) {
    var result =
        Flyway.configure()
            .dataSource(migrationDataSource)
            .locations("classpath:db/migration/tenant")
            .schemas(schemaName)
            .baselineOnMigrate(true)
            .load()
            .migrate();
    log.info("Migrated schema {} -- {} migrations applied", schemaName, result.migrationsExecuted);
  }

  /** Copies data from tenant_shared to the dedicated schema, excluding tenant_id. */
  private void copyData(String clerkOrgId, String newSchema) {
    validateSchemaName(newSchema);

    // Copy order respects FK constraints: members -> projects -> documents + project_members
    int members =
        migrationJdbc.update(
            "INSERT INTO \""
                + newSchema
                + "\".members"
                + " (id, clerk_user_id, email, name, avatar_url, org_role, created_at, updated_at)"
                + " SELECT id, clerk_user_id, email, name, avatar_url, org_role, created_at,"
                + " updated_at"
                + " FROM tenant_shared.members WHERE tenant_id = ?"
                + " ON CONFLICT (id) DO NOTHING",
            clerkOrgId);

    int projects =
        migrationJdbc.update(
            "INSERT INTO \""
                + newSchema
                + "\".projects"
                + " (id, name, description, created_by, created_at, updated_at)"
                + " SELECT id, name, description, created_by, created_at, updated_at"
                + " FROM tenant_shared.projects WHERE tenant_id = ?"
                + " ON CONFLICT (id) DO NOTHING",
            clerkOrgId);

    int documents =
        migrationJdbc.update(
            "INSERT INTO \""
                + newSchema
                + "\".documents"
                + " (id, project_id, file_name, content_type, size, s3_key, status, uploaded_by,"
                + " uploaded_at, created_at)"
                + " SELECT id, project_id, file_name, content_type, size, s3_key, status,"
                + " uploaded_by, uploaded_at, created_at"
                + " FROM tenant_shared.documents WHERE tenant_id = ?"
                + " ON CONFLICT (id) DO NOTHING",
            clerkOrgId);

    int projectMembers =
        migrationJdbc.update(
            "INSERT INTO \""
                + newSchema
                + "\".project_members"
                + " (id, project_id, member_id, project_role, added_by, created_at)"
                + " SELECT id, project_id, member_id, project_role, added_by, created_at"
                + " FROM tenant_shared.project_members WHERE tenant_id = ?"
                + " ON CONFLICT (id) DO NOTHING",
            clerkOrgId);

    log.info(
        "Copied data for org {}: {} members, {} projects, {} documents, {} project_members",
        clerkOrgId,
        members,
        projects,
        documents,
        projectMembers);
  }

  /**
   * Atomically updates the schema mapping and deletes shared data in a single transaction. Delete
   * order is reverse of copy (FK constraints): project_members -> documents -> projects -> members.
   */
  private void atomicCutover(String clerkOrgId, String newSchema) {
    migrationTxTemplate.executeWithoutResult(
        status -> {
          // Update mapping to point to dedicated schema
          int updated =
              migrationJdbc.update(
                  "UPDATE public.org_schema_mapping SET schema_name = ? WHERE clerk_org_id = ?",
                  newSchema,
                  clerkOrgId);
          if (updated == 0) {
            throw new IllegalStateException("No org_schema_mapping found for org " + clerkOrgId);
          }

          // Delete shared data in reverse FK order
          int pm =
              migrationJdbc.update(
                  "DELETE FROM tenant_shared.project_members WHERE tenant_id = ?", clerkOrgId);
          int docs =
              migrationJdbc.update(
                  "DELETE FROM tenant_shared.documents WHERE tenant_id = ?", clerkOrgId);
          int proj =
              migrationJdbc.update(
                  "DELETE FROM tenant_shared.projects WHERE tenant_id = ?", clerkOrgId);
          int mem =
              migrationJdbc.update(
                  "DELETE FROM tenant_shared.members WHERE tenant_id = ?", clerkOrgId);

          log.info(
              "Atomic cutover for org {} -> {}: deleted {} project_members, {} documents,"
                  + " {} projects, {} members from shared",
              clerkOrgId,
              newSchema,
              pm,
              docs,
              proj,
              mem);
        });
  }

  private void validateSchemaName(String schemaName) {
    if (!schemaName.matches("^tenant_[0-9a-f]{12}$")) {
      throw new IllegalArgumentException("Invalid schema name: " + schemaName);
    }
  }
}
```

---

## 7. TenantAware Entities (27 classes)

All classes implementing `TenantAware`:

```
ProjectBudget          budget/ProjectBudget.java
EntityTag              tag/EntityTag.java
Tag                    tag/Tag.java
AuditEvent             audit/AuditEvent.java
Document               document/Document.java
NotificationPreference notification/NotificationPreference.java
TimeEntry              timeentry/TimeEntry.java
InvoiceLine            invoice/InvoiceLine.java
OrgSettings            settings/OrgSettings.java
SavedView              view/SavedView.java
Notification           notification/Notification.java
Invoice                invoice/Invoice.java
Project                project/Project.java
DocumentTemplate       template/DocumentTemplate.java
FieldGroup             fielddefinition/FieldGroup.java
Task                   task/Task.java
GeneratedDocument      template/GeneratedDocument.java
FieldDefinition        fielddefinition/FieldDefinition.java
BillingRate            billingrate/BillingRate.java
Member                 member/Member.java
ProjectMember          member/ProjectMember.java
FieldGroupMember       fielddefinition/FieldGroupMember.java
CostRate               costrate/CostRate.java
Comment                comment/Comment.java
CustomerProject        customer/CustomerProject.java
Customer               customer/Customer.java
PortalContact          portal/PortalContact.java
```

Entities **NOT** implementing TenantAware: `OrgSchemaMapping` (public schema), `Organization` (public schema), `Subscription` (public schema), `MagicLinkToken` (cross-tenant lookup by hash), `InvoiceCounter` (tenant_id column exists but no TenantAware interface).

---

## 8. findOneById Usage

**~248 call sites** across main and test Java files.

The pattern is used universally across all tenant-scoped repositories as the primary safe fetch method, replacing `JpaRepository.findById()` which bypasses Hibernate `@Filter`. Every repository for a `TenantAware` entity defines:

```java
@Query("SELECT e FROM Entity e WHERE e.id = :id")
Optional<Entity> findOneById(@Param("id") UUID id);
```

This ensures Hibernate `@Filter("tenantFilter")` is applied, providing tenant isolation in the shared schema.

---

## 9. Recent ADR Format Template

From ADR-063 (the highest-numbered ADR):

```markdown
# ADR-063: Compliance Packs as Bundled Seed Data

**Status**: Accepted

**Context**: [Description of the problem/question being addressed. Multiple paragraphs
explaining the background, what affects the decision, and existing patterns.]

**Options Considered**:

1. **Option name** -- [Description]
   - Pros:
     - [Pro 1]
     - [Pro 2]
   - Cons:
     - [Con 1]
     - [Con 2]

2. **Option name** -- [Description]
   - Pros: ...
   - Cons: ...

**Decision**: [Which option was chosen]

**Rationale**: [Why this option was selected over the others. References to
existing patterns and future compatibility.]

**Consequences**:
- [Concrete consequence 1]
- [Concrete consequence 2]
- [Implementation details, file locations, API shapes]
```

---

## 10. Flyway Tenant Migrations with tenant_id / RLS

17 of 30 tenant migrations contain tenant_id, RLS, or row-level security references.

### V7__add_tenant_id_for_shared.sql (FOUNDATIONAL)

The foundational migration that adds `tenant_id` column to the original 4 tables and creates RLS policies. Pattern:

1. `ALTER TABLE ... ADD COLUMN IF NOT EXISTS tenant_id VARCHAR(255)`
2. `CREATE INDEX IF NOT EXISTS idx_{table}_tenant_id ON {table} (tenant_id)`
3. `ALTER TABLE {table} ENABLE ROW LEVEL SECURITY`
4. `CREATE POLICY tenant_isolation_{table} ON {table} USING (tenant_id = current_setting('app.current_tenant', true) OR tenant_id IS NULL)`

```sql
-- V7: Add tenant_id column for shared-schema row-level isolation (ADR-012)
-- Applied to ALL tenant schemas (shared + dedicated). In dedicated schemas,
-- tenant_id stays NULL and is never read. In tenant_shared, it carries the
-- Clerk org ID for Hibernate @Filter and Postgres RLS row filtering.

-- 1. Add nullable tenant_id column to each tenant table
ALTER TABLE projects ADD COLUMN IF NOT EXISTS tenant_id VARCHAR(255);
ALTER TABLE documents ADD COLUMN IF NOT EXISTS tenant_id VARCHAR(255);
ALTER TABLE members ADD COLUMN IF NOT EXISTS tenant_id VARCHAR(255);
ALTER TABLE project_members ADD COLUMN IF NOT EXISTS tenant_id VARCHAR(255);

-- 2. Create indexes for efficient row-level filtering
CREATE INDEX IF NOT EXISTS idx_projects_tenant_id ON projects (tenant_id);
CREATE INDEX IF NOT EXISTS idx_documents_tenant_id ON documents (tenant_id);
CREATE INDEX IF NOT EXISTS idx_members_tenant_id ON members (tenant_id);
CREATE INDEX IF NOT EXISTS idx_project_members_tenant_id ON project_members (tenant_id);

-- 3. Enable Row-Level Security on all tenant tables
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE members ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_members ENABLE ROW LEVEL SECURITY;

-- 4. Create RLS policies using current_setting('app.current_tenant', true).
-- The OR tenant_id IS NULL guard allows Pro schemas (where tenant_id is always
-- NULL) to function without any filtering. In tenant_shared, tenant_id is
-- always populated by TenantAwareEntityListener.
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'tenant_isolation_projects') THEN
    EXECUTE 'CREATE POLICY tenant_isolation_projects ON projects
      USING (tenant_id = current_setting(''app.current_tenant'', true) OR tenant_id IS NULL)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'tenant_isolation_documents') THEN
    EXECUTE 'CREATE POLICY tenant_isolation_documents ON documents
      USING (tenant_id = current_setting(''app.current_tenant'', true) OR tenant_id IS NULL)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'tenant_isolation_members') THEN
    EXECUTE 'CREATE POLICY tenant_isolation_members ON members
      USING (tenant_id = current_setting(''app.current_tenant'', true) OR tenant_id IS NULL)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'tenant_isolation_project_members') THEN
    EXECUTE 'CREATE POLICY tenant_isolation_project_members ON project_members
      USING (tenant_id = current_setting(''app.current_tenant'', true) OR tenant_id IS NULL)';
  END IF;
END $$;
```

### V8__shared_schema_member_unique.sql

```sql
-- V8: Widen members unique constraint for shared-schema multitenancy.
-- In tenant_shared, the same Clerk user can be a member of multiple orgs,
-- so UNIQUE(clerk_user_id) alone would collide. Replace with
-- UNIQUE(clerk_user_id, tenant_id). For dedicated schemas where tenant_id
-- is NULL, this still enforces one row per user (NULL is unique in Postgres).

ALTER TABLE members DROP CONSTRAINT IF EXISTS uq_members_clerk_user_id;
ALTER TABLE members ADD CONSTRAINT uq_members_clerk_user_tenant
    UNIQUE (clerk_user_id, tenant_id);
```

### Standard Pattern (V9+)

Every subsequent migration that creates a new table follows this pattern. The table includes:
- `tenant_id VARCHAR(255)` column
- `CREATE INDEX IF NOT EXISTS idx_{table}_tenant_id ON {table} (tenant_id)`
- `ALTER TABLE {table} ENABLE ROW LEVEL SECURITY`
- `CREATE POLICY {name}_tenant_isolation ON {table} USING (tenant_id = current_setting('app.current_tenant', true) OR tenant_id IS NULL)`

Tables with tenant_id + RLS:
- V9: `customers`
- V10: `customer_projects`
- V11: `tasks`
- V13: `time_entries`
- V14: `audit_events` (also has append-only trigger)
- V15: `comments`
- V16: `notifications`
- V17: `notification_preferences`
- V18: `portal_contacts` (magic_link_tokens has NO tenant_id -- cross-tenant lookup)
- V19: `org_settings`, `billing_rates`, `cost_rates`, `project_budgets`
- V23: `invoices`, `invoice_lines`, `invoice_counters`
- V24: `field_definitions`, `field_groups`, `field_group_members`
- V25: `tags`, `entity_tags`
- V28: `saved_views`
- V29: `document_templates`, `generated_documents`

### Notable Variations

**Invoice number uniqueness (V23)** -- Dual partial unique indexes:
```sql
-- Per-schema for Pro (tenant_id IS NULL):
CREATE UNIQUE INDEX idx_invoices_number_unique
    ON invoices (invoice_number) WHERE invoice_number IS NOT NULL AND tenant_id IS NULL;
-- Per-tenant for Starter (tenant_id IS NOT NULL):
CREATE UNIQUE INDEX idx_invoices_tenant_number_unique
    ON invoices (tenant_id, invoice_number) WHERE invoice_number IS NOT NULL AND tenant_id IS NOT NULL;
```

**Document template slug uniqueness (V29)** -- Same dual-index pattern:
```sql
CREATE UNIQUE INDEX idx_document_templates_slug_dedicated
    ON document_templates (slug) WHERE tenant_id IS NULL;
CREATE UNIQUE INDEX idx_document_templates_slug_shared
    ON document_templates (tenant_id, slug) WHERE tenant_id IS NOT NULL;
```

**Field definitions (V24)** -- Uses `VARCHAR(100)` for tenant_id instead of `VARCHAR(255)`.

---

## 11. Test Files Referencing Shared Schema

Key test files that test shared-schema multitenancy:

| Test File | What It Tests |
|-----------|---------------|
| `multitenancy/StarterTenantIntegrationTest.java` | Two Starter orgs in `tenant_shared`, CRUD isolation |
| `multitenancy/MixedTenantIntegrationTest.java` | Starter + Pro orgs, cross-tier isolation |
| `provisioning/ProvisioningIntegrationTest.java` | Starter provisioning maps to `tenant_shared` |
| `provisioning/TenantProvisioningServiceTest.java` | Unit tests for provisioning logic |
| `provisioning/TierUpgradeIntegrationTest.java` | Starter->Pro data migration from `tenant_shared` |
| `billing/BillingUpgradeIntegrationTest.java` | Billing tier upgrade with schema change |
| `task/TaskStarterTenantIntegrationTest.java` | Task CRUD isolation in `tenant_shared` |
| `timeentry/TimeEntrySharedSchemaIntegrationTest.java` | Time entry isolation in `tenant_shared` |
| `audit/AuditTenantIsolationTest.java` | Audit event isolation + append-only enforcement |
| `audit/InternalAuditControllerTest.java` | Internal audit API with `tenant_shared` |
| `tag/TagIntegrationTest.java` | Tag operations in `tenant_shared` |
| `view/SavedViewIntegrationTest.java` | Saved view operations in `tenant_shared` |

---

## 12. Services Using setTenantId

`setTenantId` appears in two categories:

1. **TenantAwareEntityListener** (the only runtime caller):
   ```java
   tenantAware.setTenantId(RequestScopes.ORG_ID.get());
   ```
   Called via `@PrePersist` on any `TenantAware` entity when in `tenant_shared`.

2. **Entity implementations** (27 TenantAware entities): Each has a `setTenantId(String)` method that sets the `tenant_id` field.

No services call `setTenantId` directly. The `TenantAwareEntityListener` handles all tenant_id population automatically via JPA lifecycle.

---

## 13. ViewFilterService

Full source at: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/view/ViewFilterService.java`

Key design points:
- Builds SQL WHERE clauses from SavedView filter JSONB
- Delegates to handler classes: `StatusFilterHandler`, `TagFilterHandler`, `CustomFieldFilterHandler`, `DateRangeFilterHandler`, `SearchFilterHandler`
- **Explicit tenant isolation**: Since native queries bypass Hibernate `@Filter`, adds `e.tenant_id = :tenantOrgId` to all queries using `RequestScopes.ORG_ID`
- Allowlisted table names: `projects`, `tasks`, `customers`
- Three convenience methods: generic, by entity type, scoped to project

---

## 14. OrgSchemaMappingRepository

Full source at: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/OrgSchemaMappingRepository.java`

```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface OrgSchemaMappingRepository extends JpaRepository<OrgSchemaMapping, UUID> {
  Optional<OrgSchemaMapping> findByClerkOrgId(String clerkOrgId);

  @Query(
      """
      SELECT new io.b2mash.b2b.b2bstrawman.multitenancy.TenantInfo(m.schemaName, o.tier)
      FROM OrgSchemaMapping m JOIN io.b2mash.b2b.b2bstrawman.provisioning.Organization o
        ON m.clerkOrgId = o.clerkOrgId
      WHERE m.clerkOrgId = :clerkOrgId
      """)
  Optional<TenantInfo> findTenantInfoByClerkOrgId(String clerkOrgId);
}
```

The `findTenantInfoByClerkOrgId` query joins `OrgSchemaMapping` with `Organization` to return both the schema name and the tier in a single query. This is used by `TenantFilter` for tenant resolution with tier awareness.

---

## Quick Reference Summary

| Item | Current Highest | Next Available |
|------|----------------|----------------|
| ARCHITECTURE.md section | 10 | 11 |
| ADR number | 063 | 064 |
| Global migration | V7 | V8 |
| Tenant migration | V30 | V31 |
| Entity count | 37 total | -- |
| TenantAware entities | 27 | -- |
| Backend packages | 33 | -- |
| findOneById call sites | ~248 | -- |
