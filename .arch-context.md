# Architecture Context Inventory

Generated: 2026-02-25

---

## 1. ARCHITECTURE.md Section Headers

```
## 1. Overview
## 2. Architecture Decision Records
## 3. Component Architecture
## 4. Sequence Diagrams
## 5. Data Flow Diagrams
## 6. Security Architecture
## 7. Infrastructure Architecture
## 8. Database Architecture
## 9. Phase 2 — Billing & Tiered Tenancy
## 10. Phase 4 — Customers, Document Scopes & Tasks
## Appendix A: Clerk JWT Claims
## Appendix B: Environment Variables Reference
```

- **Last numbered section**: 10
- **Next available section number**: 11
- Note: Phases 5+ have separate architecture docs in `architecture/phase{N}-*.md`

---

## 2. ADR Numbering

**Highest ADR**: ADR-094 (`ADR-094-conditional-field-visibility.md`)
**Next available ADR**: ADR-095

All ADR files (94 total):
```
ADR-010 through ADR-094
(ADR-001 through ADR-009 are inline in ARCHITECTURE.md)
```

---

## 3. Migration Numbering

### Global Migrations (`db/migration/global/`)
```
V1__create_org_schema_mapping.sql
V2__create_organizations.sql
V3__create_processed_webhooks.sql
V4__add_org_tier.sql
V5__drop_schema_name_unique.sql
V6__add_subscriptions.sql
V7__create_portal_schema.sql
V8__extend_portal_read_model.sql
```
**Highest global**: V8

### Tenant Migrations (`db/migration/tenant/`)
```
V1__create_projects.sql
V2__create_documents.sql
V3__create_members.sql
V4__migrate_ownership_to_members.sql
V5__create_project_members.sql
V6__add_missing_fk_indexes.sql
V7__create_customers.sql
V8__create_customer_projects.sql
V9__create_tasks.sql
V10__extend_documents_scope.sql
V11__create_time_entries.sql
V12__create_audit_events.sql
V13__create_comments.sql
V14__create_notifications.sql
V15__create_notification_preferences.sql
V16__create_portal_contacts_and_magic_link_tokens.sql
V17__create_rate_budget_tables.sql
V18__add_time_entry_rate_snapshots.sql
V19__add_project_budget_version.sql
V20__add_dashboard_indexes.sql
V21__create_invoices.sql
V22__add_field_definitions_groups.sql
V23__add_tags.sql
V24__add_field_pack_status.sql
V25__add_custom_field_columns.sql
V26__add_saved_views.sql
V27__create_document_templates.sql
V28__add_branding_and_template_pack_status.sql
V29__customer_compliance_lifecycle.sql
V30__project_templates_recurring_schedules.sql
V31__create_retainer_tables.sql
V32__rename_external_to_shared_visibility.sql
V33__create_task_items.sql
V34__create_template_task_items.sql
V35__create_report_definitions.sql
V36__create_integration_tables.sql
V37__portal_comments_support.sql
V38__custom_field_maturity.sql
V39__generated_document_warnings.sql
V40__comment_source_column.sql
```
**Highest tenant**: V40
**Next available tenant migration**: V41

---

## 4. Entity Inventory (49 @Entity classes)

| Entity | File |
|--------|------|
| AuditEvent | `audit/AuditEvent.java` |
| BillingRate | `billingrate/BillingRate.java` |
| Subscription | `billing/Subscription.java` |
| ProjectBudget | `budget/ProjectBudget.java` |
| ChecklistInstance | `checklist/ChecklistInstance.java` |
| ChecklistInstanceItem | `checklist/ChecklistInstanceItem.java` |
| ChecklistTemplate | `checklist/ChecklistTemplate.java` |
| ChecklistTemplateItem | `checklist/ChecklistTemplateItem.java` |
| Comment | `comment/Comment.java` |
| CostRate | `costrate/CostRate.java` |
| Customer | `customer/Customer.java` |
| CustomerProject | `customer/CustomerProject.java` |
| DataSubjectRequest | `datarequest/DataSubjectRequest.java` |
| Document | `document/Document.java` |
| FieldDefinition | `fielddefinition/FieldDefinition.java` |
| FieldGroup | `fielddefinition/FieldGroup.java` |
| FieldGroupMember | `fielddefinition/FieldGroupMember.java` |
| OrgIntegration | `integration/OrgIntegration.java` |
| OrgSecret | `integration/secret/OrgSecret.java` |
| Invoice | `invoice/Invoice.java` |
| InvoiceCounter | `invoice/InvoiceCounter.java` |
| InvoiceLine | `invoice/InvoiceLine.java` |
| Member | `member/Member.java` |
| ProjectMember | `member/ProjectMember.java` |
| OrgSchemaMapping | `multitenancy/OrgSchemaMapping.java` |
| Notification | `notification/Notification.java` |
| NotificationPreference | `notification/NotificationPreference.java` |
| PortalContact | `portal/PortalContact.java` |
| MagicLinkToken | `portal/MagicLinkToken.java` |
| Project | `project/Project.java` |
| ProjectTemplate | `projecttemplate/ProjectTemplate.java` |
| TemplateTask | `projecttemplate/TemplateTask.java` |
| TemplateTaskItem | `projecttemplate/TemplateTaskItem.java` |
| Organization | `provisioning/Organization.java` |
| ReportDefinition | `reporting/ReportDefinition.java` |
| RetainerAgreement | `retainer/RetainerAgreement.java` |
| RetainerPeriod | `retainer/RetainerPeriod.java` |
| RetentionPolicy | `retention/RetentionPolicy.java` |
| RecurringSchedule | `schedule/RecurringSchedule.java` |
| ScheduleExecution | `schedule/ScheduleExecution.java` |
| OrgSettings | `settings/OrgSettings.java` |
| Tag | `tag/Tag.java` |
| EntityTag | `tag/EntityTag.java` |
| Task | `task/Task.java` |
| TaskItem | `task/TaskItem.java` |
| DocumentTemplate | `template/DocumentTemplate.java` |
| GeneratedDocument | `template/GeneratedDocument.java` |
| TimeEntry | `timeentry/TimeEntry.java` |
| SavedView | `view/SavedView.java` |

All paths relative to `backend/src/main/java/io/b2mash/b2b/b2bstrawman/`.

---

## 5. Backend Package Structure

```
io.b2mash.b2b.b2bstrawman/
├── activity/
├── audit/
├── billing/
├── billingrate/
├── budget/
├── checklist/
├── comment/
├── compliance/
├── config/
├── costrate/
├── customer/
├── customerbackend/
├── dashboard/
├── datarequest/
├── dev/
├── document/
├── event/
├── exception/
├── fielddefinition/
├── integration/
│   ├── accounting/
│   ├── ai/
│   ├── secret/
│   └── signing/
├── invoice/
├── member/
├── multitenancy/
├── mywork/
├── notification/
│   ├── channel/
│   └── template/
├── portal/
├── project/
├── projecttemplate/
├── provisioning/
├── report/
├── reporting/
├── retainer/
├── retention/
├── s3/
├── schedule/
├── security/
├── settings/
├── setupstatus/
├── tag/
├── task/
├── template/
├── timeentry/
└── view/
```

---

## 6. Frontend Route Structure

All under `frontend/app/(app)/org/[slug]/`:

```
├── layout.tsx
├── compliance/
│   ├── page.tsx
│   └── requests/
│       ├── page.tsx
│       └── [id]/page.tsx
├── customers/
│   ├── page.tsx
│   └── [id]/page.tsx
├── dashboard/page.tsx
├── documents/page.tsx
├── invoices/
│   ├── page.tsx
│   └── [id]/page.tsx
├── my-work/page.tsx
├── notifications/page.tsx
├── profitability/page.tsx
├── projects/
│   ├── page.tsx
│   └── [id]/page.tsx
├── reports/
│   ├── page.tsx
│   └── [reportSlug]/page.tsx
├── retainers/
│   ├── page.tsx
│   └── [id]/page.tsx
├── schedules/
│   ├── page.tsx
│   └── [id]/page.tsx
├── settings/
│   ├── page.tsx
│   ├── billing/page.tsx
│   ├── checklists/
│   │   ├── page.tsx
│   │   ├── new/page.tsx
│   │   └── [id]/
│   │       ├── page.tsx
│   │       └── edit/page.tsx
│   ├── compliance/page.tsx
│   ├── custom-fields/page.tsx
│   ├── integrations/page.tsx
│   ├── notifications/page.tsx
│   ├── project-templates/
│   │   ├── page.tsx
│   │   └── [id]/page.tsx
│   ├── rates/page.tsx
│   ├── tags/page.tsx
│   └── templates/
│       ├── page.tsx
│       ├── new/page.tsx
│       └── [id]/edit/page.tsx
└── team/page.tsx
```

---

## 7. Existing Patterns (Full Source)

### 7.1 NotificationChannel Interface

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/channel/NotificationChannel.java`

```java
package io.b2mash.b2b.b2bstrawman.notification.channel;

import io.b2mash.b2b.b2bstrawman.notification.Notification;

/**
 * Abstraction for notification delivery channels. Each channel handles one delivery mechanism
 * (in-app, email, push, etc.).
 */
public interface NotificationChannel {

  /** Unique identifier for this channel (e.g., "in-app", "email"). */
  String channelId();

  /**
   * Delivers a notification via this channel.
   *
   * @param notification the notification to deliver
   * @param recipientEmail the recipient's email address (for email channels)
   */
  void deliver(Notification notification, String recipientEmail);

  /** Whether this channel is currently enabled/available. */
  boolean isEnabled();
}
```

### 7.2 EmailNotificationChannel Stub

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/channel/EmailNotificationChannel.java`

```java
package io.b2mash.b2b.b2bstrawman.notification.channel;

import io.b2mash.b2b.b2bstrawman.notification.Notification;
import io.b2mash.b2b.b2bstrawman.notification.template.EmailTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

/**
 * Email notification channel -- stub implementation for local/dev profiles. Logs the rendered email
 * content instead of sending it.
 *
 * <p>In production, this bean is NOT registered (no prod profile). When SES integration is added
 * (future phase), a production EmailNotificationChannel will inject SesClient and actually send
 * emails.
 */
@Component
@Profile({"local", "dev"})
public class EmailNotificationChannel implements NotificationChannel {

  private static final Logger log = LoggerFactory.getLogger(EmailNotificationChannel.class);

  @Override
  public String channelId() {
    return "email";
  }

  @Override
  public void deliver(Notification notification, String recipientEmail) {
    if (recipientEmail == null || recipientEmail.isBlank()) {
      log.debug("Skipping email for notification {} — no recipient email", notification.getId());
      return;
    }

    EmailTemplate template = EmailTemplate.fromNotificationType(notification.getType());
    String subject = template.renderSubject(notification);
    String body = template.renderBody(notification);

    log.info("[EMAIL STUB] To: {}, Subject: {}, Body: {}", recipientEmail, subject, body);
  }

  @Override
  public boolean isEnabled() {
    return true;
  }
}
```

### 7.3 EmailTemplate Enum

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/template/EmailTemplate.java`

```java
package io.b2mash.b2b.b2bstrawman.notification.template;

import io.b2mash.b2b.b2bstrawman.notification.Notification;

/**
 * Email template definitions for notification types. Templates use simple string formatting with
 * notification fields. When rich HTML emails are needed (future phase), these can be replaced with
 * Thymeleaf templates or a dedicated template engine.
 */
public enum EmailTemplate {
  TASK_ASSIGNED(
      "You've been assigned to a task",
      "Hi,\n\n%s\n\nView the task in DocTeams.\n\nBest,\nDocTeams"),
  TASK_CLAIMED(
      "A task you were working on was claimed",
      "Hi,\n\n%s\n\nView the task in DocTeams.\n\nBest,\nDocTeams"),
  TASK_UPDATED(
      "A task you're assigned to was updated",
      "Hi,\n\n%s\n\nView the task in DocTeams.\n\nBest,\nDocTeams"),
  COMMENT_ADDED(
      "New comment on your task", "Hi,\n\n%s\n\nView the comment in DocTeams.\n\nBest,\nDocTeams"),
  DOCUMENT_SHARED(
      "New document in your project",
      "Hi,\n\n%s\n\nView the document in DocTeams.\n\nBest,\nDocTeams"),
  MEMBER_INVITED(
      "You've been added to a project",
      "Hi,\n\n%s\n\nView the project in DocTeams.\n\nBest,\nDocTeams"),
  DEFAULT("DocTeams notification", "Hi,\n\n%s\n\nBest,\nDocTeams");

  private final String subjectTemplate;
  private final String bodyTemplate;

  EmailTemplate(String subjectTemplate, String bodyTemplate) {
    this.subjectTemplate = subjectTemplate;
    this.bodyTemplate = bodyTemplate;
  }

  public static EmailTemplate fromNotificationType(String type) {
    try {
      return valueOf(type);
    } catch (IllegalArgumentException e) {
      return DEFAULT;
    }
  }

  public String renderSubject(Notification notification) {
    return subjectTemplate;
  }

  public String renderBody(Notification notification) {
    return String.format(bodyTemplate, notification.getTitle());
  }
}
```

### 7.4 TemplateRenderer Component

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/template/TemplateRenderer.java`

```java
package io.b2mash.b2b.b2bstrawman.notification.template;

import org.springframework.stereotype.Component;

/**
 * Renders email content from templates and notification data. In Phase 6.5, this is a thin wrapper
 * around EmailTemplate. Future phases can inject Thymeleaf TemplateEngine for HTML rendering.
 */
@Component
public class TemplateRenderer {

  // Placeholder for future Thymeleaf integration.
  // Phase 6.5 uses EmailTemplate enum directly.
}
```

### 7.5 NotificationDispatcher Class

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/channel/NotificationDispatcher.java`

```java
package io.b2mash.b2b.b2bstrawman.notification.channel;

import io.b2mash.b2b.b2bstrawman.notification.Notification;
import io.b2mash.b2b.b2bstrawman.notification.NotificationPreferenceRepository;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Routes notifications to appropriate channels based on user preferences. Channels self-register
 * via constructor injection (Spring collects all NotificationChannel beans).
 */
@Component
public class NotificationDispatcher {

  private static final Logger log = LoggerFactory.getLogger(NotificationDispatcher.class);

  private final Map<String, NotificationChannel> channels;
  private final NotificationPreferenceRepository preferenceRepository;

  public NotificationDispatcher(
      List<NotificationChannel> channelBeans,
      NotificationPreferenceRepository preferenceRepository) {
    this.channels =
        channelBeans.stream()
            .filter(NotificationChannel::isEnabled)
            .collect(Collectors.toMap(NotificationChannel::channelId, Function.identity()));
    this.preferenceRepository = preferenceRepository;
  }

  /**
   * Dispatches a notification to all enabled channels based on user preferences.
   *
   * @param notification the persisted notification
   * @param recipientEmail the recipient's email (for email channel)
   */
  public void dispatch(Notification notification, String recipientEmail) {
    var preference =
        preferenceRepository
            .findByMemberIdAndNotificationType(
                notification.getRecipientMemberId(), notification.getType())
            .orElse(null);

    // In-app channel: always dispatch unless explicitly disabled
    boolean inAppEnabled = preference == null || preference.isInAppEnabled();
    if (inAppEnabled) {
      dispatchToChannel("in-app", notification, recipientEmail);
    }

    // Email channel: only dispatch if explicitly enabled (default is false)
    boolean emailEnabled = preference != null && preference.isEmailEnabled();
    if (emailEnabled) {
      dispatchToChannel("email", notification, recipientEmail);
    }
  }

  private void dispatchToChannel(String channelId, Notification notification, String email) {
    var channel = channels.get(channelId);
    if (channel != null) {
      try {
        channel.deliver(notification, email);
      } catch (Exception e) {
        log.warn(
            "Failed to deliver notification via channel={} notificationId={}",
            channelId,
            notification.getId(),
            e);
      }
    }
  }
}
```

### 7.6 IntegrationDomain Enum

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/IntegrationDomain.java`

```java
package io.b2mash.b2b.b2bstrawman.integration;

/** Categorizes the external integration domains available to tenants. */
public enum IntegrationDomain {
  ACCOUNTING,
  AI,
  DOCUMENT_SIGNING,
  PAYMENT
}
```

### 7.7 IntegrationRegistry Class

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/IntegrationRegistry.java`

```java
package io.b2mash.b2b.b2bstrawman.integration;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.context.ApplicationContext;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;

@Component
public class IntegrationRegistry {

  // Built at startup: domain -> slug -> adapter bean
  private final Map<IntegrationDomain, Map<String, Object>> adapterMap = new ConcurrentHashMap<>();

  // Caffeine cache: "tenantSchema:DOMAIN" -> OrgIntegrationCacheEntry (never null)
  private final Cache<String, OrgIntegrationCacheEntry> configCache;

  private final OrgIntegrationRepository orgIntegrationRepository;

  public IntegrationRegistry(
      ApplicationContext applicationContext, OrgIntegrationRepository orgIntegrationRepository) {
    this.orgIntegrationRepository = orgIntegrationRepository;
    this.configCache =
        Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(60)).maximumSize(1000).build();

    // Scan for all beans with @IntegrationAdapter.
    applicationContext
        .getBeansWithAnnotation(IntegrationAdapter.class)
        .forEach(
            (name, bean) -> {
              var annotation =
                  AnnotationUtils.findAnnotation(bean.getClass(), IntegrationAdapter.class);
              var slugMap =
                  adapterMap.computeIfAbsent(annotation.domain(), k -> new ConcurrentHashMap<>());
              var existing = slugMap.putIfAbsent(annotation.slug(), bean);
              if (existing != null) {
                throw new IllegalStateException(
                    "Duplicate @IntegrationAdapter: domain="
                        + annotation.domain()
                        + ", slug="
                        + annotation.slug()
                        + " registered by both "
                        + existing.getClass().getName()
                        + " and "
                        + bean.getClass().getName());
              }
            });
  }

  /**
   * Resolve the active adapter for the current tenant and domain. Returns the NoOp adapter if no
   * integration is configured or enabled.
   */
  @SuppressWarnings("unchecked")
  public <T> T resolve(IntegrationDomain domain, Class<T> portInterface) {
    if (!RequestScopes.TENANT_ID.isBound()) {
      throw new IllegalStateException("resolve() must be called within a tenant-scoped context");
    }
    var tenantSchema = RequestScopes.TENANT_ID.get();
    var cacheKey = tenantSchema + ":" + domain.name();

    var entry =
        configCache.get(
            cacheKey,
            k ->
                orgIntegrationRepository
                    .findByDomain(domain)
                    .map(OrgIntegrationCacheEntry::of)
                    .orElse(OrgIntegrationCacheEntry.EMPTY));

    var slugMap = adapterMap.getOrDefault(domain, Map.of());

    if (entry == OrgIntegrationCacheEntry.EMPTY || !entry.enabled()) {
      var noop = slugMap.get("noop");
      if (noop == null) {
        throw new IllegalStateException("No noop adapter registered for domain " + domain);
      }
      return (T) noop;
    }

    var adapter = slugMap.get(entry.providerSlug());
    if (adapter == null) {
      var noop = slugMap.get("noop");
      if (noop == null) {
        throw new IllegalStateException("No noop adapter registered for domain " + domain);
      }
      return (T) noop;
    }

    if (!portInterface.isInstance(adapter)) {
      throw new IllegalStateException(
          "Adapter "
              + adapter.getClass().getName()
              + " does not implement "
              + portInterface.getName()
              + " for domain "
              + domain);
    }

    return (T) adapter;
  }

  /** Lists available provider slugs for a given domain. */
  public List<String> availableProviders(IntegrationDomain domain) {
    return List.copyOf(adapterMap.getOrDefault(domain, Map.of()).keySet());
  }

  /** Evict cached config for a tenant + domain (called on config change). */
  public void evict(String tenantSchema, IntegrationDomain domain) {
    configCache.invalidate(tenantSchema + ":" + domain.name());
  }

  private record OrgIntegrationCacheEntry(String providerSlug, boolean enabled, String configJson) {
    static final OrgIntegrationCacheEntry EMPTY = new OrgIntegrationCacheEntry(null, false, null);

    static OrgIntegrationCacheEntry of(OrgIntegration integration) {
      return new OrgIntegrationCacheEntry(
          integration.getProviderSlug(), integration.isEnabled(), integration.getConfigJson());
    }
  }
}
```

### 7.8 IntegrationAdapter Annotation

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/IntegrationAdapter.java`

```java
package io.b2mash.b2b.b2bstrawman.integration;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks a Spring bean as an integration adapter. The IntegrationRegistry discovers beans annotated
 * with this at startup and builds the domain -> slug -> adapter mapping.
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface IntegrationAdapter {
  /** The integration domain this adapter serves. */
  IntegrationDomain domain();

  /** Unique slug for this adapter within its domain (e.g., "xero", "noop"). */
  String slug();
}
```

### 7.9 IntegrationPort Interface

**Does not exist.** No `IntegrationPort` interface was found in the codebase. Each domain defines its own port interface (e.g., `AccountingProvider`, `AiProvider`, `SigningProvider`).

### 7.10 OrgIntegration Entity

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/OrgIntegration.java`

```java
package io.b2mash.b2b.b2bstrawman.integration;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

@Entity
@Table(name = "org_integrations")
public class OrgIntegration {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Enumerated(EnumType.STRING)
  @Column(name = "domain", nullable = false, length = 30)
  private IntegrationDomain domain;

  @Column(name = "provider_slug", nullable = false, length = 50)
  private String providerSlug;

  @Column(name = "enabled", nullable = false)
  private boolean enabled;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "config_json", columnDefinition = "jsonb")
  private String configJson;

  @Column(name = "key_suffix", length = 6)
  private String keySuffix;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected OrgIntegration() {}

  public OrgIntegration(IntegrationDomain domain, String providerSlug) {
    this.domain = domain;
    this.providerSlug = providerSlug;
    this.enabled = false;
  }

  @PrePersist
  void onPrePersist() {
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  @PreUpdate
  void onPreUpdate() {
    this.updatedAt = Instant.now();
  }

  public void updateProvider(String providerSlug, String configJson) {
    this.providerSlug = providerSlug;
    this.configJson = configJson;
  }

  public void setKeySuffix(String keySuffix) {
    this.keySuffix = keySuffix;
  }

  public void clearKeySuffix() {
    this.keySuffix = null;
  }

  public void enable() {
    this.enabled = true;
  }

  public void disable() {
    this.enabled = false;
  }

  // ... getters for id, domain, providerSlug, enabled, configJson, keySuffix, createdAt, updatedAt
}
```

### 7.11 SecretStore Interface + EncryptedDatabaseSecretStore

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/secret/SecretStore.java`

```java
package io.b2mash.b2b.b2bstrawman.integration.secret;

/**
 * Abstraction for storing and retrieving sensitive credentials. Queries execute within the current
 * tenant's schema.
 */
public interface SecretStore {

  /** Store a secret (encrypts before persistence). Overwrites if key exists. */
  void store(String secretKey, String plaintext);

  /** Retrieve a secret (decrypts after read). Throws if not found. */
  String retrieve(String secretKey);

  /** Delete a secret. No-op if not found. */
  void delete(String secretKey);

  /** Check whether a secret exists for the given key. */
  boolean exists(String secretKey);
}
```

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/secret/EncryptedDatabaseSecretStore.java`

```java
package io.b2mash.b2b.b2bstrawman.integration.secret;

import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import jakarta.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
public class EncryptedDatabaseSecretStore implements SecretStore {

  private static final Logger log = LoggerFactory.getLogger(EncryptedDatabaseSecretStore.class);

  private static final String ALGORITHM = "AES/GCM/NoPadding";
  private static final int GCM_TAG_LENGTH = 128; // bits
  private static final int IV_LENGTH = 12; // bytes (96 bits)

  private final OrgSecretRepository repository;
  private final SecretKeySpec encryptionKey;
  private final SecureRandom secureRandom = new SecureRandom();

  public EncryptedDatabaseSecretStore(
      OrgSecretRepository repository, @Value("${integration.encryption-key:}") String encodedKey) {
    this.repository = repository;
    if (encodedKey == null || encodedKey.isBlank()) {
      this.encryptionKey = null;
    } else {
      byte[] keyBytes = Base64.getDecoder().decode(encodedKey);
      this.encryptionKey = new SecretKeySpec(keyBytes, "AES");
    }
  }

  @PostConstruct
  void validateKey() {
    if (encryptionKey == null) {
      throw new IllegalStateException(
          "INTEGRATION_ENCRYPTION_KEY environment variable is not set.");
    }
    if (encryptionKey.getEncoded().length != 32) {
      throw new IllegalStateException(
          "INTEGRATION_ENCRYPTION_KEY must be a Base64-encoded 256-bit (32-byte) key.");
    }
  }

  @Override
  @Transactional
  public void store(String key, String plaintext) {
    byte[] iv = generateIv();
    byte[] ciphertext = encrypt(plaintext.getBytes(StandardCharsets.UTF_8), iv);

    String encodedCiphertext = Base64.getEncoder().encodeToString(ciphertext);
    String encodedIv = Base64.getEncoder().encodeToString(iv);

    var existing = repository.findBySecretKey(key);
    if (existing.isPresent()) {
      existing.get().updateEncryptedValue(encodedCiphertext, encodedIv, 1);
      repository.save(existing.get());
    } else {
      var secret = new OrgSecret(key, encodedCiphertext, encodedIv, 1);
      repository.save(secret);
    }
  }

  @Override
  @Transactional(readOnly = true)
  public String retrieve(String key) {
    var secret =
        repository
            .findBySecretKey(key)
            .orElseThrow(() -> new ResourceNotFoundException("Secret", key));

    byte[] ciphertext = Base64.getDecoder().decode(secret.getEncryptedValue());
    byte[] iv = Base64.getDecoder().decode(secret.getIv());

    byte[] plaintext = decrypt(ciphertext, iv);
    return new String(plaintext, StandardCharsets.UTF_8);
  }

  @Override
  @Transactional
  public void delete(String key) {
    repository.deleteBySecretKey(key);
  }

  @Override
  @Transactional(readOnly = true)
  public boolean exists(String key) {
    return repository.existsBySecretKey(key);
  }

  // ... encrypt/decrypt with AES-GCM
}
```

### 7.12 OrgSecret Entity

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/secret/OrgSecret.java`

```java
package io.b2mash.b2b.b2bstrawman.integration.secret;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "org_secrets")
public class OrgSecret {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "secret_key", nullable = false, length = 200)
  private String secretKey;

  @Column(name = "encrypted_value", nullable = false, columnDefinition = "TEXT")
  private String encryptedValue;

  @Column(name = "iv", nullable = false, length = 24)
  private String iv;

  @Column(name = "key_version", nullable = false)
  private int keyVersion;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  // constructor, @PrePersist, @PreUpdate, updateEncryptedValue(), getters
}
```

### 7.13 NoOpAccountingProvider (Example NoOp Adapter)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/accounting/NoOpAccountingProvider.java`

```java
package io.b2mash.b2b.b2bstrawman.integration.accounting;

import io.b2mash.b2b.b2bstrawman.integration.ConnectionTestResult;
import io.b2mash.b2b.b2bstrawman.integration.IntegrationAdapter;
import io.b2mash.b2b.b2bstrawman.integration.IntegrationDomain;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
@IntegrationAdapter(domain = IntegrationDomain.ACCOUNTING, slug = "noop")
public class NoOpAccountingProvider implements AccountingProvider {

  private static final Logger log = LoggerFactory.getLogger(NoOpAccountingProvider.class);

  @Override
  public String providerId() {
    return "noop";
  }

  @Override
  public AccountingSyncResult syncInvoice(InvoiceSyncRequest request) {
    log.info(
        "NoOp accounting: would sync invoice {} for customer {}",
        request.invoiceNumber(),
        request.customerName());
    return new AccountingSyncResult(
        true, "NOOP-" + UUID.randomUUID().toString().substring(0, 8), null);
  }

  @Override
  public AccountingSyncResult syncCustomer(CustomerSyncRequest request) {
    log.info("NoOp accounting: would sync customer {}", request.customerName());
    return new AccountingSyncResult(
        true, "NOOP-" + UUID.randomUUID().toString().substring(0, 8), null);
  }

  @Override
  public ConnectionTestResult testConnection() {
    return new ConnectionTestResult(true, "noop", null);
  }
}
```

### 7.14 AccountingProvider Port Interface

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/accounting/AccountingProvider.java`

```java
package io.b2mash.b2b.b2bstrawman.integration.accounting;

import io.b2mash.b2b.b2bstrawman.integration.ConnectionTestResult;

/**
 * Port for syncing financial data to external accounting software. Tenant-scoped: each org can
 * configure their own provider (Xero, QuickBooks, etc.).
 */
public interface AccountingProvider {

  /** Provider identifier (e.g., "xero", "quickbooks", "noop"). */
  String providerId();

  /** Sync an invoice to the external accounting system. */
  AccountingSyncResult syncInvoice(InvoiceSyncRequest request);

  /** Sync a customer record to the external accounting system. */
  AccountingSyncResult syncCustomer(CustomerSyncRequest request);

  /** Test connectivity with the configured credentials. */
  ConnectionTestResult testConnection();
}
```

### 7.15 ConnectionTestResult

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/integration/ConnectionTestResult.java`

```java
package io.b2mash.b2b.b2bstrawman.integration;

/** Shared result record for testing connectivity to an external provider. */
public record ConnectionTestResult(boolean success, String providerName, String errorMessage) {}
```

### 7.16 PdfRenderingService (Thymeleaf Setup)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/template/PdfRenderingService.java`

```java
package io.b2mash.b2b.b2bstrawman.template;

import com.openhtmltopdf.pdfboxout.PdfRendererBuilder;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.StringTemplateResolver;

/**
 * Orchestrates template rendering: loads template, builds context, merges CSS, renders HTML via
 * Thymeleaf, and converts to PDF via OpenHTMLToPDF.
 *
 * Uses a dedicated Thymeleaf TemplateEngine with a StringTemplateResolver (separate from
 * Spring's autoconfigured engine) so that document template content stored in the database
 * can be rendered directly as Thymeleaf markup.
 */
@Service
public class PdfRenderingService {

  private final DocumentTemplateRepository documentTemplateRepository;
  private final List<TemplateContextBuilder> contextBuilders;
  private final TemplateValidationService templateValidationService;
  private final TemplateEngine stringTemplateEngine;
  private final String defaultCss;

  public PdfRenderingService(
      DocumentTemplateRepository documentTemplateRepository,
      List<TemplateContextBuilder> contextBuilders,
      TemplateValidationService templateValidationService) {
    this.documentTemplateRepository = documentTemplateRepository;
    this.contextBuilders = contextBuilders;
    this.templateValidationService = templateValidationService;
    this.stringTemplateEngine = createStringTemplateEngine();
    this.defaultCss = loadDefaultCss();
  }

  @Transactional(readOnly = true)
  public PdfResult generatePdf(UUID templateId, UUID entityId, UUID memberId) {
    var template = documentTemplateRepository.findById(templateId).orElseThrow(...);
    var builder = findBuilder(template.getPrimaryEntityType());
    var contextMap = builder.buildContext(entityId, memberId);
    String customCss = template.getCss() != null ? template.getCss() : "";
    String mergedCss = defaultCss + "\n" + customCss;
    String renderedBody = renderThymeleaf(template.getContent(), contextMap);
    String fullHtml = wrapHtml(renderedBody, mergedCss);
    byte[] pdfBytes = htmlToPdf(fullHtml);
    String fileName = generateFilename(template.getSlug(), template.getPrimaryEntityType(), contextMap);
    return new PdfResult(pdfBytes, fileName, fullHtml);
  }

  // Key method: Thymeleaf engine creation
  private static TemplateEngine createStringTemplateEngine() {
    var engine = new TemplateEngine();
    engine.setDialect(new LenientStandardDialect());
    var resolver = new StringTemplateResolver();
    resolver.setTemplateMode(TemplateMode.HTML);
    engine.setTemplateResolver(resolver);
    return engine;
  }

  public String renderThymeleaf(String templateContent, Map<String, Object> contextMap) {
    TemplateSecurityValidator.validate(templateContent);
    var ctx = new Context();
    contextMap.forEach(ctx::setVariable);
    return stringTemplateEngine.process(templateContent, ctx);
  }

  public byte[] htmlToPdf(String html) {
    try (var outputStream = new ByteArrayOutputStream()) {
      var builder = new PdfRendererBuilder();
      builder.withHtmlContent(html, null);
      builder.toStream(outputStream);
      builder.run();
      return outputStream.toByteArray();
    } catch (IOException e) {
      throw new PdfGenerationException("Failed to generate PDF from rendered HTML", e);
    }
  }
}
```

### 7.17 TemplateSecurityValidator

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/template/TemplateSecurityValidator.java`

```java
package io.b2mash.b2b.b2bstrawman.template;

import java.util.List;
import java.util.regex.Pattern;

/**
 * Validates Thymeleaf template content for dangerous patterns that could lead to SSTI.
 */
public final class TemplateSecurityValidator {

  private TemplateSecurityValidator() {}

  private static final List<DangerousPattern> DANGEROUS_PATTERNS =
      List.of(
          new DangerousPattern(Pattern.compile("T\\s*\\(", Pattern.CASE_INSENSITIVE),
              "Type expressions (T()) are not allowed in templates"),
          new DangerousPattern(Pattern.compile("\\bnew\\s+[A-Z]"),
              "Object instantiation (new) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("__\\$\\{"),
              "Preprocessing expressions (__${) are not allowed in templates"),
          new DangerousPattern(Pattern.compile("\\$\\{\\s*#"),
              "Utility object access (${#) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("#ctx\\b"),
              "Context object access (#ctx) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("#root\\b"),
              "Root object access (#root) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("#execInfo\\b"),
              "ExecInfo access (#execInfo) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("#vars\\b"),
              "Vars access (#vars) is not allowed in templates"),
          new DangerousPattern(Pattern.compile("getClass\\s*\\("),
              "Reflective access (getClass()) is not allowed in templates"),
          new DangerousPattern(
              Pattern.compile("Runtime|ProcessBuilder|ClassLoader", Pattern.CASE_INSENSITIVE),
              "Access to dangerous Java classes is not allowed in templates"));

  public static void validate(String content) {
    if (content == null || content.isBlank()) {
      return;
    }
    for (var pattern : DANGEROUS_PATTERNS) {
      if (pattern.pattern().matcher(content).find()) {
        throw new TemplateSecurityException(pattern.message());
      }
    }
  }

  private record DangerousPattern(Pattern pattern, String message) {}
}
```

### 7.18 MagicLinkService

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/MagicLinkService.java`

```java
package io.b2mash.b2b.b2bstrawman.portal;

import java.nio.charset.StandardCharsets;
import java.security.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Generates and verifies time-limited magic link tokens for customer portal access. Tokens are
 * cryptographically random, stored as SHA-256 hashes in the database. Single-use enforcement via
 * database state (used_at column). Rate limited to 3 tokens per contact per 5 minutes.
 */
@Service
public class MagicLinkService {

  private static final int TOKEN_BYTES = 32;
  private static final long TOKEN_TTL_MINUTES = 15;
  private static final int MAX_TOKENS_PER_5_MINUTES = 3;

  private final MagicLinkTokenRepository tokenRepository;
  private final SecureRandom secureRandom;

  @Transactional
  public String generateToken(UUID portalContactId, String createdIp) {
    // Rate-limit check: max 3 tokens per contact per 5 minutes
    long recentCount = tokenRepository.countByPortalContactIdAndCreatedAtAfter(
        portalContactId, Instant.now().minus(5, ChronoUnit.MINUTES));
    if (recentCount >= MAX_TOKENS_PER_5_MINUTES) {
      throw new PortalAuthException("Too many login attempts");
    }

    byte[] tokenBytes = new byte[TOKEN_BYTES];
    secureRandom.nextBytes(tokenBytes);
    String rawToken = Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
    String tokenHash = hashToken(rawToken);

    Instant expiresAt = Instant.now().plus(TOKEN_TTL_MINUTES, ChronoUnit.MINUTES);
    var magicLinkToken = new MagicLinkToken(portalContactId, tokenHash, expiresAt, createdIp);
    tokenRepository.save(magicLinkToken);
    return rawToken;
  }

  @Transactional
  public UUID verifyAndConsumeToken(String rawToken) {
    String tokenHash = hashToken(rawToken);
    MagicLinkToken token = tokenRepository.findByTokenHashForUpdate(tokenHash)
        .orElseThrow(() -> new PortalAuthException("Invalid magic link token"));

    if (token.isExpired()) throw new PortalAuthException("Magic link has expired");
    if (token.isUsed()) throw new PortalAuthException("Magic link has already been used");

    token.markUsed();
    tokenRepository.save(token);
    return token.getPortalContactId();
  }

  // SHA-256 hash
  private String hashToken(String rawToken) { ... }
}
```

### 7.19 InvoiceService (Send/Transition Method)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/invoice/InvoiceService.java`

The `send` method (lines 807-878):

```java
@Transactional
public InvoiceResponse send(UUID invoiceId, SendInvoiceRequest request) {
  boolean overrideWarnings = request != null && request.overrideWarnings();
  var invoice = invoiceRepository.findById(invoiceId)
      .orElseThrow(() -> new ResourceNotFoundException("Invoice", invoiceId));

  // Validate before sending
  var validationChecks = invoiceValidationService.validateInvoiceSend(invoice);
  if (invoiceValidationService.hasCriticalFailures(validationChecks) && !overrideWarnings) {
    throw new InvoiceValidationFailedException(validationChecks);
  }

  try {
    invoice.markSent();
  } catch (IllegalStateException e) {
    throw new ResourceConflictException("Invalid status transition", e.getMessage());
  }

  invoice = invoiceRepository.save(invoice);

  // Audit event
  auditService.log(AuditEventBuilder.builder()
      .eventType("invoice.sent")
      .entityType("invoice")
      .entityId(invoice.getId())
      .details(Map.of("invoice_number", invoice.getInvoiceNumber()))
      .build());

  // Domain events: InvoiceSentEvent + InvoiceSyncEvent
  eventPublisher.publishEvent(new InvoiceSentEvent(...));
  eventPublisher.publishEvent(new InvoiceSyncEvent(...));

  return buildResponse(invoice);
}
```

### 7.20 OrgSettings Entity

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/settings/OrgSettings.java`

```java
package io.b2mash.b2b.b2bstrawman.settings;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

@Entity
@Table(name = "org_settings")
public class OrgSettings {

  @Id @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "default_currency", nullable = false, length = 3)
  private String defaultCurrency;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "field_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> fieldPackStatus;

  @Column(name = "logo_s3_key", length = 500)
  private String logoS3Key;

  @Column(name = "brand_color", length = 7)
  private String brandColor;

  @Column(name = "document_footer_text", columnDefinition = "TEXT")
  private String documentFooterText;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "template_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> templatePackStatus;

  @Column(name = "dormancy_threshold_days")
  private Integer dormancyThresholdDays;

  @Column(name = "data_request_deadline_days")
  private Integer dataRequestDeadlineDays;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "compliance_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> compliancePackStatus;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "report_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> reportPackStatus;

  @Column(name = "accounting_enabled", nullable = false)
  private boolean accountingEnabled;

  @Column(name = "ai_enabled", nullable = false)
  private boolean aiEnabled;

  @Column(name = "document_signing_enabled", nullable = false)
  private boolean documentSigningEnabled;

  // constructor, pack recording methods, integration flag update, getters/setters
}
```

### 7.21 NotificationPreference Entity

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/notification/NotificationPreference.java`

```java
package io.b2mash.b2b.b2bstrawman.notification;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "notification_preferences")
public class NotificationPreference {

  @Id @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "member_id", nullable = false)
  private UUID memberId;

  @Column(name = "notification_type", nullable = false, length = 50)
  private String notificationType;

  @Column(name = "in_app_enabled", nullable = false)
  private boolean inAppEnabled;

  @Column(name = "email_enabled", nullable = false)
  private boolean emailEnabled;

  // constructors, getters, setters
}
```

### 7.22 AuditService Interface

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/audit/AuditService.java`

```java
package io.b2mash.b2b.b2bstrawman.audit;

import java.util.List;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

/**
 * Service interface for recording and querying audit events. Implementations are tenant-scoped --
 * queries return only events in the current tenant's dedicated schema.
 */
public interface AuditService {

  /**
   * Records a single audit event within the current transaction. If the enclosing transaction rolls
   * back, the audit event is also rolled back (no REQUIRES_NEW).
   */
  void log(AuditEventRecord record);

  /**
   * Queries audit events matching the given filter, scoped to the current tenant schema.
   */
  Page<AuditEvent> findEvents(AuditEventFilter filter, Pageable pageable);

  /**
   * Counts audit events grouped by event type for the current tenant schema.
   */
  List<AuditEventRepository.EventTypeCount> countEventsByType();
}
```

### 7.23 EmailDeliveryStatus Enum

**Does not exist.** No `EmailDeliveryStatus` enum was found in the codebase.

### 7.24 Rate Limiting Pattern

**No general rate-limiting pattern exists** in the codebase. The only rate limiting found is in `MagicLinkService` (see 7.18): a simple database-count-based approach that checks token creation count within a time window. No middleware-level or annotation-based rate limiting exists.

---

## 8. Recent ADR Format Template

**File**: `adr/ADR-094-conditional-field-visibility.md`

```markdown
# ADR-094: Conditional Field Visibility Evaluation Strategy

**Status**: Accepted

**Context**:

[Description of the problem and what decisions need to be made.
Can include sub-decisions labeled Decision A, Decision B, etc.]

**Options Considered**:

### Decision A: [Sub-decision title]

1. **[Option name]** -- [brief description]
   - Pros:
     - [bullet]
   - Cons:
     - [bullet]

2. **[Option name] (chosen)** -- [brief description]
   - Pros:
     - [bullet]
   - Cons:
     - [bullet]

**Decision**:

- Decision A: Option N -- [chosen option name]
- Decision B: Option M -- [chosen option name]

**Rationale**:

[Detailed explanation of why the chosen options were selected,
why alternatives were rejected, and any important tradeoffs.]

**Consequences**:

- Positive:
  - [bullet]

- Negative:
  - [bullet]

- Neutral:
  - [bullet]

- Related: [link to related ADRs]
```

---

## 9. Frontend Patterns

### 9.1 NotificationPreferencesForm Component

**File**: `frontend/components/notifications/notification-preferences-form.tsx`

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { updateNotificationPreferences } from "@/lib/actions/notifications";
import type { NotificationPreference } from "@/lib/actions/notifications";

const NOTIFICATION_TYPE_LABELS: Record<string, string> = {
  TASK_ASSIGNED: "Task Assigned",
  TASK_CLAIMED: "Task Claimed",
  TASK_UPDATED: "Task Updated",
  COMMENT_ADDED: "Comment Added",
  DOCUMENT_SHARED: "Document Shared",
  MEMBER_INVITED: "Member Invited",
  RETAINER_PERIOD_READY_TO_CLOSE: "Retainer Period Ready to Close",
  RETAINER_PERIOD_CLOSED: "Retainer Period Closed",
  RETAINER_APPROACHING_CAPACITY: "Retainer Approaching Capacity",
  RETAINER_FULLY_CONSUMED: "Retainer Fully Consumed",
  RETAINER_TERMINATED: "Retainer Terminated",
};

interface NotificationPreferencesFormProps {
  initialPreferences: NotificationPreference[];
}

export function NotificationPreferencesForm({
  initialPreferences,
}: NotificationPreferencesFormProps) {
  const [preferences, setPreferences] =
    useState<NotificationPreference[]>(initialPreferences);
  const [isSaving, setIsSaving] = useState(false);
  const [saveMessage, setSaveMessage] = useState<string | null>(null);

  function handleToggle(
    notificationType: string,
    field: "inAppEnabled" | "emailEnabled",
    checked: boolean
  ) {
    setPreferences((prev) =>
      prev.map((p) =>
        p.notificationType === notificationType
          ? { ...p, [field]: checked }
          : p
      )
    );
    setSaveMessage(null);
  }

  async function handleSave() {
    setIsSaving(true);
    setSaveMessage(null);
    try {
      const result = await updateNotificationPreferences(preferences);
      setPreferences(result.preferences);
      setSaveMessage("Preferences saved successfully.");
    } catch {
      setSaveMessage("Failed to save preferences. Please try again.");
    } finally {
      setIsSaving(false);
    }
  }

  return (
    <div className="space-y-6">
      <div className="rounded-lg border border-slate-200 bg-white dark:border-slate-800 dark:bg-slate-950">
        {/* Table header: grid-cols-[1fr_80px_80px] */}
        {/* Preference rows with Switch toggles for in-app and email */}
        {/* Email switch is currently disabled with "Coming soon" tooltip */}
      </div>
      <div className="flex items-center gap-4">
        <Button onClick={handleSave} disabled={isSaving}>
          {isSaving ? "Saving..." : "Save preferences"}
        </Button>
        {saveMessage && <p className="text-sm ...">{saveMessage}</p>}
      </div>
    </div>
  );
}
```

### 9.2 IntegrationCard Component

**File**: `frontend/components/integrations/IntegrationCard.tsx`

```tsx
"use client";

import { useState } from "react";
import { Calculator, Sparkles, PenTool, CreditCard, KeyRound } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { SetApiKeyDialog } from "@/components/integrations/SetApiKeyDialog";
import { ConnectionTestButton } from "@/components/integrations/ConnectionTestButton";
import {
  upsertIntegrationAction,
  toggleIntegrationAction,
  deleteApiKeyAction,
} from "@/app/(app)/org/[slug]/settings/integrations/actions";
import type { IntegrationDomain, OrgIntegration } from "@/lib/types";

const DOMAIN_ICONS: Record<IntegrationDomain, React.ComponentType<{ className?: string }>> = {
  ACCOUNTING: Calculator,
  AI: Sparkles,
  DOCUMENT_SIGNING: PenTool,
  PAYMENT: CreditCard,
};

interface IntegrationCardProps {
  domain: IntegrationDomain;
  label: string;
  description: string;
  integration: OrgIntegration | null;
  providers: string[];
  slug: string;
}

export function IntegrationCard({ domain, label, description, integration, providers, slug }: IntegrationCardProps) {
  // State: isTogglingProvider, isTogglingEnabled, isDeletingKey, error
  // Sections: Provider selector (Select), API Key (SetApiKeyDialog), Enable toggle (Switch), Connection test
  // Status badge: Not Configured / Disabled / Active
}
```

### 9.3 Integrations Settings Page

**File**: `frontend/app/(app)/org/[slug]/settings/integrations/page.tsx`

```tsx
import Link from "next/link";
import { ChevronLeft } from "lucide-react";
import { listIntegrations, listProviders } from "@/lib/api/integrations";
import { IntegrationCard } from "@/components/integrations/IntegrationCard";
import type { IntegrationDomain, OrgIntegration } from "@/lib/types";

const DOMAIN_CONFIG: { domain: IntegrationDomain; label: string; description: string }[] = [
  { domain: "ACCOUNTING", label: "Accounting", description: "Connect your accounting software for invoice sync" },
  { domain: "AI", label: "AI Assistant", description: "Enable AI-powered document drafting and analysis" },
  { domain: "DOCUMENT_SIGNING", label: "Document Signing", description: "Enable electronic signatures on documents" },
  { domain: "PAYMENT", label: "Payment Gateway", description: "Accept online payments from customers" },
];

export default async function IntegrationsSettingsPage({ params }: { params: Promise<{ slug: string }> }) {
  const { slug } = await params;
  let integrations: OrgIntegration[] = [];
  let providers: Partial<Record<IntegrationDomain, string[]>> = {};

  try {
    [integrations, providers] = await Promise.all([listIntegrations(), listProviders()]);
  } catch { /* Non-fatal: show empty state */ }

  return (
    <div className="space-y-8">
      <Link href={`/org/${slug}/settings`} className="..."><ChevronLeft /> Settings</Link>
      <div>
        <h1 className="font-display text-3xl text-slate-950 dark:text-slate-50">Integrations</h1>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-400">
          Connect third-party tools and services to your organization.
        </p>
      </div>
      <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
        {DOMAIN_CONFIG.map(config => (
          <IntegrationCard key={config.domain} {...config}
            integration={integrations.find(i => i.domain === config.domain) ?? null}
            providers={providers[config.domain] ?? []} slug={slug} />
        ))}
      </div>
    </div>
  );
}
```

---

## 10. Quick Reference Summary

| Item | Current Value | Next Available |
|------|--------------|----------------|
| ARCHITECTURE.md section | 10 | 11 |
| ADR number | 094 | 095 |
| Tenant migration | V40 | V41 |
| Global migration | V8 | V9 |
| Entity count | 49 | -- |
| Backend packages | 43 | -- |
| Frontend routes | 39 pages | -- |
