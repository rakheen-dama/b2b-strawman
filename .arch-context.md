# Architecture Context Inventory

Generated: 2026-02-20

---

## 1. ARCHITECTURE.md Section Headers

Last section number: **10** (`## 10. Phase 4 -- Customers, Document Scopes & Tasks`)
Next available section number: **11**

```
## 1. Overview
## 2. Architecture Decision Records
## 3. Component Architecture
## 4. Sequence Diagrams
## 5. Data Flow Diagrams
## 6. Security Architecture
## 7. Infrastructure Architecture
## 8. Database Architecture
## 9. Phase 2 -- Billing & Tiered Tenancy
## 10. Phase 4 -- Customers, Document Scopes & Tasks
## Appendix A: Clerk JWT Claims
## Appendix B: Environment Variables Reference
```

Note: Phases 5+ have separate architecture docs in `architecture/phase{N}-*.md`.

---

## 2. ADR Numbering

Highest ADR number: **ADR-075** (`ADR-075-one-active-retainer-per-customer.md`)
Next available ADR number: **076**

| Range | Phase/Topic |
|-------|-------------|
| 001-009 | Inline in ARCHITECTURE.md |
| 010-016 | Phase 2 (Billing & Tenancy) |
| 017-020 | Phase 4 (Customers, Document Scopes, Tasks) |
| 021-024 | Phase 5 (Task & Time Lifecycle) |
| 025-029 | Phase 6 (Audit & Compliance) |
| 030-033 | Phase 7 (Customer Portal) |
| 034-038 | Phase 6.5 (Notifications, Comments, Activity) |
| 039-043 | Phase 8 (Rate Cards, Budgets, Profitability) |
| 044-047 | Phase 9 (Dashboard) |
| 048-051 | Phase 10 (Invoicing) |
| 052-055 | Phase 11 (Custom Fields, Tags, Views) |
| 056-059 | Phase 12 (Document Templates) |
| 060-063 | Phase 14 (Customer Compliance & Lifecycle) |
| 064     | Phase 13 (Dedicated Schema Only) |
| 065-067 | Phase 15 (Setup Guidance & Detail Pages) |
| 068-069 | Phase 16 (Project Templates) |
| 070-071 | Phase 17 (Recurring Schedules) |
| 072-075 | Phase 18 (Retainers) |

---

## 3. Migration Numbering

### Global Migrations (`db/migration/global/`)

Highest: **V7** (`V7__create_portal_schema.sql`)
Next available: **V8**

```
V1__create_org_schema_mapping.sql
V2__create_organizations.sql
V3__create_processed_webhooks.sql
V4__add_org_tier.sql
V5__drop_schema_name_unique.sql
V6__add_subscriptions.sql
V7__create_portal_schema.sql
```

### Tenant Migrations (`db/migration/tenant/`)

Highest: **V31** (`V31__create_retainer_tables.sql`)
Next available: **V32**

```
V1__create_projects.sql          V17__create_rate_budget_tables.sql
V2__create_documents.sql         V18__add_time_entry_rate_snapshots.sql
V3__create_members.sql           V19__add_project_budget_version.sql
V4__migrate_ownership_to_members.sql  V20__add_dashboard_indexes.sql
V5__create_project_members.sql   V21__create_invoices.sql
V6__add_missing_fk_indexes.sql   V22__add_field_definitions_groups.sql
V7__create_customers.sql         V23__add_tags.sql
V8__create_customer_projects.sql V24__add_field_pack_status.sql
V9__create_tasks.sql             V25__add_custom_field_columns.sql
V10__extend_documents_scope.sql  V26__add_saved_views.sql
V11__create_time_entries.sql     V27__create_document_templates.sql
V12__create_audit_events.sql     V28__add_branding_and_template_pack_status.sql
V13__create_comments.sql         V29__customer_compliance_lifecycle.sql
V14__create_notifications.sql    V30__project_templates_recurring_schedules.sql
V15__create_notification_preferences.sql  V31__create_retainer_tables.sql
V16__create_portal_contacts_and_magic_link_tokens.sql
```

---

## 4. Entity Inventory (44 @Entity classes)

All paths relative to `backend/src/main/java/io/b2mash/b2b/b2bstrawman/`

| Entity | Package | File |
|--------|---------|------|
| AuditEvent | audit | `audit/AuditEvent.java` |
| BillingRate | billingrate | `billingrate/BillingRate.java` |
| Subscription | billing | `billing/Subscription.java` |
| ProjectBudget | budget | `budget/ProjectBudget.java` |
| ChecklistTemplate | checklist | `checklist/ChecklistTemplate.java` |
| ChecklistInstance | checklist | `checklist/ChecklistInstance.java` |
| ChecklistInstanceItem | checklist | `checklist/ChecklistInstanceItem.java` |
| ChecklistTemplateItem | checklist | `checklist/ChecklistTemplateItem.java` |
| Comment | comment | `comment/Comment.java` |
| CostRate | costrate | `costrate/CostRate.java` |
| Customer | customer | `customer/Customer.java` |
| CustomerProject | customer | `customer/CustomerProject.java` |
| DataSubjectRequest | datarequest | `datarequest/DataSubjectRequest.java` |
| Document | document | `document/Document.java` |
| FieldDefinition | fielddefinition | `fielddefinition/FieldDefinition.java` |
| FieldGroup | fielddefinition | `fielddefinition/FieldGroup.java` |
| FieldGroupMember | fielddefinition | `fielddefinition/FieldGroupMember.java` |
| Invoice | invoice | `invoice/Invoice.java` |
| InvoiceLine | invoice | `invoice/InvoiceLine.java` |
| InvoiceCounter | invoice | `invoice/InvoiceCounter.java` |
| Member | member | `member/Member.java` |
| ProjectMember | member | `member/ProjectMember.java` |
| OrgSchemaMapping | multitenancy | `multitenancy/OrgSchemaMapping.java` |
| Notification | notification | `notification/Notification.java` |
| NotificationPreference | notification | `notification/NotificationPreference.java` |
| Organization | provisioning | `provisioning/Organization.java` |
| PortalContact | portal | `portal/PortalContact.java` |
| MagicLinkToken | portal | `portal/MagicLinkToken.java` |
| Project | project | `project/Project.java` |
| ProjectTemplate | projecttemplate | `projecttemplate/ProjectTemplate.java` |
| TemplateTask | projecttemplate | `projecttemplate/TemplateTask.java` |
| RecurringSchedule | schedule | `schedule/RecurringSchedule.java` |
| ScheduleExecution | schedule | `schedule/ScheduleExecution.java` |
| RetainerAgreement | retainer | `retainer/RetainerAgreement.java` |
| RetainerPeriod | retainer | `retainer/RetainerPeriod.java` |
| RetentionPolicy | retention | `retention/RetentionPolicy.java` |
| OrgSettings | settings | `settings/OrgSettings.java` |
| Tag | tag | `tag/Tag.java` |
| EntityTag | tag | `tag/EntityTag.java` |
| Task | task | `task/Task.java` |
| DocumentTemplate | template | `template/DocumentTemplate.java` |
| GeneratedDocument | template | `template/GeneratedDocument.java` |
| TimeEntry | timeentry | `timeentry/TimeEntry.java` |
| SavedView | view | `view/SavedView.java` |

---

## 5. Backend Package Structure

Base: `src/main/java/io/b2mash/b2b/b2bstrawman/`

```
activity/          audit/             billing/           billingrate/
budget/            checklist/         comment/           compliance/
config/            costrate/          customer/          customerbackend/
dashboard/         datarequest/       dev/               document/
event/             exception/         fielddefinition/   invoice/
member/            multitenancy/      mywork/            notification/
portal/            project/           projecttemplate/   provisioning/
report/            retainer/          retention/         s3/
schedule/          security/          settings/          setupstatus/
tag/               task/              template/          timeentry/
view/
```

(41 packages total)

---

## 6. Frontend Route Structure

Under `frontend/app/(app)/org/[slug]/`:

```
layout.tsx
compliance/page.tsx
compliance/requests/page.tsx
compliance/requests/[id]/page.tsx
customers/page.tsx
customers/[id]/page.tsx
dashboard/page.tsx
documents/page.tsx
invoices/page.tsx
invoices/[id]/page.tsx
my-work/page.tsx
notifications/page.tsx
profitability/page.tsx
projects/page.tsx
projects/[id]/page.tsx
schedules/page.tsx
schedules/[id]/page.tsx
settings/page.tsx
settings/billing/page.tsx
settings/checklists/page.tsx
settings/checklists/new/page.tsx
settings/compliance/page.tsx
settings/custom-fields/page.tsx
settings/notifications/page.tsx
settings/project-templates/page.tsx
settings/project-templates/[id]/page.tsx
settings/rates/page.tsx
settings/tags/page.tsx
settings/templates/page.tsx
settings/templates/new/page.tsx
settings/templates/[id]/edit/page.tsx
team/page.tsx
```

---

## 7. Existing Portal Patterns

### 7a. PortalEventHandler (FULL SOURCE)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/handler/PortalEventHandler.java`

```java
package io.b2mash.b2b.b2bstrawman.customerbackend.handler;

import io.b2mash.b2b.b2bstrawman.customer.CustomerProjectRepository;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.CustomerProjectLinkedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.CustomerProjectUnlinkedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.CustomerUpdatedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.DocumentCreatedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.DocumentDeletedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.DocumentVisibilityChangedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.ProjectUpdatedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.event.TimeEntryAggregatedEvent;
import io.b2mash.b2b.b2bstrawman.customerbackend.repository.PortalReadModelRepository;
import io.b2mash.b2b.b2bstrawman.document.DocumentRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.project.ProjectRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

@Component
public class PortalEventHandler {

  private static final Logger log = LoggerFactory.getLogger(PortalEventHandler.class);

  private final PortalReadModelRepository readModelRepo;
  private final ProjectRepository projectRepository;
  private final DocumentRepository documentRepository;
  private final CustomerProjectRepository customerProjectRepository;

  public PortalEventHandler(
      PortalReadModelRepository readModelRepo,
      ProjectRepository projectRepository,
      DocumentRepository documentRepository,
      CustomerProjectRepository customerProjectRepository) {
    this.readModelRepo = readModelRepo;
    this.projectRepository = projectRepository;
    this.documentRepository = documentRepository;
    this.customerProjectRepository = customerProjectRepository;
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onCustomerProjectLinked(CustomerProjectLinkedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        var projectOpt = projectRepository.findById(event.getProjectId());
        if (projectOpt.isEmpty()) {
          log.warn("Project not found for CustomerProjectLinkedEvent: projectId={}", event.getProjectId());
          return;
        }
        var project = projectOpt.get();
        readModelRepo.upsertPortalProject(
            project.getId(), event.getCustomerId(), event.getOrgId(),
            project.getName(), "ACTIVE", project.getDescription(), project.getCreatedAt());
      } catch (Exception e) {
        log.warn("Failed to project CustomerProjectLinkedEvent: customerId={}, projectId={}",
            event.getCustomerId(), event.getProjectId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onCustomerProjectUnlinked(CustomerProjectUnlinkedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        readModelRepo.deletePortalProject(event.getProjectId(), event.getCustomerId());
      } catch (Exception e) {
        log.warn("Failed to project CustomerProjectUnlinkedEvent: customerId={}, projectId={}",
            event.getCustomerId(), event.getProjectId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onProjectUpdated(ProjectUpdatedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        var customerIds = readModelRepo.findCustomerIdsByProjectId(event.getProjectId(), event.getOrgId());
        var status = event.getStatus() != null ? event.getStatus() : "ACTIVE";
        for (var customerId : customerIds) {
          readModelRepo.updatePortalProjectDetails(
              event.getProjectId(), customerId, event.getName(), status, event.getDescription());
        }
      } catch (Exception e) {
        log.warn("Failed to project ProjectUpdatedEvent: projectId={}", event.getProjectId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onCustomerUpdated(CustomerUpdatedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        if (!"ARCHIVED".equals(event.getStatus())) return;
        var links = customerProjectRepository.findByCustomerId(event.getCustomerId());
        for (var link : links) {
          readModelRepo.deletePortalProject(link.getProjectId(), event.getCustomerId());
        }
      } catch (Exception e) {
        log.warn("Failed to project CustomerUpdatedEvent: customerId={}", event.getCustomerId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onDocumentCreated(DocumentCreatedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        if (!"SHARED".equals(event.getVisibility())) return;
        var customerIds = readModelRepo.findCustomerIdsByProjectId(event.getProjectId(), event.getOrgId());
        for (var customerId : customerIds) {
          readModelRepo.upsertPortalDocument(event.getDocumentId(), event.getOrgId(), customerId,
              event.getProjectId(), event.getFileName(), event.getContentType(), event.getSize(),
              event.getScope(), event.getS3Key(), event.getOccurredAt());
          readModelRepo.incrementDocumentCount(event.getProjectId(), customerId);
        }
      } catch (Exception e) {
        log.warn("Failed to project DocumentCreatedEvent: documentId={}", event.getDocumentId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onDocumentVisibilityChanged(DocumentVisibilityChangedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        if ("SHARED".equals(event.getVisibility())) {
          var docOpt = documentRepository.findById(event.getDocumentId());
          if (docOpt.isEmpty()) return;
          var doc = docOpt.get();
          var customerIds = readModelRepo.findCustomerIdsByProjectId(doc.getProjectId(), event.getOrgId());
          for (var customerId : customerIds) {
            readModelRepo.upsertPortalDocument(doc.getId(), event.getOrgId(), customerId,
                doc.getProjectId(), doc.getFileName(), doc.getContentType(), doc.getSize(),
                doc.getScope(), doc.getS3Key(), doc.getUploadedAt());
            readModelRepo.incrementDocumentCount(doc.getProjectId(), customerId);
          }
        } else if ("SHARED".equals(event.getPreviousVisibility())) {
          var portalDoc = readModelRepo.findPortalDocumentById(event.getDocumentId(), event.getOrgId());
          if (portalDoc.isPresent()) {
            var projectId = portalDoc.get().portalProjectId();
            var customerIds = readModelRepo.findCustomerIdsByProjectId(projectId, event.getOrgId());
            readModelRepo.deletePortalDocument(event.getDocumentId(), event.getOrgId());
            for (var customerId : customerIds) {
              readModelRepo.decrementDocumentCount(projectId, customerId);
            }
          }
        }
      } catch (Exception e) {
        log.warn("Failed to project DocumentVisibilityChangedEvent: documentId={}", event.getDocumentId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onDocumentDeleted(DocumentDeletedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        var portalDoc = readModelRepo.findPortalDocumentById(event.getDocumentId(), event.getOrgId());
        if (portalDoc.isPresent()) {
          var projectId = portalDoc.get().portalProjectId();
          var customerIds = readModelRepo.findCustomerIdsByProjectId(projectId, event.getOrgId());
          readModelRepo.deletePortalDocument(event.getDocumentId(), event.getOrgId());
          for (var customerId : customerIds) {
            readModelRepo.decrementDocumentCount(projectId, customerId);
          }
        } else {
          readModelRepo.deletePortalDocument(event.getDocumentId(), event.getOrgId());
        }
      } catch (Exception e) {
        log.warn("Failed to project DocumentDeletedEvent: documentId={}", event.getDocumentId(), e);
      }
    });
  }

  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onTimeEntryAggregated(TimeEntryAggregatedEvent event) {
    handleInTenantScope(event.getTenantId(), event.getOrgId(), () -> {
      try {
        var customerIds = readModelRepo.findCustomerIdsByProjectId(event.getProjectId(), event.getOrgId());
        for (var customerId : customerIds) {
          readModelRepo.upsertPortalProjectSummary(
              event.getProjectId(), customerId, event.getOrgId(),
              event.getTotalHours(), event.getBillableHours(), event.getLastActivityAt());
        }
      } catch (Exception e) {
        log.warn("Failed to project TimeEntryAggregatedEvent: projectId={}", event.getProjectId(), e);
      }
    });
  }

  private void handleInTenantScope(String tenantId, String orgId, Runnable action) {
    if (tenantId != null) {
      var carrier = ScopedValue.where(RequestScopes.TENANT_ID, tenantId);
      if (orgId != null) {
        carrier = carrier.where(RequestScopes.ORG_ID, orgId);
      }
      carrier.run(action);
    } else {
      log.warn("Event received with null tenantId -- running without tenant scope binding");
      action.run();
    }
  }
}
```

### 7b. PortalReadModelRepository (FULL SOURCE)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/repository/PortalReadModelRepository.java`

```java
package io.b2mash.b2b.b2bstrawman.customerbackend.repository;

import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalCommentView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalDocumentView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalProjectSummaryView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalProjectView;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.simple.JdbcClient;
import org.springframework.stereotype.Repository;

@Repository
public class PortalReadModelRepository {

  private final JdbcClient jdbc;

  public PortalReadModelRepository(@Qualifier("portalJdbcClient") JdbcClient jdbc) {
    this.jdbc = jdbc;
  }

  private static Timestamp toTimestamp(Instant instant) {
    return instant != null ? Timestamp.from(instant) : null;
  }

  // ---- Upsert methods ----

  public void upsertPortalProject(
      UUID projectId, UUID customerId, String orgId,
      String name, String status, String description, Instant createdAt) {
    jdbc.sql("""
        INSERT INTO portal.portal_projects
            (id, customer_id, org_id, name, status, description, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, now())
        ON CONFLICT (id, customer_id)
        DO UPDATE SET name = EXCLUDED.name, status = EXCLUDED.status,
                      description = EXCLUDED.description, updated_at = now()
        """)
        .params(projectId, customerId, orgId, name, status, description, toTimestamp(createdAt))
        .update();
  }

  public void upsertPortalDocument(
      UUID documentId, String orgId, UUID customerId, UUID portalProjectId,
      String title, String contentType, Long size, String scope,
      String s3Key, Instant uploadedAt) {
    jdbc.sql("""
        INSERT INTO portal.portal_documents
            (id, org_id, customer_id, portal_project_id, title, content_type,
             size, scope, s3_key, uploaded_at, synced_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, now())
        ON CONFLICT (id)
        DO UPDATE SET title = EXCLUDED.title, content_type = EXCLUDED.content_type,
                      size = EXCLUDED.size, scope = EXCLUDED.scope,
                      s3_key = EXCLUDED.s3_key, synced_at = now()
        """)
        .params(documentId, orgId, customerId, portalProjectId, title,
            contentType, size, scope, s3Key, toTimestamp(uploadedAt))
        .update();
  }

  public void upsertPortalComment(
      UUID commentId, String orgId, UUID portalProjectId,
      String authorName, String content, Instant createdAt) {
    jdbc.sql("""
        INSERT INTO portal.portal_comments
            (id, org_id, portal_project_id, author_name, content, created_at, synced_at)
        VALUES (?, ?, ?, ?, ?, ?, now())
        ON CONFLICT (id)
        DO UPDATE SET author_name = EXCLUDED.author_name,
                      content = EXCLUDED.content, synced_at = now()
        """)
        .params(commentId, orgId, portalProjectId, authorName, content, toTimestamp(createdAt))
        .update();
  }

  public void upsertPortalProjectSummary(
      UUID projectId, UUID customerId, String orgId,
      BigDecimal totalHours, BigDecimal billableHours, Instant lastActivityAt) {
    jdbc.sql("""
        INSERT INTO portal.portal_project_summaries
            (id, customer_id, org_id, total_hours, billable_hours, last_activity_at, synced_at)
        VALUES (?, ?, ?, ?, ?, ?, now())
        ON CONFLICT (id, customer_id)
        DO UPDATE SET total_hours = EXCLUDED.total_hours,
                      billable_hours = EXCLUDED.billable_hours,
                      last_activity_at = EXCLUDED.last_activity_at, synced_at = now()
        """)
        .params(projectId, customerId, orgId, totalHours, billableHours, toTimestamp(lastActivityAt))
        .update();
  }

  public void updatePortalProjectDetails(
      UUID projectId, UUID customerId, String name, String status, String description) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET name = ?, status = ?, description = ?, updated_at = now()
        WHERE id = ? AND customer_id = ?
        """)
        .params(name, status, description, projectId, customerId)
        .update();
  }

  // ---- Delete methods ----

  public void deletePortalProject(UUID projectId, UUID customerId) { /* ... */ }
  public void deletePortalDocument(UUID documentId, String orgId) { /* ... */ }
  public void deletePortalComment(UUID commentId, String orgId) { /* ... */ }
  public void deletePortalProjectsByOrg(String orgId) { /* ... */ }
  public void deletePortalDocumentsByOrg(String orgId) { /* ... */ }
  public void deletePortalCommentsByOrg(String orgId) { /* ... */ }
  public void deletePortalProjectSummariesByOrg(String orgId) { /* ... */ }

  // ---- Count methods ----

  public void setDocumentCount(UUID projectId, UUID customerId, int count) { /* ... */ }
  public void incrementDocumentCount(UUID projectId, UUID customerId) { /* ... */ }
  public void decrementDocumentCount(UUID projectId, UUID customerId) { /* ... */ }
  public void incrementCommentCount(UUID projectId, UUID customerId) { /* ... */ }
  public void decrementCommentCount(UUID projectId, UUID customerId) { /* ... */ }

  // ---- Lookup methods ----

  public Optional<PortalDocumentView> findPortalDocumentById(UUID documentId, String orgId) { /* ... */ }
  public List<UUID> findCustomerIdsByProjectId(UUID projectId, String orgId) { /* ... */ }

  // ---- Query methods ----

  public List<PortalProjectView> findProjectsByCustomer(String orgId, UUID customerId) { /* ... */ }
  public Optional<PortalProjectView> findProjectDetail(UUID projectId, UUID customerId, String orgId) { /* ... */ }
  public List<PortalDocumentView> findDocumentsByProject(UUID portalProjectId, String orgId) { /* ... */ }
  public List<PortalDocumentView> findDocumentsByCustomer(String orgId, UUID customerId) { /* ... */ }
  public List<PortalCommentView> findCommentsByProject(UUID portalProjectId, String orgId) { /* ... */ }
  public Optional<PortalProjectSummaryView> findProjectSummary(UUID projectId, UUID customerId, String orgId) { /* ... */ }
}
```

### 7c. CustomerAuthFilter (FULL SOURCE)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/CustomerAuthFilter.java`

```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMapping;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.multitenancy.ScopedFilterChain;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class CustomerAuthFilter extends OncePerRequestFilter {

  private static final Logger log = LoggerFactory.getLogger(CustomerAuthFilter.class);
  private static final String BEARER_PREFIX = "Bearer ";

  private final PortalJwtService portalJwtService;
  private final OrgSchemaMappingRepository mappingRepository;
  private final PortalContactRepository portalContactRepository;

  public CustomerAuthFilter(
      PortalJwtService portalJwtService,
      OrgSchemaMappingRepository mappingRepository,
      PortalContactRepository portalContactRepository) {
    this.portalJwtService = portalJwtService;
    this.mappingRepository = mappingRepository;
    this.portalContactRepository = portalContactRepository;
  }

  @Override
  protected void doFilterInternal(
      HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {

    String authHeader = request.getHeader("Authorization");
    if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing or invalid Authorization");
      return;
    }

    String token = authHeader.substring(BEARER_PREFIX.length());
    PortalJwtService.PortalClaims claims;
    try {
      claims = portalJwtService.verifyToken(token);
    } catch (PortalAuthException e) {
      log.debug("Portal auth failed: {}", e.getMessage());
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
      return;
    }

    // Resolve tenant from org ID
    String schema = mappingRepository
        .findByClerkOrgId(claims.clerkOrgId())
        .map(OrgSchemaMapping::getSchemaName)
        .orElse(null);
    if (schema == null) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Organization not provisioned");
      return;
    }

    // Binds: CUSTOMER_ID, TENANT_ID, ORG_ID, optionally PORTAL_CONTACT_ID
    var carrier = ScopedValue.where(RequestScopes.CUSTOMER_ID, claims.customerId())
        .where(RequestScopes.TENANT_ID, schema)
        .where(RequestScopes.ORG_ID, claims.clerkOrgId());

    // Attempt to resolve PortalContact and bind PORTAL_CONTACT_ID
    try {
      var contact = ScopedValue.where(RequestScopes.TENANT_ID, schema)
          .call(() -> portalContactRepository
              .findByCustomerIdAndOrgId(claims.customerId(), claims.clerkOrgId())
              .orElse(null));
      if (contact != null) {
        carrier = carrier.where(RequestScopes.PORTAL_CONTACT_ID, contact.getId());
      }
    } catch (Exception e) {
      log.warn("Could not resolve portal contact for customer {}: {}",
          claims.customerId(), e.getMessage());
    }

    ScopedFilterChain.runScoped(carrier, filterChain, request, response);
  }

  @Override
  protected boolean shouldNotFilter(HttpServletRequest request) {
    String path = request.getRequestURI();
    if (!path.startsWith("/portal/")) return true;
    if (path.startsWith("/portal/dev/")) return true;
    return path.startsWith("/portal/auth/");
  }
}
```

### 7d. Portal API Controllers and Endpoints

| Controller | Base Path | Endpoints |
|---|---|---|
| `PortalAuthController` | `/portal/auth` | `POST /request-link`, `POST /exchange` |
| `PortalProjectController` | `/portal/projects` | `GET /` (list), `GET /{id}` (detail) |
| `PortalDocumentController` | `/portal` | `GET /projects/{projectId}/documents`, `GET /documents`, `GET /documents/{documentId}/presign-download` |
| `PortalCommentController` | `/portal/projects/{projectId}/comments` | `GET /` (list only -- NO POST) |
| `PortalSummaryController` | `/portal/projects/{projectId}/summary` | `GET /` |
| `PortalProfileController` | `/portal/me` | `GET /` |
| `PortalResyncController` | `/internal/portal` | `POST /resync/{orgId}` |
| `DevPortalController` | `/portal/dev` | (dev-only Thymeleaf harness) |

### 7e. Portal Read-Model Schema Migration

**File**: `backend/src/main/resources/db/migration/global/V7__create_portal_schema.sql`

```sql
CREATE SCHEMA IF NOT EXISTS portal;

CREATE TABLE IF NOT EXISTS portal.portal_projects (
    id              UUID NOT NULL,
    org_id          VARCHAR(255) NOT NULL,
    customer_id     UUID NOT NULL,
    name            VARCHAR(255) NOT NULL,
    status          VARCHAR(50) NOT NULL,
    description     TEXT,
    document_count  INT NOT NULL DEFAULT 0,
    comment_count   INT NOT NULL DEFAULT 0,
    created_at      TIMESTAMP NOT NULL,
    updated_at      TIMESTAMP NOT NULL DEFAULT now(),
    PRIMARY KEY (id, customer_id)
);

CREATE INDEX IF NOT EXISTS idx_portal_projects_org_customer
    ON portal.portal_projects(org_id, customer_id);

CREATE TABLE IF NOT EXISTS portal.portal_documents (
    id                  UUID PRIMARY KEY,
    org_id              VARCHAR(255) NOT NULL,
    customer_id         UUID,
    portal_project_id   UUID,
    title               VARCHAR(500) NOT NULL,
    content_type        VARCHAR(100),
    size                BIGINT,
    scope               VARCHAR(20) NOT NULL,
    s3_key              VARCHAR(1000) NOT NULL,
    uploaded_at         TIMESTAMP,
    synced_at           TIMESTAMP NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_portal_documents_project
    ON portal.portal_documents(portal_project_id);
CREATE INDEX IF NOT EXISTS idx_portal_documents_org_customer
    ON portal.portal_documents(org_id, customer_id);

CREATE TABLE IF NOT EXISTS portal.portal_comments (
    id                  UUID PRIMARY KEY,
    org_id              VARCHAR(255) NOT NULL,
    portal_project_id   UUID NOT NULL,
    author_name         VARCHAR(255) NOT NULL,
    content             TEXT NOT NULL,
    created_at          TIMESTAMP NOT NULL,
    synced_at           TIMESTAMP NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_portal_comments_project
    ON portal.portal_comments(portal_project_id);

CREATE TABLE IF NOT EXISTS portal.portal_project_summaries (
    id              UUID NOT NULL,
    org_id          VARCHAR(255) NOT NULL,
    customer_id     UUID NOT NULL,
    total_hours     DECIMAL(10,2) NOT NULL DEFAULT 0,
    billable_hours  DECIMAL(10,2) NOT NULL DEFAULT 0,
    last_activity_at TIMESTAMP,
    synced_at       TIMESTAMP NOT NULL DEFAULT now(),
    PRIMARY KEY (id, customer_id)
);
```

---

## 8. Recent ADR Format Template

Based on ADR-075 (the most recent ADR):

```markdown
# ADR-{NNN}: {Title}

**Status**: Accepted
**Date**: YYYY-MM-DD

**Context**:

{1-2 paragraphs explaining the problem, current state, and constraints.}

**Options Considered**:

1. **{Option name} (chosen)** -- {Brief description.}
   - Pros: {list}
   - Cons: {list}

2. **{Option name}** -- {Brief description.}
   - Pros: {list}
   - Cons: {list}

3. **{Option name}** -- {Brief description.}
   - Pros: {list}
   - Cons: {list}

**Decision**: Option N -- {chosen option name}.

**Rationale**:

{2-3 paragraphs explaining WHY this option was chosen.}

**Consequences**:

- Positive:
  - {Bullet points}

- Negative:
  - {Bullet points with mitigations in parentheses}
```

---

## 9. Portal Read-Model Current State

Four tables in the `portal` schema:

### portal.portal_projects
| Column | Type | Constraints |
|---|---|---|
| id | UUID | NOT NULL, PK (composite with customer_id) |
| org_id | VARCHAR(255) | NOT NULL |
| customer_id | UUID | NOT NULL, PK (composite with id) |
| name | VARCHAR(255) | NOT NULL |
| status | VARCHAR(50) | NOT NULL |
| description | TEXT | |
| document_count | INT | NOT NULL DEFAULT 0 |
| comment_count | INT | NOT NULL DEFAULT 0 |
| created_at | TIMESTAMP | NOT NULL |
| updated_at | TIMESTAMP | NOT NULL DEFAULT now() |

### portal.portal_documents
| Column | Type | Constraints |
|---|---|---|
| id | UUID | PRIMARY KEY |
| org_id | VARCHAR(255) | NOT NULL |
| customer_id | UUID | |
| portal_project_id | UUID | |
| title | VARCHAR(500) | NOT NULL |
| content_type | VARCHAR(100) | |
| size | BIGINT | |
| scope | VARCHAR(20) | NOT NULL |
| s3_key | VARCHAR(1000) | NOT NULL |
| uploaded_at | TIMESTAMP | |
| synced_at | TIMESTAMP | NOT NULL DEFAULT now() |

### portal.portal_comments
| Column | Type | Constraints |
|---|---|---|
| id | UUID | PRIMARY KEY |
| org_id | VARCHAR(255) | NOT NULL |
| portal_project_id | UUID | NOT NULL |
| author_name | VARCHAR(255) | NOT NULL |
| content | TEXT | NOT NULL |
| created_at | TIMESTAMP | NOT NULL |
| synced_at | TIMESTAMP | NOT NULL DEFAULT now() |

### portal.portal_project_summaries
| Column | Type | Constraints |
|---|---|---|
| id | UUID | NOT NULL, PK (composite with customer_id) |
| org_id | VARCHAR(255) | NOT NULL |
| customer_id | UUID | NOT NULL, PK (composite with id) |
| total_hours | DECIMAL(10,2) | NOT NULL DEFAULT 0 |
| billable_hours | DECIMAL(10,2) | NOT NULL DEFAULT 0 |
| last_activity_at | TIMESTAMP | |
| synced_at | TIMESTAMP | NOT NULL DEFAULT now() |

---

## 10. Invoice Domain Events

All implement the `DomainEvent` sealed interface. All are records in `io.b2mash.b2b.b2bstrawman.event`.

### InvoiceApprovedEvent
```java
public record InvoiceApprovedEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID createdByMemberId, String invoiceNumber, String customerName)
    implements DomainEvent {}
```

### InvoiceSentEvent
```java
public record InvoiceSentEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID createdByMemberId, String invoiceNumber, String customerName)
    implements DomainEvent {}
```

### InvoicePaidEvent
```java
public record InvoicePaidEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID createdByMemberId, String invoiceNumber, String customerName,
    String paymentReference)
    implements DomainEvent {}
```

### InvoiceVoidedEvent
```java
public record InvoiceVoidedEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID createdByMemberId, String invoiceNumber, String customerName,
    UUID approvedByMemberId)
    implements DomainEvent {}
```

---

## 11. Task Domain Events

All implement the `DomainEvent` sealed interface. All are records in `io.b2mash.b2b.b2bstrawman.event`.

### TaskAssignedEvent
```java
public record TaskAssignedEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID assigneeMemberId, String taskTitle)
    implements DomainEvent {}
```

### TaskClaimedEvent
```java
public record TaskClaimedEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    UUID previousAssigneeId, String taskTitle)
    implements DomainEvent {}
```

### TaskStatusChangedEvent
```java
public record TaskStatusChangedEvent(
    String eventType, String entityType, UUID entityId, UUID projectId,
    UUID actorMemberId, String actorName, String tenantId, String orgId,
    Instant occurredAt, Map<String, Object> details,
    String oldStatus, String newStatus, UUID assigneeMemberId, String taskTitle)
    implements DomainEvent {}
```

---

## 12. OrgSettings Entity (FULL SOURCE)

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/settings/OrgSettings.java`

```java
@Entity
@Table(name = "org_settings")
public class OrgSettings {

  @Id @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "default_currency", nullable = false, length = 3)
  private String defaultCurrency;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "field_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> fieldPackStatus;

  // ---- Branding fields ----
  @Column(name = "logo_s3_key", length = 500)
  private String logoS3Key;

  @Column(name = "brand_color", length = 7)
  private String brandColor;

  @Column(name = "document_footer_text", columnDefinition = "TEXT")
  private String documentFooterText;

  // ---- Template pack tracking ----
  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "template_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> templatePackStatus;

  // ---- Compliance settings ----
  @Column(name = "dormancy_threshold_days")
  private Integer dormancyThresholdDays;

  @Column(name = "data_request_deadline_days")
  private Integer dataRequestDeadlineDays;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "compliance_pack_status", columnDefinition = "jsonb")
  private List<Map<String, Object>> compliancePackStatus;

  // Methods: updateCurrency(), recordPackApplication(), recordTemplatePackApplication(),
  //   recordCompliancePackApplication(), anonymize()
  // Branding getters/setters: getLogoS3Key/setLogoS3Key, getBrandColor/setBrandColor,
  //   getDocumentFooterText/setDocumentFooterText
}
```

---

## 13. Frontend Dockerfile

**File**: `frontend/Dockerfile`

```dockerfile
# Stage 1: Install dependencies
FROM node:20-alpine AS deps
WORKDIR /app
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY --from=deps /app/node_modules ./node_modules
COPY . .
ARG NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
ENV NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=$NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
ENV NEXT_TELEMETRY_DISABLED=1
RUN pnpm build

# Stage 3: Production runner
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV HOSTNAME=0.0.0.0
ENV PORT=3000
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
USER nextjs
EXPOSE 3000
CMD ["node", "server.js"]
```

---

## 14. Docker Compose Configuration

**File**: `compose/docker-compose.yml`

Active services:
- **postgres**: `postgres:16-alpine`, port 5432, volume `postgres_data`, healthcheck via `pg_isready`
- **localstack**: `localstack/localstack:latest`, port 4566, S3 only, volume `localstack_data`

Backend and frontend service definitions are commented out but available as templates:
- Backend: port 8080, depends on postgres+localstack, `SPRING_DATASOURCE_URL`, `INTERNAL_API_KEY`
- Frontend: port 3000, depends on backend, `BACKEND_URL: http://backend:8080`, `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` as build-arg

---

## 15. Portal Comment POST Endpoint

**Status: NOT IMPLEMENTED**

The existing `PortalCommentController` at `/portal/projects/{projectId}/comments` only has a `GET` endpoint (list comments). There is NO POST endpoint for customers to submit comments through the portal. Comments visible in the portal are synced from the main app's comment system via the read-model event handler.

---

## 16. Event Hierarchies

### DomainEvent (sealed interface) -- for audit/notification/activity

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/event/DomainEvent.java`

Current permits (16 types):
```
BudgetThresholdEvent, CommentCreatedEvent, CommentUpdatedEvent, CommentDeletedEvent,
CommentVisibilityChangedEvent, TaskAssignedEvent, TaskClaimedEvent, TaskStatusChangedEvent,
DocumentUploadedEvent, MemberAddedToProjectEvent, InvoiceApprovedEvent, InvoiceSentEvent,
InvoicePaidEvent, InvoiceVoidedEvent, DocumentGeneratedEvent, TimeEntryChangedEvent
```

All event files in `event/` package:
```
BudgetThresholdEvent.java      DocumentGeneratedEvent.java    InvoicePaidEvent.java
CommentCreatedEvent.java       DocumentUploadedEvent.java     InvoiceSentEvent.java
CommentDeletedEvent.java       DomainEvent.java               InvoiceVoidedEvent.java
CommentUpdatedEvent.java       InvoiceApprovedEvent.java      MemberAddedToProjectEvent.java
CommentVisibilityChangedEvent.java                            TaskAssignedEvent.java
                                                              TaskClaimedEvent.java
                                                              TaskStatusChangedEvent.java
                                                              TimeEntryChangedEvent.java
```

### PortalDomainEvent (sealed abstract class) -- for portal read-model projection

**File**: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/event/PortalDomainEvent.java`

Current permits (10 types):
```
CustomerCreatedEvent, CustomerUpdatedEvent, ProjectCreatedEvent, ProjectUpdatedEvent,
CustomerProjectLinkedEvent, CustomerProjectUnlinkedEvent, DocumentCreatedEvent,
DocumentVisibilityChangedEvent, DocumentDeletedEvent, TimeEntryAggregatedEvent
```

All event files in `customerbackend/event/` package:
```
CustomerCreatedEvent.java          DocumentDeletedEvent.java
CustomerProjectLinkedEvent.java    DocumentVisibilityChangedEvent.java
CustomerProjectUnlinkedEvent.java  PortalDomainEvent.java
CustomerUpdatedEvent.java          ProjectCreatedEvent.java
DocumentCreatedEvent.java          ProjectUpdatedEvent.java
                                   TimeEntryAggregatedEvent.java
```

---

## Quick Reference

| Resource | Current Max | Next Available |
|----------|-------------|----------------|
| ARCHITECTURE.md section | 10 | 11 |
| ADR number | 075 | 076 |
| Global migration | V7 | V8 |
| Tenant migration | V31 | V32 |
| Entity count | 44 | -- |
| Backend packages | 41 | -- |
| Frontend routes | 32 pages | -- |
