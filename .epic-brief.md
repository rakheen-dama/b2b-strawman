# Implementation Brief: Epic 67D — BillingRate + CostRate Controllers & Integration Tests

## Scope
Backend

## Tasks

### Task 67.15 — Create BillingRateController with DTOs
`billingrate/BillingRateController.java` — `@RestController`, `@RequestMapping("/api/billing-rates")`. Inner DTOs: `CreateBillingRateRequest(UUID memberId, UUID projectId, UUID customerId, @NotBlank @Size(min=3,max=3) String currency, @NotNull @Positive BigDecimal hourlyRate, @NotNull LocalDate effectiveFrom, LocalDate effectiveTo)`, `UpdateBillingRateRequest(...)`, `BillingRateResponse(UUID id, UUID memberId, String memberName, UUID projectId, String projectName, UUID customerId, String customerName, String scope, String currency, BigDecimal hourlyRate, LocalDate effectiveFrom, LocalDate effectiveTo, Instant createdAt, Instant updatedAt)`, `ResolvedRateResponse(BigDecimal hourlyRate, String currency, String source, UUID billingRateId)`. 5 endpoints per architecture Section 11.4.2: `GET /` (list with filters), `POST /` (201), `PUT /{id}` (200), `DELETE /{id}` (204), `GET /resolve` (memberId, projectId, date params). Member name enrichment via MemberRepository. Pattern: follow `task/TaskController.java`.

**API Details:**

**GET /api/billing-rates** — Query params: `memberId` (optional UUID), `projectId` (optional UUID), `customerId` (optional UUID), `activeOnly` (optional boolean, default false). Response: `200 OK` with `{"content": [...]}` wrapping a list of `BillingRateResponse`.

Permission rules:
- Admin/Owner: see all rates.
- Project Lead: can call with `projectId` filter to see project overrides for projects they lead.
- Regular Member: can call with `memberId` filter set to their own ID to see their own rates.

**POST /api/billing-rates** — Request body: `CreateBillingRateRequest`. `memberId` required. `projectId` optional (project override). `customerId` optional (customer override). `projectId` and `customerId` cannot both be non-null (400). `currency` required, 3-char ISO 4217. `hourlyRate` required, positive BigDecimal. `effectiveFrom` required LocalDate. `effectiveTo` optional LocalDate, must be >= effectiveFrom if set. Validates no overlapping date ranges. Returns `409 Conflict` if overlap found. Response: `201 Created` with created billing rate object.

**PUT /api/billing-rates/{id}** — Request: `UpdateBillingRateRequest` with `hourlyRate`, `currency`, `effectiveFrom`, `effectiveTo`. `memberId`, `projectId`, `customerId` are immutable after creation. Response: `200 OK` with updated object.

**DELETE /api/billing-rates/{id}** — Response: `204 No Content`.

**GET /api/billing-rates/resolve** — Query params: `memberId` (required UUID), `projectId` (required UUID), `date` (required LocalDate ISO 8601). Response: `200 OK` with `ResolvedRateResponse`. Returns null values if no rate resolved. Permission: any member can resolve their own rate, admin/owner can resolve any member's rate.

### Task 67.16 — Create CostRateController with DTOs
`costrate/CostRateController.java` — `@RestController`, `@RequestMapping("/api/cost-rates")`. Inner DTOs: `CreateCostRateRequest(UUID memberId, @NotBlank @Size(min=3,max=3) String currency, @NotNull @Positive BigDecimal hourlyCost, @NotNull LocalDate effectiveFrom, LocalDate effectiveTo)`, `UpdateCostRateRequest(...)`, `CostRateResponse(UUID id, UUID memberId, String memberName, String currency, BigDecimal hourlyCost, LocalDate effectiveFrom, LocalDate effectiveTo, Instant createdAt, Instant updatedAt)`. 4 endpoints per architecture Section 11.4.3: `GET /` (filter by memberId), `POST /` (201), `PUT /{id}` (200), `DELETE /{id}` (204). All admin/owner only.

**API Details:**

**GET /api/cost-rates** — Query params: `memberId` (optional UUID). Response: `200 OK` with `{"content": [...]}`.

**POST /api/cost-rates** — Request body: `CreateCostRateRequest`. Validates no overlapping date ranges. Returns `409 Conflict` if overlap. Response: `201 Created`.

**PUT /api/cost-rates/{id}** — Request: `UpdateCostRateRequest` with `hourlyCost`, `currency`, `effectiveFrom`, `effectiveTo`. Response: `200 OK`.

**DELETE /api/cost-rates/{id}** — Response: `204 No Content`.

### Task 67.17 — Add SecurityConfig updates for rate endpoints
Modify `security/SecurityConfig.java` — verify `/api/billing-rates/**`, `/api/cost-rates/**`, `/api/settings/**` are covered by authenticated endpoint patterns. **FINDING: Already covered** by `.requestMatchers("/api/**").authenticated()` pattern in SecurityConfig (line 92). No changes needed.

### Task 67.18 — Add BillingRateController MockMvc tests
`billingrate/BillingRateControllerTest.java` (~8 MockMvc tests): POST creates rate 201, GET lists rates 200, GET with filters, PUT updates 200, DELETE 204, POST with invalid data 400, POST overlap returns 409, GET /resolve returns rate. Test permission: admin JWT creates rate (success), member JWT creates member-default rate (rejected). Pattern: follow `settings/OrgSettingsIntegrationTest.java`.

### Task 67.19 — Add CostRateController MockMvc tests
`costrate/CostRateControllerTest.java` (~5 MockMvc tests): POST creates 201, GET lists 200, PUT updates 200, DELETE 204, member JWT rejected 403. Pattern: follow BillingRateControllerTest from 67.18.

### Task 67.20 — Add rate tenant isolation tests
~3 tests within existing test files or separate: billing rate in tenant A invisible in tenant B, cost rate in tenant A invisible in tenant B, shared-schema @Filter isolation verification. Pattern: follow `audit/AuditTenantIsolationTest.java`.

### Task 67.21 — Verify OrgSettings integration with rate creation defaults
~2 tests: create billing rate without explicit currency — service falls back to OrgSettings defaultCurrency. Create cost rate after updating org default currency — verify new rate uses updated default. This validates the cross-service integration between OrgSettingsService and rate creation flows.

## File Plan

### Create
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRateController.java` — REST controller with 5 endpoints and DTOs
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/costrate/CostRateController.java` — REST controller with 4 endpoints and DTOs
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRateControllerTest.java` — Integration tests for billing rate controller (~8 tests)
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/costrate/CostRateControllerTest.java` — Integration tests for cost rate controller (~5 tests)

### Modify
- **No files need modification**. SecurityConfig already covers `/api/**` with authenticated pattern (line 92). The BillingRateService and CostRateService from 67B/67C are called as-is — no changes needed.

## Reference Patterns

### Controller Pattern (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/settings/OrgSettingsController.java`)
```java
package io.b2mash.b2b.b2bstrawman.settings;

import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.util.UUID;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/settings")
public class OrgSettingsController {

  private final OrgSettingsService orgSettingsService;

  public OrgSettingsController(OrgSettingsService orgSettingsService) {
    this.orgSettingsService = orgSettingsService;
  }

  @GetMapping
  @PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<SettingsResponse> getSettings() {
    var settings = orgSettingsService.getSettings();
    return ResponseEntity.ok(new SettingsResponse(settings.defaultCurrency()));
  }

  @PutMapping
  @PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<SettingsResponse> updateSettings(
      @Valid @RequestBody UpdateSettingsRequest request) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var settings = orgSettingsService.updateSettings(request.defaultCurrency(), memberId, orgRole);
    return ResponseEntity.ok(new SettingsResponse(settings.defaultCurrency()));
  }

  // --- DTOs ---

  public record SettingsResponse(String defaultCurrency) {}

  public record UpdateSettingsRequest(
      @NotBlank(message = "defaultCurrency is required")
          @Size(min = 3, max = 3, message = "defaultCurrency must be exactly 3 characters")
          String defaultCurrency) {}
}
```

### Controller with Member Name Enrichment (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/comment/CommentController.java`)
```java
package io.b2mash.b2b.b2bstrawman.comment;

import io.b2mash.b2b.b2bstrawman.member.Member;
import io.b2mash.b2b.b2bstrawman.member.MemberRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.net.URI;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/projects/{projectId}/comments")
public class CommentController {

  private final CommentService commentService;
  private final MemberRepository memberRepository;

  public CommentController(CommentService commentService, MemberRepository memberRepository) {
    this.commentService = commentService;
    this.memberRepository = memberRepository;
  }

  @PostMapping
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<CommentResponse> createComment(
      @PathVariable UUID projectId, @Valid @RequestBody CreateCommentRequest request) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var comment =
        commentService.createComment(
            projectId,
            request.entityType(),
            request.entityId(),
            request.body(),
            request.visibility(),
            memberId,
            orgRole);

    var authors = resolveAuthors(List.of(comment));
    return ResponseEntity.created(
            URI.create("/api/projects/" + projectId + "/comments/" + comment.getId()))
        .body(CommentResponse.from(comment, authors));
  }

  @DeleteMapping("/{commentId}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<Void> deleteComment(
      @PathVariable UUID projectId, @PathVariable UUID commentId) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    commentService.deleteComment(projectId, commentId, memberId, orgRole);
    return ResponseEntity.noContent().build();
  }

  private Map<UUID, AuthorInfo> resolveAuthors(List<Comment> comments) {
    var ids =
        comments.stream()
            .map(Comment::getAuthorMemberId)
            .filter(Objects::nonNull)
            .distinct()
            .toList();

    if (ids.isEmpty()) {
      return Map.of();
    }

    return memberRepository.findAllById(ids).stream()
        .collect(
            Collectors.toMap(
                Member::getId, m -> new AuthorInfo(m.getName(), m.getAvatarUrl()), (a, b) -> a));
  }

  // --- DTOs ---

  record AuthorInfo(String name, String avatarUrl) {}

  public record CommentResponse(
      UUID id,
      String entityType,
      UUID entityId,
      UUID projectId,
      UUID authorMemberId,
      String authorName,
      String authorAvatarUrl,
      String body,
      String visibility,
      UUID parentId,
      Instant createdAt,
      Instant updatedAt) {

    public static CommentResponse from(Comment comment, Map<UUID, AuthorInfo> authors) {
      var author = authors.get(comment.getAuthorMemberId());
      return new CommentResponse(
          comment.getId(),
          comment.getEntityType(),
          comment.getEntityId(),
          comment.getProjectId(),
          comment.getAuthorMemberId(),
          author != null ? author.name() : null,
          author != null ? author.avatarUrl() : null,
          comment.getBody(),
          comment.getVisibility(),
          comment.getParentId(),
          comment.getCreatedAt(),
          comment.getUpdatedAt());
    }
  }
}
```

### BillingRate Entity (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRate.java`)
```java
package io.b2mash.b2b.b2bstrawman.billingrate;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "billing_rates")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class BillingRate implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "member_id", nullable = false)
  private UUID memberId;

  @Column(name = "project_id")
  private UUID projectId;

  @Column(name = "customer_id")
  private UUID customerId;

  @Column(name = "currency", nullable = false, length = 3)
  private String currency;

  @Column(name = "hourly_rate", nullable = false, precision = 12, scale = 2)
  private BigDecimal hourlyRate;

  @Column(name = "effective_from", nullable = false)
  private LocalDate effectiveFrom;

  @Column(name = "effective_to")
  private LocalDate effectiveTo;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected BillingRate() {}

  public BillingRate(
      UUID memberId,
      UUID projectId,
      UUID customerId,
      String currency,
      BigDecimal hourlyRate,
      LocalDate effectiveFrom,
      LocalDate effectiveTo) {
    this.memberId = memberId;
    this.projectId = projectId;
    this.customerId = customerId;
    this.currency = currency;
    this.hourlyRate = hourlyRate;
    this.effectiveFrom = effectiveFrom;
    this.effectiveTo = effectiveTo;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void update(
      BigDecimal hourlyRate, String currency, LocalDate effectiveFrom, LocalDate effectiveTo) {
    this.hourlyRate = hourlyRate;
    this.currency = currency;
    this.effectiveFrom = effectiveFrom;
    this.effectiveTo = effectiveTo;
    this.updatedAt = Instant.now();
  }

  public String getScope() {
    if (projectId != null) {
      return "PROJECT_OVERRIDE";
    }
    if (customerId != null) {
      return "CUSTOMER_OVERRIDE";
    }
    return "MEMBER_DEFAULT";
  }

  // All getters: getId(), getMemberId(), getProjectId(), getCustomerId(),
  // getCurrency(), getHourlyRate(), getEffectiveFrom(), getEffectiveTo(),
  // getCreatedAt(), getUpdatedAt(), getTenantId(), setTenantId(String)
}
```

### BillingRateService (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRateService.java`)
```java
package io.b2mash.b2b.b2bstrawman.billingrate;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.customer.CustomerProjectRepository;
import io.b2mash.b2b.b2bstrawman.customer.CustomerRepository;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceConflictException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.member.ProjectAccessService;
import io.b2mash.b2b.b2bstrawman.project.ProjectRepository;
import io.b2mash.b2b.b2bstrawman.security.Roles;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class BillingRateService {

  private static final Logger log = LoggerFactory.getLogger(BillingRateService.class);
  private static final LocalDate FAR_FUTURE = LocalDate.of(9999, 12, 31);

  private final BillingRateRepository billingRateRepository;
  private final CustomerProjectRepository customerProjectRepository;
  private final CustomerRepository customerRepository;
  private final ProjectRepository projectRepository;
  private final ProjectAccessService projectAccessService;
  private final AuditService auditService;

  public BillingRateService(
      BillingRateRepository billingRateRepository,
      CustomerProjectRepository customerProjectRepository,
      CustomerRepository customerRepository,
      ProjectRepository projectRepository,
      ProjectAccessService projectAccessService,
      AuditService auditService) {
    this.billingRateRepository = billingRateRepository;
    this.customerProjectRepository = customerProjectRepository;
    this.customerRepository = customerRepository;
    this.projectRepository = projectRepository;
    this.projectAccessService = projectAccessService;
    this.auditService = auditService;
  }

  public record ResolvedRate(
      BigDecimal hourlyRate, String currency, String source, UUID billingRateId) {}

  @Transactional(readOnly = true)
  public Optional<ResolvedRate> resolveRate(UUID memberId, UUID projectId, LocalDate date) {
    // 1. Try project override
    var projectRates = billingRateRepository.findProjectOverride(memberId, projectId, date);
    if (!projectRates.isEmpty()) {
      var rate = projectRates.getFirst();
      return Optional.of(
          new ResolvedRate(
              rate.getHourlyRate(), rate.getCurrency(), "PROJECT_OVERRIDE", rate.getId()));
    }

    // 2. Try customer override via CustomerProject join
    var customerId = customerProjectRepository.findFirstCustomerByProjectId(projectId);
    if (customerId.isPresent()) {
      var customerRates =
          billingRateRepository.findCustomerOverride(memberId, customerId.get(), date);
      if (!customerRates.isEmpty()) {
        var rate = customerRates.getFirst();
        return Optional.of(
            new ResolvedRate(
                rate.getHourlyRate(), rate.getCurrency(), "CUSTOMER_OVERRIDE", rate.getId()));
      }
    }

    // 3. Try member default
    var defaultRates = billingRateRepository.findMemberDefault(memberId, date);
    if (!defaultRates.isEmpty()) {
      var rate = defaultRates.getFirst();
      return Optional.of(
          new ResolvedRate(
              rate.getHourlyRate(), rate.getCurrency(), "MEMBER_DEFAULT", rate.getId()));
    }

    return Optional.empty();
  }

  @Transactional
  public BillingRate createRate(
      UUID memberId, UUID projectId, UUID customerId,
      String currency, BigDecimal hourlyRate,
      LocalDate effectiveFrom, LocalDate effectiveTo,
      UUID actorMemberId, String orgRole) {
    // validates scope, project/customer existence, permissions, overlap
    // returns saved BillingRate
  }

  @Transactional
  public BillingRate updateRate(
      UUID id, BigDecimal hourlyRate, String currency,
      LocalDate effectiveFrom, LocalDate effectiveTo,
      UUID actorMemberId, String orgRole) {
    // finds rate, validates permissions, checks overlap excluding self, saves
    // returns updated BillingRate
  }

  @Transactional
  public void deleteRate(UUID id, UUID actorMemberId, String orgRole) {
    // finds rate, validates permissions, deletes, audit logs
  }

  @Transactional(readOnly = true)
  public List<BillingRate> listRates(UUID memberId, UUID projectId, UUID customerId) {
    return billingRateRepository.findByFilters(memberId, projectId, customerId);
  }

  // Private helpers: validateScope(), requirePermission(), validateProjectExists(), validateCustomerExists()
}
```

### CostRateService (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/costrate/CostRateService.java`)
```java
package io.b2mash.b2b.b2bstrawman.costrate;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceConflictException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.security.Roles;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CostRateService {

  private static final Logger log = LoggerFactory.getLogger(CostRateService.class);
  private static final LocalDate FAR_FUTURE = LocalDate.of(9999, 12, 31);

  private final CostRateRepository costRateRepository;
  private final AuditService auditService;

  public record ResolvedCostRate(BigDecimal hourlyCost, String currency, UUID costRateId) {}

  public CostRateService(CostRateRepository costRateRepository, AuditService auditService) {
    this.costRateRepository = costRateRepository;
    this.auditService = auditService;
  }

  @Transactional(readOnly = true)
  public Optional<ResolvedCostRate> resolveCostRate(UUID memberId, LocalDate date) {
    // single-level lookup, no hierarchy
  }

  @Transactional
  public CostRate createCostRate(
      UUID memberId, String currency, BigDecimal hourlyCost,
      LocalDate effectiveFrom, LocalDate effectiveTo,
      UUID actorMemberId, String orgRole) {
    // requireAdminOrOwner, overlap check, save, audit
  }

  @Transactional
  public CostRate updateCostRate(
      UUID id, BigDecimal hourlyCost, String currency,
      LocalDate effectiveFrom, LocalDate effectiveTo,
      UUID actorMemberId, String orgRole) {
    // requireAdminOrOwner, find, overlap check excluding self, save, audit
  }

  @Transactional
  public void deleteCostRate(UUID id, UUID actorMemberId, String orgRole) {
    // requireAdminOrOwner, find, delete, audit
  }

  @Transactional(readOnly = true)
  public List<CostRate> listCostRates(UUID memberId) {
    return costRateRepository.findByMemberId(memberId);
  }

  private void requireAdminOrOwner(String orgRole) {
    if (Roles.ORG_ADMIN.equals(orgRole) || Roles.ORG_OWNER.equals(orgRole)) {
      return;
    }
    throw new ForbiddenException(
        "Insufficient permissions", "Only admins and owners can manage cost rates");
  }
}
```

### Integration Test Pattern (from `backend/src/test/java/io/b2mash/b2b/b2bstrawman/settings/OrgSettingsIntegrationTest.java`)
```java
package io.b2mash.b2b.b2bstrawman.settings;

import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.JwtRequestPostProcessor;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OrgSettingsIntegrationTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_settings_test";

  @Autowired private MockMvc mockMvc;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;

  private String memberIdOwner;
  private String memberIdAdmin;
  private String memberIdMember;

  @BeforeAll
  void provisionTenant() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "OrgSettings Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    memberIdOwner =
        syncMember(ORG_ID, "user_settings_owner", "settings_owner@test.com", "Owner", "owner");
    memberIdAdmin =
        syncMember(ORG_ID, "user_settings_admin", "settings_admin@test.com", "Admin", "admin");
    memberIdMember =
        syncMember(ORG_ID, "user_settings_member", "settings_member@test.com", "Member", "member");
  }

  @Test
  @Order(1)
  void getSettings_returnsDefaultWhenNoSettingsExist() throws Exception {
    mockMvc
        .perform(get("/api/settings").with(ownerJwt()))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.defaultCurrency").value("USD"));
  }

  @Test
  @Order(2)
  void putSettings_createsSettings() throws Exception {
    mockMvc
        .perform(
            put("/api/settings")
                .with(ownerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {"defaultCurrency": "EUR"}
                    """))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.defaultCurrency").value("EUR"));
  }

  @Test
  void putSettings_memberGetsForbidden() throws Exception {
    mockMvc
        .perform(
            put("/api/settings")
                .with(memberJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {"defaultCurrency": "CAD"}
                    """))
        .andExpect(status().isForbidden());
  }

  // --- Helpers ---

  private String syncMember(
      String orgId, String clerkUserId, String email, String name, String orgRole)
      throws Exception {
    var result =
        mockMvc
            .perform(
                org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post(
                        "/internal/members/sync")
                    .header("X-API-KEY", API_KEY)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {
                          "clerkOrgId": "%s",
                          "clerkUserId": "%s",
                          "email": "%s",
                          "name": "%s",
                          "avatarUrl": null,
                          "orgRole": "%s"
                        }
                        """
                            .formatted(orgId, clerkUserId, email, name, orgRole)))
            .andExpect(status().isCreated())
            .andReturn();

    return JsonPath.read(result.getResponse().getContentAsString(), "$.memberId");
  }

  private JwtRequestPostProcessor ownerJwt() {
    return jwt()
        .jwt(j -> j.subject("user_settings_owner").claim("o", Map.of("id", ORG_ID, "rol", "owner")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
  }

  private JwtRequestPostProcessor adminJwt() {
    return jwt()
        .jwt(j -> j.subject("user_settings_admin").claim("o", Map.of("id", ORG_ID, "rol", "admin")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_ADMIN")));
  }

  private JwtRequestPostProcessor memberJwt() {
    return jwt()
        .jwt(
            j ->
                j.subject("user_settings_member").claim("o", Map.of("id", ORG_ID, "rol", "member")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_MEMBER")));
  }
}
```

### CommentControllerTest — Full Integration Test Pattern (from `backend/src/test/java/io/b2mash/b2b/b2bstrawman/comment/CommentControllerTest.java`)
```java
package io.b2mash.b2b.b2bstrawman.comment;

import static org.hamcrest.Matchers.hasSize;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.JwtRequestPostProcessor;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class CommentControllerTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_comment_ctrl_test";

  @Autowired private MockMvc mockMvc;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;

  private String projectId;
  private String taskId;
  private String memberIdOwner;
  private String memberIdAdmin;
  private String memberIdMember;
  private String memberIdMember2;

  @BeforeAll
  void provisionAndSeed() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "Comment Ctrl Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    memberIdOwner = syncMember(ORG_ID, "user_cc_owner", "cc_owner@test.com", "CC Owner", "owner");
    memberIdAdmin = syncMember(ORG_ID, "user_cc_admin", "cc_admin@test.com", "CC Admin", "admin");
    memberIdMember =
        syncMember(ORG_ID, "user_cc_member", "cc_member@test.com", "CC Member", "member");
    memberIdMember2 =
        syncMember(ORG_ID, "user_cc_member2", "cc_member2@test.com", "CC Member2", "member");

    var projectResult =
        mockMvc
            .perform(
                post("/api/projects")
                    .with(ownerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("""
                        {"name": "Comment Ctrl Test Project", "description": "For comment ctrl tests"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    projectId = extractIdFromLocation(projectResult);

    // Add all members to the project
    for (String mid : List.of(memberIdAdmin, memberIdMember, memberIdMember2)) {
      mockMvc
          .perform(
              post("/api/projects/" + projectId + "/members")
                  .with(ownerJwt())
                  .contentType(MediaType.APPLICATION_JSON)
                  .content("{\"memberId\": \"%s\"}".formatted(mid)))
          .andExpect(status().isCreated());
    }

    var taskResult =
        mockMvc
            .perform(
                post("/api/projects/" + projectId + "/tasks")
                    .with(ownerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("""
                        {"title": "Comment Ctrl Test Task", "priority": "MEDIUM"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    taskId = extractIdFromLocation(taskResult);
  }

  @Test
  void postCreatesCommentAndReturns201WithCorrectShape() throws Exception {
    mockMvc
        .perform(
            post("/api/projects/" + projectId + "/comments")
                .with(memberJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                      "entityType": "TASK",
                      "entityId": "%s",
                      "body": "Controller test comment"
                    }
                    """.formatted(taskId)))
        .andExpect(status().isCreated())
        .andExpect(jsonPath("$.id").exists())
        .andExpect(jsonPath("$.entityType").value("TASK"))
        .andExpect(jsonPath("$.authorName").value("CC Member"))
        .andExpect(jsonPath("$.body").value("Controller test comment"));
  }

  @Test
  void deleteByAuthorReturns204() throws Exception {
    var commentId = createComment(memberJwt(), "Comment to delete by author");
    mockMvc
        .perform(delete("/api/projects/" + projectId + "/comments/" + commentId).with(memberJwt()))
        .andExpect(status().isNoContent());
  }

  // --- Helpers (syncMember, extractIdFromLocation, JWT helpers) ---
  // Same pattern as OrgSettingsIntegrationTest above
}
```

### RequestScopes (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/RequestScopes.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import io.b2mash.b2b.b2bstrawman.exception.MissingOrganizationContextException;
import java.util.UUID;

public final class RequestScopes {

  public static final ScopedValue<String> TENANT_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> MEMBER_ID = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ROLE = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> CUSTOMER_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> PORTAL_CONTACT_ID = ScopedValue.newInstance();

  public static final String DEFAULT_TENANT = "public";

  public static UUID requireMemberId() {
    if (!MEMBER_ID.isBound()) {
      throw new MemberContextNotBoundException();
    }
    return MEMBER_ID.get();
  }

  public static String requireOrgId() {
    if (!ORG_ID.isBound()) {
      throw new MissingOrganizationContextException();
    }
    return ORG_ID.get();
  }

  public static String getOrgRole() {
    return ORG_ROLE.isBound() ? ORG_ROLE.get() : null;
  }

  private RequestScopes() {}
}
```

### Roles (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/security/Roles.java`)
```java
package io.b2mash.b2b.b2bstrawman.security;

public final class Roles {
  public static final String ORG_OWNER = "owner";
  public static final String ORG_ADMIN = "admin";
  public static final String ORG_MEMBER = "member";

  public static final String PROJECT_LEAD = "lead";
  public static final String PROJECT_MEMBER = "member";

  public static final String AUTHORITY_ORG_OWNER = "ROLE_ORG_OWNER";
  public static final String AUTHORITY_ORG_ADMIN = "ROLE_ORG_ADMIN";
  public static final String AUTHORITY_ORG_MEMBER = "ROLE_ORG_MEMBER";
  public static final String AUTHORITY_INTERNAL = "ROLE_INTERNAL_SERVICE";

  private Roles() {}
}
```

### MemberRepository (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/member/MemberRepository.java`)
```java
package io.b2mash.b2b.b2bstrawman.member;

import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface MemberRepository extends JpaRepository<Member, UUID> {

  @Query("SELECT m FROM Member m WHERE m.id = :id")
  Optional<Member> findOneById(@Param("id") UUID id);

  Optional<Member> findByClerkUserId(String clerkUserId);

  void deleteByClerkUserId(String clerkUserId);

  boolean existsByClerkUserId(String clerkUserId);
}
```

## Conventions

### Naming
- Base package: `io.b2mash.b2b.b2bstrawman`
- Entities: domain name (e.g., `Project`, `Document`) -- no `Entity` suffix
- Repositories: `*Repository` extending `JpaRepository`
- Services: `*Service`
- Controllers: `*Controller`
- DTOs: nested records inside the controller or in a `dto` sub-package if shared

### Code Style
- Use Java records for DTOs, request/response objects, and value objects
- Prefer constructor injection (no `@Autowired` on fields)
- Use `@PreAuthorize` annotations for role-based access control
- Return `ResponseEntity` from controllers for explicit status codes
- Use Spring's `ProblemDetail` (RFC 9457) for error responses
- No Lombok -- Java 25 records and pattern matching cover most use cases

### Anti-Patterns -- NEVER Do This (VERBATIM from backend/CLAUDE.md)

- Never use `@Autowired` on fields -- use constructor injection
- Never use Lombok -- Java 25 records and pattern matching cover all cases
- Never trust client headers for tenant resolution -- always derive from validated JWT
- Never use `org.springframework.boot.orm.jpa.HibernatePropertiesCustomizer` -- it moved to `boot.hibernate.autoconfigure` in Spring Boot 4
- Never set `hibernate.multiTenancy` property -- Hibernate 7 auto-detects from registered provider
- Never use `java -jar` for the Docker entry point -- use `org.springframework.boot.loader.launch.JarLauncher`
- Never make `TestcontainersConfiguration` package-private -- it must be `public` for `@Import` from subpackages
- Never use `@ActiveProfiles("local")` in tests -- use `@ActiveProfiles("test")`. The "local" profile connects to Docker Compose Postgres. Tests must run against ephemeral Testcontainers only.
- Never use flat JWT claims (`org_id`, `org_role`) -- Clerk JWT v2 nests org claims under `"o"`: `jwt.getClaim("o")` returns `Map<String, Object>` with keys `id`, `rol`, `slg`
- Never use `ThreadLocal` for request-scoped context -- use `ScopedValue` via `RequestScopes` (guaranteed cleanup, virtual thread safe)
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first or accepting `NoSuchElementException`
- Never build `ProblemDetail` directly in controllers or services -- throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" -- throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers -- use `RequestScopes.requireMemberId()` and the shared exception classes

### Exception Pattern
Services throw semantic exceptions from the `exception/` package -- Spring auto-renders them as RFC 9457 ProblemDetail responses. Controllers should be pure delegation with no error mapping.

| Exception | HTTP Status | When to use |
|-----------|-------------|-------------|
| `ResourceNotFoundException` | 404 | Resource not found or access denied (security-by-obscurity) |
| `ResourceConflictException` | 409 | Duplicate or state conflict |
| `ForbiddenException` | 403 | Authenticated but insufficient permissions |
| `InvalidStateException` | 400 | Invalid state transition or bad request |
| `MissingOrganizationContextException` | 401 | JWT missing org claim |

### Spring Boot 4 Specifics
- `AutoConfigureMockMvc` import: `org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc` (NOT `boot.test.autoconfigure.web.servlet`)
- Spring Security Test `jwt()` mock does NOT invoke `ClerkJwtAuthenticationConverter` -- must set `.authorities()` explicitly on the mock
- Use `RequestScopes.requireMemberId()` and `RequestScopes.getOrgRole()` in controllers

## Integration Points

### Classes the new code calls

**BillingRateController** calls:
- `BillingRateService.createRate(UUID memberId, UUID projectId, UUID customerId, String currency, BigDecimal hourlyRate, LocalDate effectiveFrom, LocalDate effectiveTo, UUID actorMemberId, String orgRole)` -- returns `BillingRate`
- `BillingRateService.updateRate(UUID id, BigDecimal hourlyRate, String currency, LocalDate effectiveFrom, LocalDate effectiveTo, UUID actorMemberId, String orgRole)` -- returns `BillingRate`
- `BillingRateService.deleteRate(UUID id, UUID actorMemberId, String orgRole)` -- void
- `BillingRateService.listRates(UUID memberId, UUID projectId, UUID customerId)` -- returns `List<BillingRate>`
- `BillingRateService.resolveRate(UUID memberId, UUID projectId, LocalDate date)` -- returns `Optional<ResolvedRate>`
- `MemberRepository.findOneById(UUID id)` -- returns `Optional<Member>` (for name enrichment)
- `MemberRepository.findAllById(Iterable<UUID> ids)` -- returns `List<Member>` (for batch name enrichment on list)
- `ProjectRepository.findOneById(UUID id)` -- returns `Optional<Project>` (for project name enrichment)
- `CustomerRepository.findOneById(UUID id)` -- returns `Optional<Customer>` (for customer name enrichment)
- `RequestScopes.requireMemberId()` -- returns `UUID`
- `RequestScopes.getOrgRole()` -- returns `String`

**CostRateController** calls:
- `CostRateService.createCostRate(UUID memberId, String currency, BigDecimal hourlyCost, LocalDate effectiveFrom, LocalDate effectiveTo, UUID actorMemberId, String orgRole)` -- returns `CostRate`
- `CostRateService.updateCostRate(UUID id, BigDecimal hourlyCost, String currency, LocalDate effectiveFrom, LocalDate effectiveTo, UUID actorMemberId, String orgRole)` -- returns `CostRate`
- `CostRateService.deleteCostRate(UUID id, UUID actorMemberId, String orgRole)` -- void
- `CostRateService.listCostRates(UUID memberId)` -- returns `List<CostRate>`
- `MemberRepository.findOneById(UUID id)` / `findAllById(...)` -- for name enrichment
- `RequestScopes.requireMemberId()`, `RequestScopes.getOrgRole()`

### Entity Field Access (for DTO mapping)
- `BillingRate`: `getId()`, `getMemberId()`, `getProjectId()`, `getCustomerId()`, `getCurrency()`, `getHourlyRate()`, `getEffectiveFrom()`, `getEffectiveTo()`, `getScope()`, `getCreatedAt()`, `getUpdatedAt()`
- `CostRate`: `getId()`, `getMemberId()`, `getCurrency()`, `getHourlyCost()`, `getEffectiveFrom()`, `getEffectiveTo()`, `getCreatedAt()`, `getUpdatedAt()`
- `Member`: `getId()`, `getName()`
- `Project`: `getId()`, `getName()`
- `Customer`: `getId()`, `getName()`
- `BillingRateService.ResolvedRate`: `hourlyRate()`, `currency()`, `source()`, `billingRateId()`

## Implementation Notes

### BillingRateController Design Decisions

1. **Permission model is in the service layer**: `BillingRateService.createRate()` already calls `requirePermission()` internally, which checks admin/owner and project lead roles. The controller uses `@PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")` to ensure the user is authenticated, but fine-grained permission (e.g., project leads can only manage project overrides) is enforced in the service.

2. **Name enrichment in controller**: The response DTOs include `memberName`, `projectName`, `customerName`. Look up these from `MemberRepository`, `ProjectRepository`, `CustomerRepository` in the controller (same pattern as `CommentController.resolveAuthors()`). Use `findAllById()` for batch queries on list responses, `findOneById()` for single responses.

3. **Response wrapping**: List endpoints return `{"content": [...]}` format per the architecture doc API spec. Use a simple wrapper record: `record ListResponse<T>(List<T> content) {}`.

4. **Resolve endpoint returns 200 with null values** (not 404) when no rate is found. This matches the architecture spec.

5. **POST returns 201 with Location header** per existing controller patterns (see CommentController).

### CostRateController Design Decisions

1. **All endpoints admin/owner only**: Use `@PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")` on all endpoints. The service also enforces this (`requireAdminOrOwner()`), so there's defense in depth.

2. **Simpler than BillingRateController**: No projectId/customerId fields, no resolve endpoint, no project lead permissions.

### Test Design Decisions

1. **Use UNIQUE ORG_IDs per test class**: e.g., `"org_billing_ctrl_test"`, `"org_cost_ctrl_test"`. This avoids cross-test interference.

2. **For task 67.20 (tenant isolation)**: Provision TWO tenants, create rates in tenant A, verify they're invisible via tenant B's JWT. Use different ORG_IDs.

3. **For task 67.21 (OrgSettings integration)**: Update OrgSettings currency, create a rate, verify the controller response currency matches. This is a controller-level test (not service-level), verifying end-to-end.

## Build & Verify

All commands run from: `cd /Users/rakheendama/Projects/2026/worktree-epic-67D/backend`

**Step 1: Format**
```bash
./mvnw spotless:apply 2>&1 | tail -3
```

**Step 2: Silent full build (Pass 1)**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-67D.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-67D.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-67D.log | head -20; fi; fi
```

**Step 3: Re-run ONLY failed tests with full output (only if Pass 1 failed with test failures)**
```bash
./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80
```

**Step 4: Silent re-verify after fixing (Pass 2)**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-67D.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-67D.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi
```

**IMPORTANT: NEVER run `./mvnw clean verify` without `-q` -- full output burns 30-60KB of context per run.**

## Environment
- Postgres host: b2mash.local:5432
- LocalStack host: b2mash.local:4566
- Maven wrapper: ./mvnw from backend dir
- Java 25 (required for ScopedValue)
- Spring Boot 4.0.2
- Hibernate 7
- `@ActiveProfiles("test")` in all tests (NEVER "local")
