# Implementation Brief: Epic 54A -- PortalContact Entity & Migration

## Scope
Backend only

## Tasks

### Task 54.1: Create V18 tenant migration for portal_contacts, magic_link_tokens, and tasks.customer_visible

**IMPORTANT**: The task spec says "V14" but V14 through V17 already exist. The next available tenant migration number is **V18**.

File: `backend/src/main/resources/db/migration/tenant/V18__create_portal_contacts_and_magic_link_tokens.sql`

Three parts:
1. `portal_contacts` table: `id` (UUID PK DEFAULT gen_random_uuid()), `org_id` (VARCHAR(255) NOT NULL), `customer_id` (UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE), `email` (VARCHAR(255) NOT NULL), `display_name` (VARCHAR(255)), `role` (VARCHAR(20) NOT NULL DEFAULT 'GENERAL'), `status` (VARCHAR(20) NOT NULL DEFAULT 'ACTIVE'), `tenant_id` (VARCHAR(255)), `created_at` (TIMESTAMPTZ NOT NULL DEFAULT now()), `updated_at` (TIMESTAMPTZ NOT NULL DEFAULT now()). UNIQUE(email, customer_id). Indexes: `idx_portal_contacts_email_org`, `idx_portal_contacts_customer`, `idx_portal_contacts_tenant`. RLS policy.
2. `magic_link_tokens` table: `id` (UUID PK DEFAULT gen_random_uuid()), `portal_contact_id` (UUID NOT NULL REFERENCES portal_contacts(id) ON DELETE CASCADE), `token_hash` (VARCHAR(64) NOT NULL), `expires_at` (TIMESTAMP NOT NULL), `used_at` (TIMESTAMP), `created_at` (TIMESTAMPTZ NOT NULL DEFAULT now()), `created_ip` (VARCHAR(45)). UNIQUE(token_hash). Indexes: `idx_magic_link_tokens_contact_created`, `idx_magic_link_tokens_expires`. No `tenant_id` column on tokens -- cross-tenant lookup by hash.
3. `ALTER TABLE tasks ADD COLUMN customer_visible BOOLEAN NOT NULL DEFAULT false`.

**Acceptance**: Migration runs cleanly on tenant schemas. Tables, indexes, constraints, and RLS policy all created. Idempotent (`IF NOT EXISTS`).

### Task 54.2: Create PortalContact entity

File: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContact.java`

JPA entity mapped to `portal_contacts`. Fields: UUID id, orgId (String, NOT NULL), customerId (UUID, NOT NULL), email (String, NOT NULL), displayName (String, nullable), role (enum ContactRole: PRIMARY/BILLING/GENERAL), status (enum ContactStatus: ACTIVE/SUSPENDED/ARCHIVED), tenantId (String), createdAt (Instant), updatedAt (Instant). Annotations: `@FilterDef`/`@Filter` for `tenantFilter`, `@EntityListeners(TenantAwareEntityListener.class)`, implements `TenantAware`. Inner enums: `ContactRole`, `ContactStatus`.

**Acceptance**: Entity persists correctly. Tenant filter works in shared schema. `TenantAwareEntityListener` sets `tenant_id` on persist.

### Task 54.3: Create PortalContactRepository

File: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactRepository.java`

Extends `JpaRepository<PortalContact, UUID>`. Methods:
- `Optional<PortalContact> findOneById(UUID id)` -- JPQL `@Query` for `@Filter` compatibility (CRITICAL: do NOT use `findById()`)
- `Optional<PortalContact> findByEmailAndOrgId(String email, String orgId)` -- JPQL
- `List<PortalContact> findByCustomerId(UUID customerId)` -- JPQL
- `boolean existsByEmailAndCustomerId(String email, UUID customerId)`

**Acceptance**: All methods respect Hibernate tenant filter. `findOneById` uses explicit JPQL.

### Task 54.4: Create PortalContactService

File: `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactService.java`

Constructor injection of `PortalContactRepository`, `CustomerRepository`. Methods:
- `createContact(String orgId, UUID customerId, String email, String displayName, PortalContact.ContactRole role)` -- validates customer exists via `customerRepository.findOneById()`, checks unique email+customer via `existsByEmailAndCustomerId()`, creates and saves PortalContact.
- `listContactsForCustomer(UUID customerId)` -- returns `findByCustomerId()`.
- `findByEmailAndOrg(String email, String orgId)` -- delegates to repo.
- `suspendContact(UUID contactId)` -- sets status=SUSPENDED.
- `archiveContact(UUID contactId)` -- sets status=ARCHIVED.

All `@Transactional`.

**Acceptance**: CRUD operations work. Duplicate email+customer returns 409. Non-existent customer returns 404. Status transitions work correctly.

### Task 54.5: Add PortalContact integration tests

File: `backend/src/test/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactIntegrationTest.java`

~10 tests:
1. Create contact (verify persisted correctly)
2. Create with duplicate email+customer (409)
3. Create with email that exists on a different customer (success -- email can appear across customers)
4. Find by email and org
5. List contacts for customer
6. Suspend contact (status changes)
7. Archive contact (status changes)
8. Tenant isolation (contact in tenant A invisible in tenant B)
9. Contact created_by customer not found (404)
10. Verify org_id is populated correctly

Seed: provision tenant, sync member, create customer in `@BeforeAll`.

**Acceptance**: All tests pass. Tenant isolation verified across two tenants.

### Task 54.6: Add PORTAL_CONTACT_ID to RequestScopes

File: Modify `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/RequestScopes.java`

Add `public static final ScopedValue<UUID> PORTAL_CONTACT_ID = ScopedValue.newInstance()` and `requirePortalContactId()` convenience method (throws `IllegalStateException` if not bound).

**Acceptance**: New ScopedValue is bindable and accessible. `requirePortalContactId()` throws when not bound.

## File Plan

### Create
- `backend/src/main/resources/db/migration/tenant/V18__create_portal_contacts_and_magic_link_tokens.sql` -- Tenant schema migration for portal_contacts, magic_link_tokens tables, and tasks.customer_visible column
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContact.java` -- JPA entity for portal contacts
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactRepository.java` -- Spring Data JPA repository with JPQL queries
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactService.java` -- Business logic service for portal contacts
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/portal/PortalContactIntegrationTest.java` -- Integration tests for PortalContact CRUD and tenant isolation

### Modify
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/RequestScopes.java` -- Add `PORTAL_CONTACT_ID` ScopedValue and `requirePortalContactId()` method

## Reference Patterns

### Entity Pattern (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/Customer.java`)
```java
package io.b2mash.b2b.b2bstrawman.customer;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "customers")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class Customer implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "name", nullable = false, length = 255)
  private String name;

  @Column(name = "email", nullable = false, length = 255)
  private String email;

  @Column(name = "phone", length = 50)
  private String phone;

  @Column(name = "id_number", length = 100)
  private String idNumber;

  @Column(name = "status", nullable = false, length = 20)
  private String status;

  @Column(name = "notes", columnDefinition = "TEXT")
  private String notes;

  @Column(name = "created_by", nullable = false)
  private UUID createdBy;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected Customer() {}

  public Customer(
      String name, String email, String phone, String idNumber, String notes, UUID createdBy) {
    this.name = name;
    this.email = email;
    this.phone = phone;
    this.idNumber = idNumber;
    this.status = "ACTIVE";
    this.notes = notes;
    this.createdBy = createdBy;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void update(String name, String email, String phone, String idNumber, String notes) {
    this.name = name;
    this.email = email;
    this.phone = phone;
    this.idNumber = idNumber;
    this.notes = notes;
    this.updatedAt = Instant.now();
  }

  public void archive() {
    this.status = "ARCHIVED";
    this.updatedAt = Instant.now();
  }

  public UUID getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public String getEmail() {
    return email;
  }

  public String getPhone() {
    return phone;
  }

  public String getIdNumber() {
    return idNumber;
  }

  public String getStatus() {
    return status;
  }

  public String getNotes() {
    return notes;
  }

  public UUID getCreatedBy() {
    return createdBy;
  }

  @Override
  public String getTenantId() {
    return tenantId;
  }

  @Override
  public void setTenantId(String tenantId) {
    this.tenantId = tenantId;
  }

  public Instant getCreatedAt() {
    return createdAt;
  }

  public Instant getUpdatedAt() {
    return updatedAt;
  }
}
```

### Repository Pattern (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/CustomerRepository.java`)
```java
package io.b2mash.b2b.b2bstrawman.customer;

import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface CustomerRepository extends JpaRepository<Customer, UUID> {

  /**
   * JPQL-based findById that respects Hibernate @Filter (unlike JpaRepository.findById which uses
   * EntityManager.find and bypasses @Filter). Required for shared-schema tenant isolation.
   */
  @Query("SELECT c FROM Customer c WHERE c.id = :id")
  Optional<Customer> findOneById(@Param("id") UUID id);

  Optional<Customer> findByEmail(String email);

  boolean existsByEmail(String email);
}
```

### Service Pattern (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/CustomerService.java`)
```java
package io.b2mash.b2b.b2bstrawman.customer;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.exception.ResourceConflictException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CustomerService {

  private static final Logger log = LoggerFactory.getLogger(CustomerService.class);

  private final CustomerRepository repository;
  private final AuditService auditService;

  public CustomerService(CustomerRepository repository, AuditService auditService) {
    this.repository = repository;
    this.auditService = auditService;
  }

  @Transactional(readOnly = true)
  public List<Customer> listCustomers() {
    return repository.findAll();
  }

  @Transactional(readOnly = true)
  public Customer getCustomer(UUID id) {
    return repository
        .findOneById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Customer", id));
  }

  @Transactional
  public Customer createCustomer(
      String name, String email, String phone, String idNumber, String notes, UUID createdBy) {
    if (repository.existsByEmail(email)) {
      throw new ResourceConflictException(
          "Customer email conflict", "A customer with email " + email + " already exists");
    }
    var customer = repository.save(new Customer(name, email, phone, idNumber, notes, createdBy));
    log.info("Created customer {} with email {}", customer.getId(), email);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("customer.created")
            .entityType("customer")
            .entityId(customer.getId())
            .details(Map.of("name", customer.getName(), "email", customer.getEmail()))
            .build());

    return customer;
  }

  @Transactional
  public Customer updateCustomer(
      UUID id, String name, String email, String phone, String idNumber, String notes) {
    var customer =
        repository.findOneById(id).orElseThrow(() -> new ResourceNotFoundException("Customer", id));

    // Check email uniqueness if changed
    if (!customer.getEmail().equals(email) && repository.existsByEmail(email)) {
      throw new ResourceConflictException(
          "Customer email conflict", "A customer with email " + email + " already exists");
    }

    // Capture old values before mutation
    String oldName = customer.getName();
    String oldEmail = customer.getEmail();
    String oldPhone = customer.getPhone();
    String oldIdNumber = customer.getIdNumber();
    String oldNotes = customer.getNotes();

    customer.update(name, email, phone, idNumber, notes);
    var saved = repository.save(customer);

    // Build delta map -- only include changed fields
    var details = new LinkedHashMap<String, Object>();
    if (!Objects.equals(oldName, name)) {
      details.put("name", Map.of("from", oldName, "to", name));
    }
    if (!Objects.equals(oldEmail, email)) {
      details.put("email", Map.of("from", oldEmail, "to", email));
    }
    if (!Objects.equals(oldPhone, phone)) {
      details.put("phone", Map.of("from", String.valueOf(oldPhone), "to", String.valueOf(phone)));
    }
    if (!Objects.equals(oldIdNumber, idNumber)) {
      details.put(
          "id_number", Map.of("from", String.valueOf(oldIdNumber), "to", String.valueOf(idNumber)));
    }
    if (!Objects.equals(oldNotes, notes)) {
      details.put("notes", Map.of("from", String.valueOf(oldNotes), "to", String.valueOf(notes)));
    }

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("customer.updated")
            .entityType("customer")
            .entityId(saved.getId())
            .details(details.isEmpty() ? null : details)
            .build());

    return saved;
  }

  @Transactional
  public Customer archiveCustomer(UUID id) {
    var customer =
        repository.findOneById(id).orElseThrow(() -> new ResourceNotFoundException("Customer", id));
    customer.archive();
    var saved = repository.save(customer);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("customer.archived")
            .entityType("customer")
            .entityId(saved.getId())
            .build());

    return saved;
  }
}
```

### Controller Pattern (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/CustomerController.java`)
```java
package io.b2mash.b2b.b2bstrawman.customer;

import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.project.Project;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.net.URI;
import java.time.Instant;
import java.util.List;
import java.util.UUID;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {

  private final CustomerService customerService;
  private final CustomerProjectService customerProjectService;

  public CustomerController(
      CustomerService customerService, CustomerProjectService customerProjectService) {
    this.customerService = customerService;
    this.customerProjectService = customerProjectService;
  }

  @GetMapping
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<List<CustomerResponse>> listCustomers() {
    var customers = customerService.listCustomers().stream().map(CustomerResponse::from).toList();
    return ResponseEntity.ok(customers);
  }

  @GetMapping("/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<CustomerResponse> getCustomer(@PathVariable UUID id) {
    var customer = customerService.getCustomer(id);
    return ResponseEntity.ok(CustomerResponse.from(customer));
  }

  @PostMapping
  @PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<CustomerResponse> createCustomer(
      @Valid @RequestBody CreateCustomerRequest request) {
    UUID createdBy = RequestScopes.requireMemberId();
    var customer =
        customerService.createCustomer(
            request.name(),
            request.email(),
            request.phone(),
            request.idNumber(),
            request.notes(),
            createdBy);
    return ResponseEntity.created(URI.create("/api/customers/" + customer.getId()))
        .body(CustomerResponse.from(customer));
  }

  @PutMapping("/{id}")
  @PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<CustomerResponse> updateCustomer(
      @PathVariable UUID id, @Valid @RequestBody UpdateCustomerRequest request) {
    var customer =
        customerService.updateCustomer(
            id,
            request.name(),
            request.email(),
            request.phone(),
            request.idNumber(),
            request.notes());
    return ResponseEntity.ok(CustomerResponse.from(customer));
  }

  @DeleteMapping("/{id}")
  @PreAuthorize("hasAnyRole('ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<CustomerResponse> archiveCustomer(@PathVariable UUID id) {
    var customer = customerService.archiveCustomer(id);
    return ResponseEntity.ok(CustomerResponse.from(customer));
  }

  // --- DTOs ---

  public record CreateCustomerRequest(
      @NotBlank(message = "name is required")
          @Size(max = 255, message = "name must be at most 255 characters")
          String name,
      @NotBlank(message = "email is required")
          @Email(message = "email must be a valid email address")
          @Size(max = 255, message = "email must be at most 255 characters")
          String email,
      @Size(max = 50, message = "phone must be at most 50 characters") String phone,
      @Size(max = 100, message = "idNumber must be at most 100 characters") String idNumber,
      String notes) {}

  public record UpdateCustomerRequest(
      @NotBlank(message = "name is required")
          @Size(max = 255, message = "name must be at most 255 characters")
          String name,
      @NotBlank(message = "email is required")
          @Email(message = "email must be a valid email address")
          @Size(max = 255, message = "email must be at most 255 characters")
          String email,
      @Size(max = 50, message = "phone must be at most 50 characters") String phone,
      @Size(max = 100, message = "idNumber must be at most 100 characters") String idNumber,
      String notes) {}

  public record CustomerResponse(
      UUID id,
      String name,
      String email,
      String phone,
      String idNumber,
      String status,
      String notes,
      UUID createdBy,
      Instant createdAt,
      Instant updatedAt) {

    public static CustomerResponse from(Customer customer) {
      return new CustomerResponse(
          customer.getId(),
          customer.getName(),
          customer.getEmail(),
          customer.getPhone(),
          customer.getIdNumber(),
          customer.getStatus(),
          customer.getNotes(),
          customer.getCreatedBy(),
          customer.getCreatedAt(),
          customer.getUpdatedAt());
    }
  }

  public record CustomerProjectResponse(
      UUID customerId, UUID projectId, UUID linkedBy, Instant createdAt) {

    public static CustomerProjectResponse from(CustomerProject link) {
      return new CustomerProjectResponse(
          link.getCustomerId(), link.getProjectId(), link.getLinkedBy(), link.getCreatedAt());
    }
  }

  public record LinkedProjectResponse(UUID id, String name, String description, Instant createdAt) {

    public static LinkedProjectResponse from(Project project) {
      return new LinkedProjectResponse(
          project.getId(), project.getName(), project.getDescription(), project.getCreatedAt());
    }
  }
}
```

### Integration Test Pattern (from `backend/src/test/java/io/b2mash/b2b/b2bstrawman/portal/PortalAuthIntegrationTest.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.customer.CustomerService;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PortalAuthIntegrationTest {

  private static final String ORG_ID = "org_portal_test";
  private static final String API_KEY = "test-api-key";

  @Autowired private MockMvc mockMvc;
  @Autowired private MagicLinkService magicLinkService;
  @Autowired private PortalJwtService portalJwtService;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;
  @Autowired private CustomerService customerService;
  @Autowired private OrgSchemaMappingRepository orgSchemaMappingRepository;

  private UUID customerId;

  @BeforeAll
  void setup() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "Portal Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    // Sync a member for creating customers
    var syncResult =
        mockMvc
            .perform(
                post("/internal/members/sync")
                    .header("X-API-KEY", API_KEY)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {
                          "clerkOrgId": "%s",
                          "clerkUserId": "user_portal_owner",
                          "email": "portal_owner@test.com",
                          "name": "Portal Owner",
                          "avatarUrl": null,
                          "orgRole": "owner"
                        }
                        """
                            .formatted(ORG_ID)))
            .andExpect(status().isCreated())
            .andReturn();

    String memberIdStr = JsonPath.read(syncResult.getResponse().getContentAsString(), "$.memberId");
    UUID memberId = UUID.fromString(memberIdStr);

    // Resolve tenant schema
    String tenantSchema = orgSchemaMappingRepository.findByClerkOrgId(ORG_ID).get().getSchemaName();

    // Create a customer in the tenant
    ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
        .where(RequestScopes.ORG_ID, ORG_ID)
        .run(
            () -> {
              var customer =
                  customerService.createCustomer(
                      "Portal Customer", "portal-customer@test.com", null, null, null, memberId);
              customerId = customer.getId();
            });
  }

  @Nested
  class MagicLinkTests {

    @Test
    void shouldGenerateAndVerifyMagicLinkToken() {
      String token = magicLinkService.generateToken(customerId, ORG_ID);
      assertThat(token).isNotBlank();

      var identity = magicLinkService.verifyToken(token);
      assertThat(identity.customerId()).isEqualTo(customerId);
      assertThat(identity.clerkOrgId()).isEqualTo(ORG_ID);
    }

    @Test
    void shouldRejectInvalidMagicLinkToken() {
      assertThatThrownBy(() -> magicLinkService.verifyToken("invalid.token.here"))
          .isInstanceOf(PortalAuthException.class);
    }

    @Test
    void shouldRejectReusedMagicLinkToken() {
      String token = magicLinkService.generateToken(customerId, ORG_ID);

      // First use succeeds
      var identity = magicLinkService.verifyToken(token);
      assertThat(identity.customerId()).isEqualTo(customerId);

      // Second use fails (single-use enforcement)
      assertThatThrownBy(() -> magicLinkService.verifyToken(token))
          .isInstanceOf(PortalAuthException.class)
          .hasMessageContaining("already been used");
    }

    @Test
    void shouldRejectTamperedToken() {
      String token = magicLinkService.generateToken(customerId, ORG_ID);
      // Tamper with the token by modifying the last few characters
      String tampered = token.substring(0, token.length() - 5) + "XXXXX";

      assertThatThrownBy(() -> magicLinkService.verifyToken(tampered))
          .isInstanceOf(PortalAuthException.class);
    }
  }

  // ... additional test classes for portal JWT and security filter chain
}
```

### Flyway Migration Pattern (from `backend/src/main/resources/db/migration/tenant/V9__create_customers.sql`)
```sql
-- V9: Create customers table
-- Epic 37A -- Customer entity for client-aware system

CREATE TABLE IF NOT EXISTS customers (
    id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name         VARCHAR(255) NOT NULL,
    email        VARCHAR(255) NOT NULL,
    phone        VARCHAR(50),
    id_number    VARCHAR(100),
    status       VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    notes        TEXT,
    created_by   UUID NOT NULL REFERENCES members(id),
    tenant_id    VARCHAR(255),
    created_at   TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at   TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Email uniqueness scoped to tenant (allows same email across orgs in shared schema)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'uq_customers_email_tenant') THEN
    ALTER TABLE customers ADD CONSTRAINT uq_customers_email_tenant UNIQUE (email, tenant_id);
  END IF;
END $$;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_customers_tenant_id
    ON customers (tenant_id);

CREATE INDEX IF NOT EXISTS idx_customers_tenant_id_status
    ON customers (tenant_id, status);

CREATE INDEX IF NOT EXISTS idx_customers_tenant_id_email
    ON customers (tenant_id, email);

CREATE INDEX IF NOT EXISTS idx_customers_created_by
    ON customers (created_by);

-- Row-Level Security
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'tenant_isolation_customers') THEN
    EXECUTE 'CREATE POLICY tenant_isolation_customers ON customers
      USING (tenant_id = current_setting(''app.current_tenant'', true) OR tenant_id IS NULL)';
  END IF;
END $$;
```

### TenantAware Interface (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/TenantAware.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

/**
 * Marker interface for entities that participate in shared-schema row-level isolation. Entities
 * implementing this interface have a {@code tenant_id} column that is populated by {@link
 * TenantAwareEntityListener} on persist when operating within the {@code tenant_shared} schema.
 */
public interface TenantAware {

  String getTenantId();

  void setTenantId(String tenantId);
}
```

### TenantAwareEntityListener (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/TenantAwareEntityListener.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import jakarta.persistence.PrePersist;

/**
 * JPA entity listener that sets {@code tenant_id} on new entities when operating in the shared
 * schema ({@code tenant_shared}). For dedicated schemas, this is a no-op -- tenant_id stays null.
 */
public class TenantAwareEntityListener {

  private static final String SHARED_SCHEMA = "tenant_shared";

  @PrePersist
  public void setTenantId(Object entity) {
    if (entity instanceof TenantAware tenantAware
        && RequestScopes.TENANT_ID.isBound()
        && SHARED_SCHEMA.equals(RequestScopes.TENANT_ID.get())
        && RequestScopes.ORG_ID.isBound()) {
      tenantAware.setTenantId(RequestScopes.ORG_ID.get());
    }
  }
}
```

### RequestScopes (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/RequestScopes.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import io.b2mash.b2b.b2bstrawman.exception.MissingOrganizationContextException;
import java.util.UUID;

public final class RequestScopes {

  /** Tenant schema name (e.g. "tenant_a1b2c3d4e5f6"). Bound by TenantFilter. */
  public static final ScopedValue<String> TENANT_ID = ScopedValue.newInstance();

  /** Current member's UUID within the tenant. Bound by MemberFilter. */
  public static final ScopedValue<UUID> MEMBER_ID = ScopedValue.newInstance();

  /** Current member's org role ("owner", "admin", "member"). Bound by MemberFilter. */
  public static final ScopedValue<String> ORG_ROLE = ScopedValue.newInstance();

  /** Clerk organization ID (e.g., "org_abc123"). Bound by TenantFilter. */
  public static final ScopedValue<String> ORG_ID = ScopedValue.newInstance();

  /** Authenticated customer's UUID. Bound by CustomerAuthFilter for portal requests. */
  public static final ScopedValue<UUID> CUSTOMER_ID = ScopedValue.newInstance();

  public static final String DEFAULT_TENANT = "public";

  /** Returns the current member's UUID. Throws if not bound by filter chain. */
  public static UUID requireMemberId() {
    if (!MEMBER_ID.isBound()) {
      throw new MemberContextNotBoundException();
    }
    return MEMBER_ID.get();
  }

  /** Returns the Clerk org ID. Throws if not bound by filter chain. */
  public static String requireOrgId() {
    if (!ORG_ID.isBound()) {
      throw new MissingOrganizationContextException();
    }
    return ORG_ID.get();
  }

  /** Returns the current member's org role, or null if not bound. */
  public static String getOrgRole() {
    return ORG_ROLE.isBound() ? ORG_ROLE.get() : null;
  }

  /** Returns the authenticated customer's UUID. Throws if not bound by CustomerAuthFilter. */
  public static UUID requireCustomerId() {
    if (!CUSTOMER_ID.isBound()) {
      throw new IllegalStateException("Customer context not available -- CUSTOMER_ID not bound");
    }
    return CUSTOMER_ID.get();
  }

  private RequestScopes() {}
}
```

### Exception Patterns (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/exception/`)

**ResourceNotFoundException**:
```java
package io.b2mash.b2b.b2bstrawman.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.ErrorResponseException;

public class ResourceNotFoundException extends ErrorResponseException {

  public ResourceNotFoundException(String resourceType, Object id) {
    super(
        HttpStatus.NOT_FOUND,
        createProblem(
            resourceType + " not found",
            "No " + resourceType.toLowerCase() + " found with id " + id),
        null);
  }

  public static ResourceNotFoundException withDetail(String title, String detail) {
    return new ResourceNotFoundException(title, detail, HttpStatus.NOT_FOUND);
  }

  private ResourceNotFoundException(String title, String detail, HttpStatus status) {
    super(status, createProblem(title, detail), null);
  }

  private static ProblemDetail createProblem(String title, String detail) {
    var problem = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
    problem.setTitle(title);
    problem.setDetail(detail);
    return problem;
  }
}
```

**ResourceConflictException**:
```java
package io.b2mash.b2b.b2bstrawman.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.ErrorResponseException;

public class ResourceConflictException extends ErrorResponseException {

  public ResourceConflictException(String title, String detail) {
    super(HttpStatus.CONFLICT, createProblem(title, detail), null);
  }

  private static ProblemDetail createProblem(String title, String detail) {
    var problem = ProblemDetail.forStatus(HttpStatus.CONFLICT);
    problem.setTitle(title);
    problem.setDetail(detail);
    return problem;
  }
}
```

**PortalAuthException**:
```java
package io.b2mash.b2b.b2bstrawman.portal;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.ErrorResponseException;

public class PortalAuthException extends ErrorResponseException {

  public PortalAuthException(String detail) {
    super(HttpStatus.UNAUTHORIZED, createProblem(detail), null);
  }

  private static ProblemDetail createProblem(String detail) {
    var problem = ProblemDetail.forStatus(HttpStatus.UNAUTHORIZED);
    problem.setTitle("Portal authentication failed");
    problem.setDetail(detail);
    return problem;
  }
}
```

### TestcontainersConfiguration (from `backend/src/test/java/io/b2mash/b2b/b2bstrawman/TestcontainersConfiguration.java`)
```java
package io.b2mash.b2b.b2bstrawman;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.context.annotation.Bean;
import org.springframework.test.context.DynamicPropertyRegistrar;
import org.testcontainers.postgresql.PostgreSQLContainer;
import org.testcontainers.utility.DockerImageName;

@TestConfiguration(proxyBeanMethods = false)
public class TestcontainersConfiguration {

  @SuppressWarnings("resource")
  @Bean
  @ServiceConnection
  PostgreSQLContainer postgresContainer() {
    return new PostgreSQLContainer(DockerImageName.parse("postgres:latest"));
  }

  @Bean
  DynamicPropertyRegistrar datasourceProperties(PostgreSQLContainer container) {
    return registry -> {
      registry.add("spring.datasource.app.jdbc-url", container::getJdbcUrl);
      registry.add("spring.datasource.app.username", container::getUsername);
      registry.add("spring.datasource.app.password", container::getPassword);
      registry.add("spring.datasource.migration.jdbc-url", container::getJdbcUrl);
      registry.add("spring.datasource.migration.username", container::getUsername);
      registry.add("spring.datasource.migration.password", container::getPassword);
    };
  }
}
```

### ScopedFilterChain (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/ScopedFilterChain.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

public final class ScopedFilterChain {

  private ScopedFilterChain() {}

  public static void runScoped(
      ScopedValue.Carrier carrier,
      FilterChain chain,
      HttpServletRequest request,
      HttpServletResponse response)
      throws ServletException, IOException {
    try {
      carrier.run(
          () -> {
            try {
              chain.doFilter(request, response);
            } catch (IOException e) {
              throw new WrappedIOException(e);
            } catch (ServletException e) {
              throw new WrappedServletException(e);
            }
          });
    } catch (WrappedIOException e) {
      throw e.wrapped;
    } catch (WrappedServletException e) {
      throw e.wrapped;
    }
  }

  static final class WrappedIOException extends RuntimeException {
    final IOException wrapped;

    WrappedIOException(IOException e) {
      super(e);
      this.wrapped = e;
    }
  }

  static final class WrappedServletException extends RuntimeException {
    final ServletException wrapped;

    WrappedServletException(ServletException e) {
      super(e);
      this.wrapped = e;
    }
  }
}
```

### Existing CustomerAuthFilter (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/CustomerAuthFilter.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.multitenancy.ScopedFilterChain;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantInfo;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class CustomerAuthFilter extends OncePerRequestFilter {

  private static final Logger log = LoggerFactory.getLogger(CustomerAuthFilter.class);
  private static final String BEARER_PREFIX = "Bearer ";

  private final PortalJwtService portalJwtService;
  private final OrgSchemaMappingRepository mappingRepository;

  public CustomerAuthFilter(
      PortalJwtService portalJwtService, OrgSchemaMappingRepository mappingRepository) {
    this.portalJwtService = portalJwtService;
    this.mappingRepository = mappingRepository;
  }

  @Override
  protected void doFilterInternal(
      HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {

    String authHeader = request.getHeader("Authorization");
    if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing or invalid Authorization");
      return;
    }

    String token = authHeader.substring(BEARER_PREFIX.length());
    PortalJwtService.PortalClaims claims;
    try {
      claims = portalJwtService.verifyToken(token);
    } catch (PortalAuthException e) {
      log.debug("Portal auth failed: {}", e.getMessage());
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
      return;
    }

    // Resolve tenant from org ID
    TenantInfo tenantInfo =
        mappingRepository.findTenantInfoByClerkOrgId(claims.clerkOrgId()).orElse(null);
    if (tenantInfo == null) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Organization not provisioned");
      return;
    }

    // Bind scoped values: CUSTOMER_ID, TENANT_ID, ORG_ID
    var carrier =
        ScopedValue.where(RequestScopes.CUSTOMER_ID, claims.customerId())
            .where(RequestScopes.TENANT_ID, tenantInfo.schemaName())
            .where(RequestScopes.ORG_ID, claims.clerkOrgId());

    ScopedFilterChain.runScoped(carrier, filterChain, request, response);
  }

  @Override
  protected boolean shouldNotFilter(HttpServletRequest request) {
    String path = request.getRequestURI();
    // Only filter authenticated portal paths, not the auth endpoints themselves
    if (!path.startsWith("/portal/")) {
      return true;
    }
    // Allow unauthenticated access to /portal/auth/** (magic link request/verify)
    return path.startsWith("/portal/auth/");
  }
}
```

### Existing MagicLinkService (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/MagicLinkService.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.time.Duration;
import java.time.Instant;
import java.util.Date;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MagicLinkService {

  private static final Logger log = LoggerFactory.getLogger(MagicLinkService.class);
  private static final Duration TOKEN_TTL = Duration.ofMinutes(15);

  private final byte[] secret;

  private final Cache<String, Boolean> consumedTokens =
      Caffeine.newBuilder().maximumSize(100_000).expireAfterWrite(Duration.ofMinutes(30)).build();

  public MagicLinkService(@Value("${portal.magic-link.secret}") String magicLinkSecret) {
    this.secret = magicLinkSecret.getBytes(StandardCharsets.UTF_8);
  }

  public record CustomerIdentity(UUID customerId, String clerkOrgId) {}

  public String generateToken(UUID customerId, String clerkOrgId) {
    try {
      Instant now = Instant.now();
      var claims =
          new JWTClaimsSet.Builder()
              .jwtID(UUID.randomUUID().toString())
              .subject(customerId.toString())
              .claim("org_id", clerkOrgId)
              .claim("type", "magic_link")
              .issueTime(Date.from(now))
              .expirationTime(Date.from(now.plus(TOKEN_TTL)))
              .build();

      var signedJwt = new SignedJWT(new JWSHeader(JWSAlgorithm.HS256), claims);
      JWSSigner signer = new MACSigner(secret);
      signedJwt.sign(signer);

      log.debug("Generated magic link token for customer {} in org {}", customerId, clerkOrgId);
      return signedJwt.serialize();
    } catch (JOSEException e) {
      throw new IllegalStateException("Failed to sign magic link token", e);
    }
  }

  public CustomerIdentity verifyToken(String token) {
    try {
      var signedJwt = SignedJWT.parse(token);
      JWSVerifier verifier = new MACVerifier(secret);

      if (!signedJwt.verify(verifier)) {
        throw new PortalAuthException("Invalid magic link token signature");
      }

      var claims = signedJwt.getJWTClaimsSet();

      if (claims.getExpirationTime() == null
          || claims.getExpirationTime().toInstant().isBefore(Instant.now())) {
        throw new PortalAuthException("Magic link has expired");
      }

      String type = claims.getStringClaim("type");
      if (!"magic_link".equals(type)) {
        throw new PortalAuthException("Invalid token type");
      }

      String jti = claims.getJWTID();
      if (jti == null) {
        throw new PortalAuthException("Token missing JTI");
      }
      Boolean prev = consumedTokens.asMap().putIfAbsent(jti, Boolean.TRUE);
      if (prev != null) {
        throw new PortalAuthException("Magic link has already been used");
      }

      UUID customerId = UUID.fromString(claims.getSubject());
      String orgId = claims.getStringClaim("org_id");

      log.debug("Verified magic link token for customer {} in org {}", customerId, orgId);
      return new CustomerIdentity(customerId, orgId);
    } catch (ParseException | JOSEException e) {
      throw new PortalAuthException("Invalid magic link token: " + e.getMessage());
    }
  }
}
```

### Existing PortalAuthController (from `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalAuthController.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.customer.CustomerRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/portal/auth")
public class PortalAuthController {

  private static final Logger log = LoggerFactory.getLogger(PortalAuthController.class);

  private final MagicLinkService magicLinkService;
  private final PortalJwtService portalJwtService;
  private final CustomerRepository customerRepository;
  private final OrgSchemaMappingRepository orgSchemaMappingRepository;

  public PortalAuthController(
      MagicLinkService magicLinkService,
      PortalJwtService portalJwtService,
      CustomerRepository customerRepository,
      OrgSchemaMappingRepository orgSchemaMappingRepository) {
    this.magicLinkService = magicLinkService;
    this.portalJwtService = portalJwtService;
    this.customerRepository = customerRepository;
    this.orgSchemaMappingRepository = orgSchemaMappingRepository;
  }

  @PostMapping("/request-link")
  public ResponseEntity<MagicLinkResponse> requestMagicLink(
      @Valid @RequestBody MagicLinkRequest request) {
    var mapping =
        orgSchemaMappingRepository
            .findByClerkOrgId(request.orgId())
            .orElseThrow(() -> new PortalAuthException("Organization not found"));

    String tenantSchema = mapping.getSchemaName();

    UUID customerId =
        ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
            .call(
                () ->
                    customerRepository
                        .findByEmail(request.email())
                        .orElseThrow(
                            () ->
                                new PortalAuthException("No customer account found for this email"))
                        .getId());

    String token = magicLinkService.generateToken(customerId, request.orgId());

    log.info("Generated magic link for customer {} in org {}", customerId, request.orgId());
    return ResponseEntity.ok(new MagicLinkResponse(token));
  }

  @PostMapping("/exchange")
  public ResponseEntity<PortalTokenResponse> exchangeToken(
      @Valid @RequestBody ExchangeRequest request) {
    var identity = magicLinkService.verifyToken(request.token());

    var mapping =
        orgSchemaMappingRepository
            .findByClerkOrgId(identity.clerkOrgId())
            .orElseThrow(() -> new PortalAuthException("Organization not found"));

    ScopedValue.where(RequestScopes.TENANT_ID, mapping.getSchemaName())
        .run(
            () ->
                customerRepository
                    .findOneById(identity.customerId())
                    .orElseThrow(
                        () -> new PortalAuthException("Customer account no longer exists")));

    String portalToken = portalJwtService.issueToken(identity.customerId(), identity.clerkOrgId());

    log.info(
        "Exchanged magic link for portal JWT -- customer {} in org {}",
        identity.customerId(),
        identity.clerkOrgId());
    return ResponseEntity.ok(new PortalTokenResponse(portalToken, identity.customerId()));
  }

  // --- DTOs ---

  public record MagicLinkRequest(
      @NotBlank(message = "email is required") @Email(message = "invalid email format")
          String email,
      @NotBlank(message = "orgId is required") String orgId) {}

  public record MagicLinkResponse(String token) {}

  public record ExchangeRequest(@NotBlank(message = "token is required") String token) {}

  public record PortalTokenResponse(String token, UUID customerId) {}
}
```

## Conventions

### Naming
- Base package: `io.b2mash.b2b.b2bstrawman`
- Entities: domain name (e.g., `Project`, `Customer`, `PortalContact`) -- no `Entity` suffix
- Repositories: `*Repository` extending `JpaRepository`
- Services: `*Service`
- Controllers: `*Controller`
- Filters: `*Filter`
- DTOs: nested records inside the controller or in a `dto` sub-package if shared

### Code Style
- Use Java records for DTOs, request/response objects, and value objects
- Prefer constructor injection (no `@Autowired` on fields)
- Use `@PreAuthorize` annotations for role-based access control
- Return `ResponseEntity` from controllers for explicit status codes
- Use Spring's `ProblemDetail` (RFC 9457) for error responses
- No Lombok -- Java 25 records and pattern matching cover most use cases

### Anti-Patterns -- NEVER Do This (VERBATIM from backend/CLAUDE.md)

- Never use `@Autowired` on fields -- use constructor injection
- Never use Lombok -- Java 25 records and pattern matching cover all cases
- Never trust client headers for tenant resolution -- always derive from validated JWT
- Never use `org.springframework.boot.orm.jpa.HibernatePropertiesCustomizer` -- it moved to `boot.hibernate.autoconfigure` in Spring Boot 4
- Never set `hibernate.multiTenancy` property -- Hibernate 7 auto-detects from registered provider
- Never use `java -jar` for the Docker entry point -- use `org.springframework.boot.loader.launch.JarLauncher`
- Never make `TestcontainersConfiguration` package-private -- it must be `public` for `@Import` from subpackages
- Never use `@ActiveProfiles("local")` in tests -- use `@ActiveProfiles("test")`. The "local" profile connects to Docker Compose Postgres. Tests must run against ephemeral Testcontainers only.
- Never use flat JWT claims (`org_id`, `org_role`) -- Clerk JWT v2 nests org claims under `"o"`: `jwt.getClaim("o")` returns `Map<String, Object>` with keys `id`, `rol`, `slg`
- Never use `ThreadLocal` for request-scoped context -- use `ScopedValue` via `RequestScopes` (guaranteed cleanup, virtual thread safe)
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first or accepting `NoSuchElementException`
- Never build `ProblemDetail` directly in controllers or services -- throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" -- throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers -- use `RequestScopes.requireMemberId()` and the shared exception classes

### Exception Pattern
Services throw semantic exceptions from the `exception/` package -- Spring auto-renders them as RFC 9457 ProblemDetail responses. Controllers should be pure delegation with no error mapping.

| Exception | HTTP Status | When to use |
|-----------|-------------|-------------|
| `ResourceNotFoundException` | 404 | Resource not found **or** access denied (security-by-obscurity) |
| `ResourceConflictException` | 409 | Duplicate or state conflict |
| `ForbiddenException` | 403 | Authenticated but insufficient permissions |
| `InvalidStateException` | 400 | Invalid state transition or bad request |
| `MissingOrganizationContextException` | 401 | JWT missing org claim |
| `PortalAuthException` | 401 | Portal authentication failure |

### Critical Gotchas
- **`findById()` bypasses Hibernate `@Filter`**: Always use JPQL-based `findOneById()` for entities with `@Filter`. `JpaRepository.findById()` uses `EntityManager.find()` which skips `@Filter`.
- **`@ActiveProfiles("test")`**: Always use `"test"` in tests. Never `"local"`.
- **`AutoConfigureMockMvc`**: Import from `org.springframework.boot.webmvc.test.autoconfigure` (NOT `boot.test.autoconfigure.web.servlet` -- that's Spring Boot 3).
- **Plan enforcement**: Add `planSyncService.syncPlan(ORG_ID, "pro-plan")` after `provisionTenant()` in `@BeforeAll` for test orgs that need more members.
- **OSIV disabled**: `spring.jpa.open-in-view: false` globally. Don't rely on lazy loading outside transactions.

## Integration Points

### Existing Services/Repos Used by PortalContactService
- `CustomerRepository.findOneById(UUID id)` -- validate customer exists before creating contact
- `CustomerRepository` -- located at `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/CustomerRepository.java`

### Used by Integration Test Setup
- `TenantProvisioningService.provisionTenant(String orgId, String orgName)` -- located at `backend/src/main/java/io/b2mash/b2b/b2bstrawman/provisioning/TenantProvisioningService.java`
- `PlanSyncService.syncPlan(String orgId, String planId)` -- located at `backend/src/main/java/io/b2mash/b2b/b2bstrawman/provisioning/PlanSyncService.java`
- `CustomerService.createCustomer(...)` -- located at `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customer/CustomerService.java`
- `OrgSchemaMappingRepository.findByClerkOrgId(String orgId)` -- located at `backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/OrgSchemaMappingRepository.java`

### Files This Epic's Work Will Be Used By (Epic 54B, future)
- `MagicLinkService` will be refactored in 54B to use `PortalContactRepository` and `MagicLinkTokenRepository` (DB-backed tokens)
- `PortalAuthController` will be updated in 54B to use `PortalContactService` for email resolution
- `CustomerAuthFilter` will be updated in 54B to bind `PORTAL_CONTACT_ID`

## Migration Notes

### Version Number
The task spec says V14, but V14 (`V14__create_audit_events.sql`) through V17 (`V17__create_notification_preferences.sql`) already exist. Use **V18**.

File: `V18__create_portal_contacts_and_magic_link_tokens.sql`

### Table Structure
Follow the architecture doc Section 13.8.1 exactly for column definitions. Key differences from the V9 customers migration pattern:
- `portal_contacts` has `org_id VARCHAR(255) NOT NULL` -- denormalized for cross-schema lookups
- `portal_contacts` uses `REFERENCES customers(id) ON DELETE CASCADE` -- not `members(id)`
- `magic_link_tokens` has NO `tenant_id` column -- tokens are looked up by hash cross-tenant
- `magic_link_tokens` does NOT get RLS policy -- no tenant_id column means no tenant scoping needed at DB level
- `portal_contacts` RLS policy uses `current_setting('app.current_tenant', true)` -- same as other tenant tables
- The `ALTER TABLE tasks ADD COLUMN customer_visible BOOLEAN NOT NULL DEFAULT false` is at the end

### Idempotency
Use `CREATE TABLE IF NOT EXISTS`, `CREATE INDEX IF NOT EXISTS`, and `DO $$ ... IF NOT EXISTS ...` guards for constraints and policies. Follow the V9 pattern exactly.

## Build & Verify

All commands run from: `cd /Users/rakheendama/Projects/2026/worktree-epic-54A/backend`

**Step 1: Format**
```bash
./mvnw spotless:apply 2>&1 | tail -3
```

**Step 2: Silent full build (Pass 1)**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-54A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-54A.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-54A.log | head -20; fi; fi
```

**Step 3: Re-run ONLY failed tests with full output (only if Pass 1 failed with test failures)**
```bash
./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80
```

**Step 4: Silent re-verify after fixing (Pass 2)**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-54A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-54A.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi
```

**IMPORTANT: NEVER run `./mvnw clean verify` without `-q` -- full output burns 30-60KB of context per run.**

## Environment
- Postgres host: b2mash.local:5432
- LocalStack host: b2mash.local:4566
- Maven wrapper: ./mvnw from backend dir
- Java version: 25
- Spring Boot: 4.0.2
- Hibernate: 7
- Test profile: `@ActiveProfiles("test")` (NEVER `"local"`)
