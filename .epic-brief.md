# Implementation Brief: Epic 75B — DashboardService & Project Health Endpoints

## Scope
Backend

## Tasks

1. **Task 75.6 — Add TaskRepository query methods for dashboard**
   Modify `task/TaskRepository.java`. Add JPQL methods:
   - `countByProjectId(UUID projectId)` — `SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId`
   - `countByProjectIdAndStatus(UUID projectId, String status)` — `SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId AND t.status = :status`
   - `countOverdueByProjectId(UUID projectId, LocalDate today)` — `SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId AND t.status <> 'DONE' AND t.dueDate < :today`
   - `countOrgOverdue(LocalDate today)` — `SELECT COUNT(t) FROM Task t WHERE t.status <> 'DONE' AND t.dueDate < :today`
   JPQL queries benefit from Hibernate `@Filter` for tenant isolation.
   **Acceptance**: All 4 methods compile and are callable from DashboardService. Integration test verifies correct counts.

2. **Task 75.7 — Add AuditEventRepository method for days since last activity**
   Modify `audit/AuditEventRepository.java`. Add native SQL query:
   `findMostRecentByProject(UUID projectId)` — `SELECT MAX(ae.occurred_at) FROM audit_events ae WHERE (ae.details->>'project_id')::uuid = :projectId`. Returns `Optional<Instant>`. RLS handles tenant isolation.
   **Acceptance**: Method returns correct most-recent timestamp for a project. Returns empty Optional for project with no events.

3. **Task 75.8 — Create dashboard DTO records**
   - `dashboard/dto/ProjectHealthDetail.java` — record with `HealthStatus healthStatus, List<String> healthReasons, ProjectHealthMetrics metrics`
   - `dashboard/dto/ProjectHealthMetrics.java` — record with `int tasksDone, int tasksInProgress, int tasksTodo, int tasksOverdue, int totalTasks, double completionPercent, Double budgetConsumedPercent, double hoursThisPeriod, int daysSinceLastActivity`
   - `dashboard/dto/TaskSummary.java` — record with `int todo, int inProgress, int inReview, int done, int total, int overdueCount`
   **Acceptance**: All 3 records compile, have correct field types, serialize to JSON correctly.

4. **Task 75.9 — Create DashboardService (project methods)**
   `dashboard/DashboardService.java`. `@Service`. Inject: `TaskRepository`, `TimeEntryRepository`, `AuditEventRepository`, `ProjectBudgetRepository`.
   Caffeine project-level cache field: `Cache<String, Object>` with 5,000 max entries, 1-min TTL.
   Methods:
   - `getProjectHealth(UUID projectId, String tenantId)` — gathers task counts, budget data (via `ProjectBudgetRepository.findByProjectId()` + `TimeEntryRepository.budgetHoursConsumed()`), last activity; builds `ProjectHealthInput`; calls `ProjectHealthCalculator.calculate()`; assembles `ProjectHealthDetail`.
   - `getTaskSummary(UUID projectId, String tenantId)` — conditional COUNT query returning `TaskSummary`.
   Both use `getIfPresent() + put()` cache pattern per ADR-044.
   **Acceptance**: Both methods return correct data, use cache. Cache hit returns same result without DB query. Service is properly injected.

5. **Task 75.10 — Create DashboardController (project endpoints)**
   `dashboard/DashboardController.java`. `@RestController`.
   - `GET /api/projects/{projectId}/health` — calls `ProjectAccessService.requireViewAccess()`, then `dashboardService.getProjectHealth()`. Returns `ProjectHealthDetail`.
   - `GET /api/projects/{projectId}/task-summary` — same access check, returns `TaskSummary`.
   Extract tenantId from `RequestScopes.TENANT_ID`, memberId from `RequestScopes.MEMBER_ID`.
   **Acceptance**: Both endpoints return 200 with correct JSON. 404 for non-member. 401 without auth.

6. **Task 75.11 — Add DashboardController integration tests (project endpoints)**
   `dashboard/DashboardProjectIntegrationTest.java` (~8 tests):
   (1) health returns HEALTHY for project with all tasks done
   (2) health returns AT_RISK with overdue tasks
   (3) health returns UNKNOWN for project with no tasks
   (4) health includes reasons array
   (5) task summary returns correct counts by status
   (6) task summary includes overdue count
   (7) non-member cannot access project health (404)
   (8) admin can access any project health
   Seed: provision tenant, sync 2 members (admin + member), create project, create tasks with various statuses, add project member.
   **Acceptance**: All 8 tests pass. Tests use MockMvc with JWT mocks. Full tenant provisioning in @BeforeAll.

7. **Task 75.12 — Verify Caffeine dependency in pom.xml**
   Caffeine is already present in `backend/pom.xml` (confirmed — `com.github.ben-manes.caffeine:caffeine`). No action needed.
   **Acceptance**: Verified, no change required.

## File Plan

### Create
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/DashboardService.java` — Service with project health + task summary methods, Caffeine cache
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/DashboardController.java` — REST controller for project-scoped dashboard endpoints
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/dto/ProjectHealthDetail.java` — Response DTO for project health endpoint
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/dto/ProjectHealthMetrics.java` — Metrics sub-record within ProjectHealthDetail
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/dto/TaskSummary.java` — Response DTO for task summary endpoint
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/dashboard/DashboardProjectIntegrationTest.java` — Integration tests with MockMvc

### Modify
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/task/TaskRepository.java` — Add 4 count query methods
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/audit/AuditEventRepository.java` — Add `findMostRecentByProject()` native query

## Reference Patterns

### HealthStatus enum (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/HealthStatus.java)
```java
package io.b2mash.b2b.b2bstrawman.dashboard;

/** Health status for a project, ordered by severity for escalation comparisons. */
public enum HealthStatus {
  UNKNOWN,
  HEALTHY,
  AT_RISK,
  CRITICAL;

  /**
   * Returns a severity score for escalation comparisons. Higher values indicate worse health.
   *
   * @return severity score: UNKNOWN=0, HEALTHY=1, AT_RISK=2, CRITICAL=3
   */
  public int severity() {
    return switch (this) {
      case UNKNOWN -> 0;
      case HEALTHY -> 1;
      case AT_RISK -> 2;
      case CRITICAL -> 3;
    };
  }
}
```

### ProjectHealthInput record (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/ProjectHealthInput.java)
```java
package io.b2mash.b2b.b2bstrawman.dashboard;

/**
 * Input data for the project health calculator.
 *
 * @param totalTasks total number of tasks in the project
 * @param doneTasks number of tasks with status DONE
 * @param overdueTasks number of non-DONE tasks past their due date
 * @param budgetConsumedPercent percentage of budget consumed, null if no budget configured
 * @param alertThresholdPct budget alert threshold from ProjectBudget, default 80
 * @param completionPercent derived: doneTasks / totalTasks * 100
 * @param daysSinceLastActivity days since the most recent AuditEvent for this project
 */
public record ProjectHealthInput(
    int totalTasks,
    int doneTasks,
    int overdueTasks,
    Double budgetConsumedPercent,
    int alertThresholdPct,
    double completionPercent,
    int daysSinceLastActivity) {}
```

### ProjectHealthResult record (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/ProjectHealthResult.java)
```java
package io.b2mash.b2b.b2bstrawman.dashboard;

import java.util.List;

/**
 * Result of the project health calculation.
 *
 * @param status the overall health status (worst across all fired rules)
 * @param reasons human-readable list of reasons explaining the status
 */
public record ProjectHealthResult(HealthStatus status, List<String> reasons) {}
```

### ProjectHealthCalculator (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/dashboard/ProjectHealthCalculator.java)
```java
package io.b2mash.b2b.b2bstrawman.dashboard;

import java.util.ArrayList;
import java.util.List;

/**
 * Deterministic rule-based project health scoring calculator.
 *
 * <p>Evaluates six rules against project metrics and returns the worst (highest severity) status
 * along with all triggered reasons. Pure utility class with no Spring dependencies.
 *
 * <p>Rules:
 *
 * <ol>
 *   <li>Budget overrun (>= 100%) -> CRITICAL
 *   <li>Budget at risk (>= alert threshold, low completion) -> AT_RISK
 *   <li>High overdue ratio (> 30%) -> CRITICAL
 *   <li>Moderate overdue ratio (> 10%) -> AT_RISK
 *   <li>Stale project (> 14 days inactive) -> AT_RISK
 *   <li>No tasks -> UNKNOWN (terminal, overrides everything)
 * </ol>
 */
public final class ProjectHealthCalculator {

  static final double OVERDUE_CRITICAL_THRESHOLD = 0.3;
  static final double OVERDUE_AT_RISK_THRESHOLD = 0.1;
  static final int INACTIVITY_DAYS_THRESHOLD = 14;
  static final int DEFAULT_BUDGET_ALERT_THRESHOLD = 80;

  private ProjectHealthCalculator() {}

  /**
   * Calculates the health status and reasons for a project.
   *
   * @param input the project health metrics
   * @return the computed health result with status and reasons
   */
  public static ProjectHealthResult calculate(ProjectHealthInput input) {
    HealthStatus status = HealthStatus.HEALTHY;
    List<String> reasons = new ArrayList<>();

    // Rule 1: Budget overrun (CRITICAL)
    if (input.budgetConsumedPercent() != null && input.budgetConsumedPercent() >= 100) {
      status = escalate(status, HealthStatus.CRITICAL);
      reasons.add("Over budget");
    }

    // Rule 2: Budget at risk — high consumption with low task completion
    if (input.budgetConsumedPercent() != null
        && input.budgetConsumedPercent() >= input.alertThresholdPct()
        && input.completionPercent() < input.budgetConsumedPercent() - 10) {
      status = escalate(status, HealthStatus.AT_RISK);
      reasons.add(
          "Budget %d%% consumed but only %d%% of tasks complete"
              .formatted(
                  Math.round(input.budgetConsumedPercent()),
                  Math.round(input.completionPercent())));
    }

    // Rule 3: High overdue ratio (CRITICAL)
    if (input.totalTasks() > 0) {
      double overdueRatio = (double) input.overdueTasks() / input.totalTasks();
      if (overdueRatio > OVERDUE_CRITICAL_THRESHOLD) {
        status = escalate(status, HealthStatus.CRITICAL);
        reasons.add("%d of %d tasks overdue".formatted(input.overdueTasks(), input.totalTasks()));
      }
      // Rule 4: Moderate overdue ratio (AT_RISK) — mutually exclusive with Rule 3
      else if (overdueRatio > OVERDUE_AT_RISK_THRESHOLD) {
        status = escalate(status, HealthStatus.AT_RISK);
        reasons.add("%d overdue tasks".formatted(input.overdueTasks()));
      }
    }

    // Rule 5: Stale project (AT_RISK)
    if (input.totalTasks() > 0 && input.daysSinceLastActivity() > INACTIVITY_DAYS_THRESHOLD) {
      status = escalate(status, HealthStatus.AT_RISK);
      reasons.add("No activity in %d days".formatted(input.daysSinceLastActivity()));
    }

    // Rule 6: No tasks (UNKNOWN) — terminal, overrides everything
    if (input.totalTasks() == 0) {
      status = HealthStatus.UNKNOWN;
      reasons = List.of("No tasks created yet");
    }

    return new ProjectHealthResult(status, List.copyOf(reasons));
  }

  /**
   * Returns the status with higher severity. Used to escalate from current status when a rule
   * fires.
   */
  private static HealthStatus escalate(HealthStatus current, HealthStatus candidate) {
    return current.severity() >= candidate.severity() ? current : candidate;
  }
}
```

### TaskRepository — existing (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/task/TaskRepository.java)
```java
package io.b2mash.b2b.b2bstrawman.task;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface TaskRepository extends JpaRepository<Task, UUID> {

  /**
   * JPQL-based findById that respects Hibernate @Filter (unlike JpaRepository.findById which uses
   * EntityManager.find and bypasses @Filter). Required for shared-schema tenant isolation.
   */
  @Query("SELECT t FROM Task t WHERE t.id = :id")
  Optional<Task> findOneById(@Param("id") UUID id);

  @Query("SELECT t FROM Task t WHERE t.projectId = :projectId ORDER BY t.createdAt DESC")
  List<Task> findByProjectId(@Param("projectId") UUID projectId);

  @Query(
      """
      SELECT t FROM Task t WHERE t.projectId = :projectId
        AND (:status IS NULL OR t.status = :status)
        AND (:assigneeId IS NULL OR t.assigneeId = :assigneeId)
        AND (:priority IS NULL OR t.priority = :priority)
      ORDER BY t.createdAt DESC
      """)
  List<Task> findByProjectIdWithFilters(
      @Param("projectId") UUID projectId,
      @Param("status") String status,
      @Param("assigneeId") UUID assigneeId,
      @Param("priority") String priority);

  @Query(
      """
      SELECT t FROM Task t WHERE t.projectId = :projectId
        AND t.assigneeId IS NULL
        AND (:status IS NULL OR t.status = :status)
        AND (:priority IS NULL OR t.priority = :priority)
      ORDER BY t.createdAt DESC
      """)
  List<Task> findByProjectIdUnassigned(
      @Param("projectId") UUID projectId,
      @Param("status") String status,
      @Param("priority") String priority);

  // --- Cross-project queries for My Work (Epic 48A) ---

  @Query(
      """
      SELECT t FROM Task t
      WHERE t.assigneeId = :memberId
        AND t.status IN ('OPEN', 'IN_PROGRESS')
      ORDER BY t.dueDate ASC NULLS LAST, t.createdAt DESC
      """)
  List<Task> findAssignedToMember(@Param("memberId") UUID memberId);

  @Query(
      """
      SELECT t FROM Task t
      WHERE t.assigneeId IS NULL
        AND t.status = 'OPEN'
        AND t.projectId IN (
          SELECT pm.projectId FROM ProjectMember pm WHERE pm.memberId = :memberId
        )
      ORDER BY t.createdAt DESC
      """)
  List<Task> findUnassignedInMemberProjects(@Param("memberId") UUID memberId);
}
```

### AuditEventRepository — existing (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/audit/AuditEventRepository.java)
```java
package io.b2mash.b2b.b2bstrawman.audit;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface AuditEventRepository extends JpaRepository<AuditEvent, UUID> {

  /** Typed projection for event-type count aggregation. */
  interface EventTypeCount {
    String getEventType();

    long getCount();
  }

  @Query("SELECT e FROM AuditEvent e WHERE e.id = :id")
  Optional<AuditEvent> findOneById(@Param("id") UUID id);

  @Query(
      """
      SELECT e FROM AuditEvent e
      WHERE (:entityType IS NULL OR e.entityType = :entityType)
        AND (:entityId IS NULL OR e.entityId = :entityId)
        AND (:actorId IS NULL OR e.actorId = :actorId)
        AND (CAST(:eventTypePrefix AS string) IS NULL OR e.eventType LIKE CONCAT(CAST(:eventTypePrefix AS string), '%'))
        AND (CAST(:from AS timestamp) IS NULL OR e.occurredAt >= :from)
        AND (CAST(:to AS timestamp) IS NULL OR e.occurredAt < :to)
      ORDER BY e.occurredAt DESC
      """)
  Page<AuditEvent> findByFilter(
      @Param("entityType") String entityType,
      @Param("entityId") UUID entityId,
      @Param("actorId") UUID actorId,
      @Param("eventTypePrefix") String eventTypePrefix,
      @Param("from") Instant from,
      @Param("to") Instant to,
      Pageable pageable);

  @Query(
      value =
          """
          SELECT * FROM audit_events
          WHERE (details->>'project_id') = CAST(:projectId AS TEXT)
            AND (:entityType IS NULL OR entity_type = :entityType)
            AND (CAST(:since AS TIMESTAMPTZ) IS NULL OR occurred_at >= CAST(:since AS TIMESTAMPTZ))
          ORDER BY occurred_at DESC
          """,
      countQuery =
          """
          SELECT count(*) FROM audit_events
          WHERE (details->>'project_id') = CAST(:projectId AS TEXT)
            AND (:entityType IS NULL OR entity_type = :entityType)
            AND (CAST(:since AS TIMESTAMPTZ) IS NULL OR occurred_at >= CAST(:since AS TIMESTAMPTZ))
          """,
      nativeQuery = true)
  Page<AuditEvent> findByProjectId(
      @Param("projectId") String projectId,
      @Param("entityType") String entityType,
      @Param("since") Instant since,
      Pageable pageable);

  @Query(
      "SELECT e.eventType AS eventType, COUNT(e) AS count FROM AuditEvent e"
          + " GROUP BY e.eventType ORDER BY COUNT(e) DESC")
  List<EventTypeCount> countByEventType();
}
```

### ActivityController — project-scoped endpoint pattern (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/activity/ActivityController.java)
```java
package io.b2mash.b2b.b2bstrawman.activity;

import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import java.time.Instant;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/** REST controller for the project activity feed. */
@RestController
@RequestMapping("/api/projects/{projectId}/activity")
public class ActivityController {

  private final ActivityService activityService;

  public ActivityController(ActivityService activityService) {
    this.activityService = activityService;
  }

  @GetMapping
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<Page<ActivityItem>> getProjectActivity(
      @PathVariable UUID projectId,
      @RequestParam(defaultValue = "0") int page,
      @RequestParam(defaultValue = "20") int size,
      @RequestParam(required = false) String entityType,
      @RequestParam(required = false) Instant since) {

    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var pageable = PageRequest.of(page, Math.min(size, 50));
    var activity =
        activityService.getProjectActivity(
            projectId, entityType, since, pageable, memberId, orgRole);

    return ResponseEntity.ok(activity);
  }
}
```

### ReportController — GET endpoints with @PreAuthorize (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/report/ReportController.java)
```java
package io.b2mash.b2b.b2bstrawman.report;

import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ReportController {

  private final ReportService reportService;

  public ReportController(ReportService reportService) {
    this.reportService = reportService;
  }

  @GetMapping("/api/projects/{projectId}/profitability")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<ProjectProfitabilityResponse> getProjectProfitability(
      @PathVariable UUID projectId,
      @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate from,
      @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate to) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var response = reportService.getProjectProfitability(projectId, from, to, memberId, orgRole);
    return ResponseEntity.ok(response);
  }

  // ... (other endpoints follow same pattern)
}
```

### ProjectAccessService (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/member/ProjectAccessService.java)
```java
package io.b2mash.b2b.b2bstrawman.member;

import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.project.ProjectRepository;
import io.b2mash.b2b.b2bstrawman.security.Roles;
import java.util.UUID;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class ProjectAccessService {

  private final ProjectMemberRepository projectMemberRepository;
  private final ProjectRepository projectRepository;

  public ProjectAccessService(
      ProjectMemberRepository projectMemberRepository, ProjectRepository projectRepository) {
    this.projectMemberRepository = projectMemberRepository;
    this.projectRepository = projectRepository;
  }

  @Transactional(readOnly = true)
  public ProjectAccess checkAccess(UUID projectId, UUID memberId, String orgRole) {
    if (Roles.ORG_OWNER.equals(orgRole)) {
      if (!projectExistsInTenant(projectId)) {
        return ProjectAccess.DENIED;
      }
      var projectRole = lookupProjectRole(projectId, memberId);
      return new ProjectAccess(true, true, true, true, projectRole);
    }

    if (Roles.ORG_ADMIN.equals(orgRole)) {
      if (!projectExistsInTenant(projectId)) {
        return ProjectAccess.DENIED;
      }
      var projectRole = lookupProjectRole(projectId, memberId);
      return new ProjectAccess(true, true, true, false, projectRole);
    }

    // org:member — access depends on project membership
    return projectMemberRepository
        .findByProjectIdAndMemberId(projectId, memberId)
        .map(
            pm -> {
              boolean isLead = Roles.PROJECT_LEAD.equals(pm.getProjectRole());
              return new ProjectAccess(true, isLead, isLead, false, pm.getProjectRole());
            })
        .orElse(ProjectAccess.DENIED);
  }

  /**
   * Checks access and throws ResourceNotFoundException if the caller cannot view the project. This
   * provides security-by-obscurity: unauthorized users see "not found" rather than "forbidden".
   */
  @Transactional(readOnly = true)
  public ProjectAccess requireViewAccess(UUID projectId, UUID memberId, String orgRole) {
    var access = checkAccess(projectId, memberId, orgRole);
    if (!access.canView()) {
      throw new ResourceNotFoundException("Project", projectId);
    }
    return access;
  }

  @Transactional(readOnly = true)
  public ProjectAccess requireEditAccess(UUID projectId, UUID memberId, String orgRole) {
    var access = requireViewAccess(projectId, memberId, orgRole);
    if (!access.canEdit()) {
      throw new ForbiddenException(
          "Cannot edit project", "You do not have permission to edit project " + projectId);
    }
    return access;
  }

  private boolean projectExistsInTenant(UUID projectId) {
    return projectRepository.findOneById(projectId).isPresent();
  }

  private String lookupProjectRole(UUID projectId, UUID memberId) {
    return projectMemberRepository
        .findByProjectIdAndMemberId(projectId, memberId)
        .map(ProjectMember::getProjectRole)
        .orElse(null);
  }
}
```

### RequestScopes (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/RequestScopes.java)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import io.b2mash.b2b.b2bstrawman.exception.MissingOrganizationContextException;
import java.util.UUID;

public final class RequestScopes {

  public static final ScopedValue<String> TENANT_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> MEMBER_ID = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ROLE = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> CUSTOMER_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> PORTAL_CONTACT_ID = ScopedValue.newInstance();

  public static final String DEFAULT_TENANT = "public";

  public static UUID requireMemberId() {
    if (!MEMBER_ID.isBound()) {
      throw new MemberContextNotBoundException();
    }
    return MEMBER_ID.get();
  }

  public static String requireOrgId() {
    if (!ORG_ID.isBound()) {
      throw new MissingOrganizationContextException();
    }
    return ORG_ID.get();
  }

  public static String getOrgRole() {
    return ORG_ROLE.isBound() ? ORG_ROLE.get() : null;
  }

  // ... other methods ...

  private RequestScopes() {}
}
```

### TenantFilter — Caffeine cache pattern (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/multitenancy/TenantFilter.java)
```java
// Key Caffeine pattern used in the codebase:
private final Cache<String, TenantInfo> tenantCache =
    Caffeine.newBuilder().maximumSize(10_000).expireAfterWrite(Duration.ofHours(1)).build();

// Access pattern (getIfPresent + put):
private TenantInfo resolveTenant(String clerkOrgId) {
    // Caffeine's cache.get(key, loader) throws NPE if loader returns null.
    // Use getIfPresent + manual put to handle unprovisioned orgs gracefully.
    TenantInfo cached = tenantCache.getIfPresent(clerkOrgId);
    if (cached != null) {
      return cached;
    }
    TenantInfo info = lookupTenant(clerkOrgId);
    if (info != null) {
      tenantCache.put(clerkOrgId, info);
    }
    return info;
}
```

### ProjectBudget entity (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/budget/ProjectBudget.java)
```java
package io.b2mash.b2b.b2bstrawman.budget;

// Key fields for health calculation:
@Entity
@Table(name = "project_budgets")
public class ProjectBudget implements TenantAware {
  @Id @GeneratedValue(strategy = GenerationType.UUID) private UUID id;
  @Column(name = "project_id", nullable = false, unique = true) private UUID projectId;
  @Column(name = "budget_hours", precision = 10, scale = 2) private BigDecimal budgetHours;
  @Column(name = "alert_threshold_pct", nullable = false) private int alertThresholdPct = 80;
  // ... other fields ...

  public BigDecimal getBudgetHours() { return budgetHours; }
  public int getAlertThresholdPct() { return alertThresholdPct; }
}
```

### ProjectBudgetRepository (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/budget/ProjectBudgetRepository.java)
```java
package io.b2mash.b2b.b2bstrawman.budget;

import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface ProjectBudgetRepository extends JpaRepository<ProjectBudget, UUID> {

  @Query("SELECT pb FROM ProjectBudget pb WHERE pb.id = :id")
  Optional<ProjectBudget> findOneById(@Param("id") UUID id);

  @Query("SELECT pb FROM ProjectBudget pb WHERE pb.projectId = :projectId")
  Optional<ProjectBudget> findByProjectId(@Param("projectId") UUID projectId);
}
```

### TimeEntryRepository — native SQL aggregation pattern (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryRepository.java)
```java
// Budget hours consumed query — relevant for dashboard budget data:
@Query(
    nativeQuery = true,
    value =
        """
    SELECT COALESCE(SUM(te.duration_minutes), 0) / 60.0 AS hoursConsumed
    FROM time_entries te
    JOIN tasks t ON te.task_id = t.id
    WHERE t.project_id = :projectId
    """)
BudgetHoursProjection budgetHoursConsumed(@Param("projectId") UUID projectId);

// Per-member time summary — relevant for hoursThisPeriod:
@Query(
    nativeQuery = true,
    value =
        """
    SELECT
      COALESCE(SUM(CASE WHEN te.billable = true THEN te.duration_minutes ELSE 0 END), 0) AS billableMinutes,
      COALESCE(SUM(CASE WHEN te.billable = false THEN te.duration_minutes ELSE 0 END), 0) AS nonBillableMinutes,
      COALESCE(SUM(te.duration_minutes), 0) AS totalMinutes,
      COUNT(DISTINCT te.member_id) AS contributorCount,
      COUNT(te.id) AS entryCount
    FROM time_entries te
      JOIN tasks t ON te.task_id = t.id
    WHERE t.project_id = :projectId
      AND (CAST(:fromDate AS DATE) IS NULL OR te.date >= CAST(:fromDate AS DATE))
      AND (CAST(:toDate AS DATE) IS NULL OR te.date <= CAST(:toDate AS DATE))
    """)
ProjectTimeSummaryProjection projectTimeSummary(
    @Param("projectId") UUID projectId,
    @Param("fromDate") LocalDate from,
    @Param("toDate") LocalDate to);
```

### BudgetHoursProjection — Spring Data projection interface pattern (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/BudgetHoursProjection.java)
```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import java.math.BigDecimal;

/** Spring Data projection interface for budget hours consumption aggregation. */
public interface BudgetHoursProjection {

  BigDecimal getHoursConsumed();
}
```

### Roles — role constants (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/security/Roles.java)
```java
package io.b2mash.b2b.b2bstrawman.security;

public final class Roles {
  public static final String ORG_OWNER = "owner";
  public static final String ORG_ADMIN = "admin";
  public static final String ORG_MEMBER = "member";
  public static final String PROJECT_LEAD = "lead";
  public static final String PROJECT_MEMBER = "member";
  public static final String AUTHORITY_ORG_OWNER = "ROLE_ORG_OWNER";
  public static final String AUTHORITY_ORG_ADMIN = "ROLE_ORG_ADMIN";
  public static final String AUTHORITY_ORG_MEMBER = "ROLE_ORG_MEMBER";
  public static final String AUTHORITY_INTERNAL = "ROLE_INTERNAL_SERVICE";

  private Roles() {}
}
```

### ProjectAccess record (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/member/ProjectAccess.java)
```java
package io.b2mash.b2b.b2bstrawman.member;

public record ProjectAccess(
    boolean canView,
    boolean canEdit,
    boolean canManageMembers,
    boolean canDelete,
    String projectRole) {

  public static final ProjectAccess DENIED = new ProjectAccess(false, false, false, false, null);
}
```

### Integration test pattern — MockMvc + tenant provisioning (from backend/src/test/java/io/b2mash/b2b/b2bstrawman/budget/ProjectBudgetIntegrationTest.java)
```java
package io.b2mash.b2b.b2bstrawman.budget;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.project.ProjectService;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import io.b2mash.b2b.b2bstrawman.task.TaskService;
import io.b2mash.b2b.b2bstrawman.timeentry.TimeEntryService;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.JwtRequestPostProcessor;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ProjectBudgetIntegrationTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_budget_test";

  @Autowired private MockMvc mockMvc;
  @Autowired private ProjectService projectService;
  @Autowired private TaskService taskService;
  @Autowired private TimeEntryService timeEntryService;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;
  @Autowired private OrgSchemaMappingRepository orgSchemaMappingRepository;

  private String tenantSchema;
  private UUID memberIdOwner;
  private UUID projectId;

  @BeforeAll
  void setup() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "Budget Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    memberIdOwner =
        UUID.fromString(
            syncMember(ORG_ID, "user_budget_owner", "budget_owner@test.com", "Budget Owner", "owner"));

    tenantSchema =
        orgSchemaMappingRepository.findByClerkOrgId(ORG_ID).orElseThrow().getSchemaName();

    // Seed data in tenant scope
    ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
        .where(RequestScopes.ORG_ID, ORG_ID)
        .where(RequestScopes.MEMBER_ID, memberIdOwner)
        .where(RequestScopes.ORG_ROLE, "owner")
        .run(() -> {
          var project = projectService.createProject("Test Project", "Test", memberIdOwner);
          projectId = project.getId();
          // ... create tasks, time entries etc.
        });
  }

  // JWT helper:
  private JwtRequestPostProcessor ownerJwt() {
    return jwt()
        .jwt(j -> j.subject("user_budget_owner").claim("o", Map.of("id", ORG_ID, "rol", "owner")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
  }

  // Member sync helper:
  private String syncMember(
      String orgId, String clerkUserId, String email, String name, String orgRole) throws Exception {
    var result =
        mockMvc
            .perform(
                post("/internal/members/sync")
                    .header("X-API-KEY", API_KEY)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                    {
                      "clerkOrgId": "%s",
                      "clerkUserId": "%s",
                      "email": "%s",
                      "name": "%s",
                      "avatarUrl": null,
                      "orgRole": "%s"
                    }
                    """
                            .formatted(orgId, clerkUserId, email, name, orgRole)))
            .andExpect(status().isCreated())
            .andReturn();
    return JsonPath.read(result.getResponse().getContentAsString(), "$.memberId");
  }
}
```

## Conventions

### Naming
- Base package: `io.b2mash.b2b.b2bstrawman`
- Entities: domain name (no `Entity` suffix)
- Repositories: `*Repository` extending `JpaRepository`
- Services: `*Service`
- Controllers: `*Controller`
- DTOs: nested records inside controller or in `dto` sub-package if shared

### Code Style
- Use Java records for DTOs, request/response objects, and value objects
- Prefer constructor injection (no `@Autowired` on fields)
- Use `@PreAuthorize` annotations for role-based access control
- Return `ResponseEntity` from controllers for explicit status codes
- Use Spring's `ProblemDetail` (RFC 9457) for error responses
- No Lombok — Java 25 records and pattern matching cover most use cases

### Anti-Patterns — Never Do This

- Never use `@Autowired` on fields — use constructor injection
- Never use Lombok — Java 25 records and pattern matching cover all cases
- Never trust client headers for tenant resolution — always derive from validated JWT
- Never use `org.springframework.boot.orm.jpa.HibernatePropertiesCustomizer` — it moved to `boot.hibernate.autoconfigure` in Spring Boot 4
- Never set `hibernate.multiTenancy` property — Hibernate 7 auto-detects from registered provider
- Never use `java -jar` for the Docker entry point — use `org.springframework.boot.loader.launch.JarLauncher`
- Never make `TestcontainersConfiguration` package-private — it must be `public` for `@Import` from subpackages
- Never use `@ActiveProfiles("local")` in tests — use `@ActiveProfiles("test")`. The "local" profile connects to Docker Compose Postgres. Tests must run against ephemeral Testcontainers only.
- Never use flat JWT claims (`org_id`, `org_role`) — Clerk JWT v2 nests org claims under `"o"`: `jwt.getClaim("o")` returns `Map<String, Object>` with keys `id`, `rol`, `slg`
- Never use `ThreadLocal` for request-scoped context — use `ScopedValue` via `RequestScopes` (guaranteed cleanup, virtual thread safe)
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first or accepting `NoSuchElementException`
- Never build `ProblemDetail` directly in controllers or services — throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" — throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers — use `RequestScopes.requireMemberId()` and the shared exception classes

### Testing
- Integration tests: `@SpringBootTest` + `@AutoConfigureMockMvc` + `@Import(TestcontainersConfiguration.class)` + `@ActiveProfiles("test")` + `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`
- `AutoConfigureMockMvc` import from `org.springframework.boot.webmvc.test.autoconfigure` (NOT `boot.test.autoconfigure.web.servlet` — Spring Boot 4 migration)
- JWT mocks: `jwt().jwt(j -> j.subject("...").claim("o", Map.of(...))).authorities(List.of(new SimpleGrantedAuthority("ROLE_...")))`
- Spring Security Test `jwt()` mock does NOT invoke `JwtAuthenticationConverter` — must set `.authorities()` explicitly on the mock
- Use `ScopedValue.where(RequestScopes.TENANT_ID, schema).run(...)` in `@BeforeAll` for data seeding — no `@AfterEach` cleanup needed
- Member sync via internal endpoint: `POST /internal/members/sync` with `X-API-KEY` header
- `@TestInstance(Lifecycle.PER_CLASS)` for `@BeforeAll` non-static methods

## Integration Points

### Classes and method signatures the new code calls or extends

**ProjectAccessService** (from `member/ProjectAccessService.java`):
```java
public ProjectAccess requireViewAccess(UUID projectId, UUID memberId, String orgRole)
// Throws ResourceNotFoundException if caller cannot view project (404 for non-members)
```

**TaskRepository** (from `task/TaskRepository.java`):
- Existing methods are listed in Reference Patterns above
- NEW methods to add:
```java
@Query("SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId")
long countByProjectId(@Param("projectId") UUID projectId);

@Query("SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId AND t.status = :status")
long countByProjectIdAndStatus(@Param("projectId") UUID projectId, @Param("status") String status);

@Query("SELECT COUNT(t) FROM Task t WHERE t.projectId = :projectId AND t.status <> 'DONE' AND t.dueDate < :today")
long countOverdueByProjectId(@Param("projectId") UUID projectId, @Param("today") LocalDate today);

@Query("SELECT COUNT(t) FROM Task t WHERE t.status <> 'DONE' AND t.dueDate < :today")
long countOrgOverdue(@Param("today") LocalDate today);
```

**AuditEventRepository** (from `audit/AuditEventRepository.java`):
- NEW method to add:
```java
@Query(
    value = "SELECT MAX(ae.occurred_at) FROM audit_events ae WHERE (ae.details->>'project_id')::uuid = :projectId",
    nativeQuery = true)
Optional<Instant> findMostRecentByProject(@Param("projectId") UUID projectId);
```

**ProjectBudgetRepository** (from `budget/ProjectBudgetRepository.java`):
```java
Optional<ProjectBudget> findByProjectId(@Param("projectId") UUID projectId);
```

**TimeEntryRepository** (from `timeentry/TimeEntryRepository.java`):
```java
BudgetHoursProjection budgetHoursConsumed(@Param("projectId") UUID projectId);
ProjectTimeSummaryProjection projectTimeSummary(UUID projectId, LocalDate from, LocalDate to);
```

**ProjectHealthCalculator** (from `dashboard/ProjectHealthCalculator.java`):
```java
public static ProjectHealthResult calculate(ProjectHealthInput input);
```

**RequestScopes** (from `multitenancy/RequestScopes.java`):
```java
public static UUID requireMemberId();
public static String getOrgRole();
// Access TENANT_ID: RequestScopes.TENANT_ID.get() (after checking isBound())
```

### Budget consumption calculation for health input

To get `budgetConsumedPercent`:
1. Query `ProjectBudgetRepository.findByProjectId(projectId)` — returns `Optional<ProjectBudget>`
2. If present: get `budgetHours` from the entity
3. Get consumed hours: `TimeEntryRepository.budgetHoursConsumed(projectId).getHoursConsumed()`
4. Calculate: `consumedHours / budgetHours * 100`
5. Get `alertThresholdPct` from the budget entity
6. If no budget exists: pass `null` for `budgetConsumedPercent`, use `ProjectHealthCalculator.DEFAULT_BUDGET_ALERT_THRESHOLD` for `alertThresholdPct`

### Task status values

Task status is a free-form String field. Known values used in the codebase:
- `"OPEN"` — maps to `todo` in TaskSummary
- `"IN_PROGRESS"` — maps to `inProgress` in TaskSummary
- `"IN_REVIEW"` — maps to `inReview` in TaskSummary
- `"DONE"` — maps to `done` in TaskSummary

For TaskSummary, use a single JPQL query with conditional COUNT:
```java
@Query("""
    SELECT
        SUM(CASE WHEN t.status = 'OPEN' THEN 1 ELSE 0 END),
        SUM(CASE WHEN t.status = 'IN_PROGRESS' THEN 1 ELSE 0 END),
        SUM(CASE WHEN t.status = 'IN_REVIEW' THEN 1 ELSE 0 END),
        SUM(CASE WHEN t.status = 'DONE' THEN 1 ELSE 0 END),
        COUNT(t),
        SUM(CASE WHEN t.status <> 'DONE' AND t.dueDate < :today THEN 1 ELSE 0 END)
    FROM Task t
    WHERE t.projectId = :projectId
    """)
```
This returns `Object[]` — extract each position. Alternatively, use individual count methods (already being added).

**Recommendation**: Use the individual count methods for `getProjectHealth()` (3 queries: total, done, overdue). For `getTaskSummary()`, add a single aggregation query that returns all 6 counts at once (more efficient than 6 separate queries). The aggregation query can be a custom JPQL returning Object[] or use a projection interface.

### TaskSummary approach — single query via Object[]

Add this to `TaskRepository`:
```java
@Query("""
    SELECT
        COALESCE(SUM(CASE WHEN t.status = 'OPEN' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN t.status = 'IN_PROGRESS' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN t.status = 'IN_REVIEW' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN t.status = 'DONE' THEN 1 ELSE 0 END), 0),
        COUNT(t),
        COALESCE(SUM(CASE WHEN t.status <> 'DONE' AND t.dueDate < :today THEN 1 ELSE 0 END), 0)
    FROM Task t
    WHERE t.projectId = :projectId
    """)
Object[] getTaskSummaryByProjectId(@Param("projectId") UUID projectId, @Param("today") LocalDate today);
```

In `DashboardService`:
```java
Object[] row = taskRepository.getTaskSummaryByProjectId(projectId, LocalDate.now());
var summary = new TaskSummary(
    ((Number) row[0]).intValue(),  // todo
    ((Number) row[1]).intValue(),  // inProgress
    ((Number) row[2]).intValue(),  // inReview
    ((Number) row[3]).intValue(),  // done
    ((Number) row[4]).intValue(),  // total
    ((Number) row[5]).intValue()   // overdueCount
);
```

## Caffeine Cache Config

### Maven Dependency
Already present in `backend/pom.xml`:
```xml
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
```
No version needed — managed by Spring Boot BOM.

### Configuration Approach
Inline cache instance as a field in `DashboardService` — NOT a Spring-managed `CacheManager`. Consistent with `TenantFilter` and `MemberFilter` patterns in the codebase.

### Cache Setup
```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import java.time.Duration;

// In DashboardService:
private final Cache<String, Object> projectCache = Caffeine.newBuilder()
    .maximumSize(5_000)
    .expireAfterWrite(Duration.ofMinutes(1))
    .build();
```

### Cache Keys and TTLs

| Cache | Endpoint | Key Format | TTL |
|-------|----------|-----------|-----|
| `projectCache` | `GET /api/projects/{id}/health` | `"{tenantId}:project:{projectId}:health"` | 1 min |
| `projectCache` | `GET /api/projects/{id}/task-summary` | `"{tenantId}:project:{projectId}:task-summary"` | 1 min |

### Cache Access Pattern (IMPORTANT)
```java
@SuppressWarnings("unchecked")
public ProjectHealthDetail getProjectHealth(UUID projectId, String tenantId) {
    String key = tenantId + ":project:" + projectId + ":health";
    ProjectHealthDetail cached = (ProjectHealthDetail) projectCache.getIfPresent(key);
    if (cached != null) {
        return cached;
    }
    ProjectHealthDetail result = computeProjectHealth(projectId);
    projectCache.put(key, result);
    return result;
}
```

**CRITICAL**: Use `getIfPresent() + put()` — NEVER use `cache.get(key, loader)` because it throws NPE if the loader returns null. This is an established pattern from `TenantFilter`.

## Build & Verify

All commands run from: cd /Users/rakheendama/Projects/2026/worktree-epic-75B/backend

**Step 1: Format**
  ./mvnw spotless:apply 2>&1 | tail -3

**Step 2: Silent full build (Pass 1)**
  ./mvnw clean verify -q > /tmp/mvn-epic-75B.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-75B.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-75B.log | head -20; fi; fi

**Step 3: Re-run ONLY failed tests with full output (only if Pass 1 failed)**
  ./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80

**Step 4: Silent re-verify after fixing (Pass 2)**
  ./mvnw clean verify -q > /tmp/mvn-epic-75B.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-75B.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi

IMPORTANT: NEVER run ./mvnw clean verify without -q.

## Environment
- Postgres host: b2mash.local:5432
- LocalStack host: b2mash.local:4566
- Maven wrapper: ./mvnw from backend dir
