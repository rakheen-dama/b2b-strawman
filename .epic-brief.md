# Implementation Brief: Epic 59B — Comment Service, Controller & Integration Tests

## Scope
Backend

## Tasks

### Task 59.6 — Create CommentService with CRUD operations
Create `comment/CommentService.java`. Constructor injection of `CommentRepository`, `ProjectAccessService`, `TaskRepository`, `DocumentRepository`, `AuditService`, `ApplicationEventPublisher`, `MemberRepository`. Methods:

1. **`createComment(UUID projectId, String entityType, UUID entityId, String body, String visibility, UUID memberId, String orgRole)`** — calls `projectAccessService.requireViewAccess()`, validates entityType is TASK or DOCUMENT, verifies entity exists and belongs to project, determines visibility (SHARED requires `access.canEdit()`), saves comment, logs audit event (`comment.created`), publishes `CommentCreatedEvent`. Returns saved Comment.
2. **`updateComment(UUID projectId, UUID commentId, String body, String visibility, UUID memberId, String orgRole)`** — loads comment via `findOneById`, verifies projectId matches, authorization checks per permission table (see below), updates fields, logs `comment.updated` audit, publishes `CommentUpdatedEvent`. If visibility changed, also logs `comment.visibility_changed` and publishes `CommentVisibilityChangedEvent`. Returns updated Comment.
3. **`deleteComment(UUID projectId, UUID commentId, UUID memberId, String orgRole)`** — loads comment, verifies projectId, authorization (author OR admin/owner), logs `comment.deleted` audit (captures body in details), publishes `CommentDeletedEvent`, hard-deletes via `commentRepository.delete()`.
4. **`listComments(UUID projectId, String entityType, UUID entityId, Pageable pageable, UUID memberId, String orgRole)`** — calls `requireViewAccess()`, delegates to `commentRepository.findByEntityTypeAndEntityId()`. Returns `Page<Comment>`.

All mutating methods are `@Transactional`. Read-only methods are `@Transactional(readOnly = true)`.

**Acceptance Criteria:**
- All CRUD operations work correctly
- Entity existence validated before comment creation
- Audit events logged for all mutations
- Domain events published for all mutations
- SHARED visibility gated by `access.canEdit()` (lead/admin/owner)
- Edit/delete others' comments gated by admin/owner org role

### Task 59.7 — Create CommentController with request/response DTOs
Create `comment/CommentController.java`. `@RestController`, `@RequestMapping("/api/projects/{projectId}/comments")`. Inner record DTOs: `CreateCommentRequest`, `UpdateCommentRequest`, `CommentResponse`. Endpoints:
- `POST /` → 201 Created with Location header
- `GET /` with `entityType` + `entityId` + `page` + `size` params → 200
- `PUT /{commentId}` → 200
- `DELETE /{commentId}` → 204

Each endpoint extracts `memberId` and `orgRole` from `RequestScopes`. For author name/avatar resolution: batch-load from `MemberRepository.findAllById()`.

**Acceptance Criteria:**
- All endpoints respond with correct HTTP status codes
- Author name and avatar URL resolved and included in `CommentResponse`
- Request validation via `@Valid` + `@NotBlank` on body field
- `@PreAuthorize` on all endpoints for authenticated users

### Task 59.8 — SecurityConfig verification
Verify `/api/projects/*/comments/**` is covered by authenticated endpoint patterns. The existing `/api/**` pattern in `SecurityConfig.securityFilterChain()` already covers this — no modification needed (confirmed from reading SecurityConfig).

**Acceptance Criteria:** Comment endpoints require authentication (already covered by `/api/**` pattern).

### Task 59.9 — CommentService integration tests
Create `comment/CommentServiceIntegrationTest.java`. ~8 tests:
1. Create comment on task (verify persisted correctly)
2. Create comment on document
3. Create comment with SHARED visibility by lead (success)
4. Create comment with SHARED by regular member (rejected with ForbiddenException)
5. Update own comment body (success)
6. Update own comment visibility without lead role (rejected)
7. Delete own comment
8. Delete others' comment as admin

Seed: provision tenant, sync members (owner + admin + regular member), create project, add project members, create task + document in `@BeforeAll`.

**Acceptance Criteria:** All 8 tests pass, covering CRUD + authorization + visibility gating.

### Task 59.10 — CommentController integration tests (MockMvc)
Create `comment/CommentControllerTest.java`. ~7 tests:
1. POST creates comment and returns 201 with correct JSON shape
2. GET lists comments ordered by createdAt ASC
3. GET with pagination
4. PUT updates body and returns 200
5. PUT by non-author non-admin returns 403/404
6. DELETE by author returns 204
7. DELETE by non-author non-admin returns 404

Use MockMvc with `jwt()` mock per backend CLAUDE.md conventions.

**Acceptance Criteria:** All 7 tests pass, covering endpoints + access control + response shapes.

### Task 59.11 — Comment tenant isolation tests
~3 tests within `CommentServiceIntegrationTest.java`:
1. Comment created in tenant A is invisible in tenant B (Pro isolation)
2. Comment created by Starter org A is invisible to Starter org B (shared schema + @Filter isolation)
3. Verify `tenant_id` auto-populated by `TenantAwareEntityListener`

**Acceptance Criteria:** All 3 tenant isolation tests pass.

## Permission Model (from Architecture Doc Section 11.10)

| Operation | Any Project Member | Project Lead | Org Admin | Org Owner |
|-----------|-------------------|--------------|-----------|-----------|
| Create comment (INTERNAL) | Yes | Yes | Yes | Yes |
| Create comment (SHARED) | No | Yes | Yes | Yes |
| Edit own comment body | Yes | Yes | Yes | Yes |
| Edit own comment visibility | No | Yes | Yes | Yes |
| Edit others' comment body | No | No | Yes | Yes |
| Edit others' comment visibility | No | No | Yes | Yes |
| Delete own comment | Yes | Yes | Yes | Yes |
| Delete others' comment | No | No | Yes | Yes |
| List comments | Yes | Yes | Yes | Yes |

**Authorization logic**: `CommentService` first checks authorship via `comment.getAuthorMemberId().equals(memberId)`.
- **Own comments**: body edits always allowed; visibility edits require `ProjectAccess.canEdit()` (lead/admin/owner).
- **Others' comments**: both body and visibility edits require admin/owner org role — check `Roles.ORG_ADMIN.equals(orgRole) || Roles.ORG_OWNER.equals(orgRole)`. Project leads CANNOT modify others' comments.
- **Deletion**: own comment = always allowed; others' comment = admin/owner only (same check as edit others').

**How to determine admin/owner (not lead)**: `ProjectAccess` record has `canEdit()` which is true for lead, admin, AND owner. To distinguish admin/owner from lead, check the `orgRole` string directly:
```java
boolean isOrgAdminOrOwner = Roles.ORG_ADMIN.equals(orgRole) || Roles.ORG_OWNER.equals(orgRole);
```

## File Plan

### Create
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/comment/CommentService.java` — CRUD service with authorization, audit, and event publication
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/comment/CommentController.java` — REST controller with DTOs
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/comment/CommentServiceIntegrationTest.java` — Service + tenant isolation tests (~11 tests)
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/comment/CommentControllerTest.java` — MockMvc controller tests (~7 tests)

### Modify
- **None** — SecurityConfig already covers `/api/**` pattern. No modifications needed.

## Existing Code (from 59A)

### Comment Entity
```java
package io.b2mash.b2b.b2bstrawman.comment;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import java.time.Instant;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "comments")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class Comment implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "entity_type", nullable = false, length = 20)
  private String entityType;

  @Column(name = "entity_id", nullable = false)
  private UUID entityId;

  @Column(name = "project_id", nullable = false)
  private UUID projectId;

  @Column(name = "author_member_id", nullable = false)
  private UUID authorMemberId;

  @NotBlank
  @Column(name = "body", nullable = false, columnDefinition = "TEXT")
  private String body;

  @Column(name = "visibility", nullable = false, length = 20)
  private String visibility;

  @Column(name = "parent_id")
  private UUID parentId;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected Comment() {}

  public Comment(
      String entityType,
      UUID entityId,
      UUID projectId,
      UUID authorMemberId,
      String body,
      String visibility) {
    this.entityType = entityType;
    this.entityId = entityId;
    this.projectId = projectId;
    this.authorMemberId = authorMemberId;
    this.body = body;
    this.visibility = visibility;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public void updateBody(String body) {
    this.body = body;
    this.updatedAt = Instant.now();
  }

  public void updateVisibility(String visibility) {
    this.visibility = visibility;
    this.updatedAt = Instant.now();
  }

  public UUID getId() { return id; }
  public String getEntityType() { return entityType; }
  public UUID getEntityId() { return entityId; }
  public UUID getProjectId() { return projectId; }
  public UUID getAuthorMemberId() { return authorMemberId; }
  public String getBody() { return body; }
  public String getVisibility() { return visibility; }
  public UUID getParentId() { return parentId; }
  public void setParentId(UUID parentId) { this.parentId = parentId; }
  public Instant getCreatedAt() { return createdAt; }
  public Instant getUpdatedAt() { return updatedAt; }

  @Override
  public String getTenantId() { return tenantId; }

  @Override
  public void setTenantId(String tenantId) { this.tenantId = tenantId; }
}
```

### CommentRepository
```java
package io.b2mash.b2b.b2bstrawman.comment;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface CommentRepository extends JpaRepository<Comment, UUID> {

  /**
   * JPQL-based findById that respects Hibernate @Filter (unlike JpaRepository.findById which uses
   * EntityManager.find and bypasses @Filter). Required for shared-schema tenant isolation.
   */
  @Query("SELECT c FROM Comment c WHERE c.id = :id")
  Optional<Comment> findOneById(@Param("id") UUID id);

  /** List comments on a specific entity, ordered by creation time (oldest first). */
  @Query(
      """
      SELECT c FROM Comment c
      WHERE c.entityType = :entityType
        AND c.entityId = :entityId
      ORDER BY c.createdAt ASC
      """)
  Page<Comment> findByEntityTypeAndEntityId(
      @Param("entityType") String entityType, @Param("entityId") UUID entityId, Pageable pageable);

  /** Find all distinct commenter member IDs on an entity (for notification fan-out). */
  @Query(
      """
      SELECT DISTINCT c.authorMemberId FROM Comment c
      WHERE c.entityType = :entityType
        AND c.entityId = :entityId
      """)
  List<UUID> findDistinctAuthorsByEntity(
      @Param("entityType") String entityType, @Param("entityId") UUID entityId);
}
```

### DomainEvent Sealed Interface
```java
package io.b2mash.b2b.b2bstrawman.event;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public sealed interface DomainEvent
    permits CommentCreatedEvent,
        CommentUpdatedEvent,
        CommentDeletedEvent,
        CommentVisibilityChangedEvent,
        TaskAssignedEvent,
        TaskClaimedEvent,
        TaskStatusChangedEvent,
        DocumentUploadedEvent,
        MemberAddedToProjectEvent {

  String eventType();
  String entityType();
  UUID entityId();
  UUID projectId();
  UUID actorMemberId();
  String actorName();
  String tenantId();
  Instant occurredAt();
  Map<String, Object> details();
}
```

### CommentCreatedEvent
```java
package io.b2mash.b2b.b2bstrawman.event;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record CommentCreatedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    Instant occurredAt,
    Map<String, Object> details,
    String targetEntityType,
    UUID targetEntityId,
    String visibility)
    implements DomainEvent {}
```

### CommentUpdatedEvent
```java
package io.b2mash.b2b.b2bstrawman.event;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record CommentUpdatedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    Instant occurredAt,
    Map<String, Object> details)
    implements DomainEvent {}
```

### CommentDeletedEvent
```java
package io.b2mash.b2b.b2bstrawman.event;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record CommentDeletedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    Instant occurredAt,
    Map<String, Object> details,
    String targetEntityType,
    UUID targetEntityId)
    implements DomainEvent {}
```

### CommentVisibilityChangedEvent
```java
package io.b2mash.b2b.b2bstrawman.event;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record CommentVisibilityChangedEvent(
    String eventType,
    String entityType,
    UUID entityId,
    UUID projectId,
    UUID actorMemberId,
    String actorName,
    String tenantId,
    Instant occurredAt,
    Map<String, Object> details,
    String oldVisibility,
    String newVisibility)
    implements DomainEvent {}
```

## Reference Patterns

### Service (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/task/TaskService.java)
```java
package io.b2mash.b2b.b2bstrawman.task;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.member.ProjectAccessService;
import io.b2mash.b2b.b2bstrawman.member.ProjectMemberRepository;
import java.time.LocalDate;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class TaskService {

  private static final Logger log = LoggerFactory.getLogger(TaskService.class);

  private final TaskRepository taskRepository;
  private final ProjectAccessService projectAccessService;
  private final ProjectMemberRepository projectMemberRepository;
  private final AuditService auditService;

  public TaskService(
      TaskRepository taskRepository,
      ProjectAccessService projectAccessService,
      ProjectMemberRepository projectMemberRepository,
      AuditService auditService) {
    this.taskRepository = taskRepository;
    this.projectAccessService = projectAccessService;
    this.projectMemberRepository = projectMemberRepository;
    this.auditService = auditService;
  }

  @Transactional(readOnly = true)
  public List<Task> listTasks(
      UUID projectId,
      UUID memberId,
      String orgRole,
      String status,
      UUID assigneeId,
      String priority,
      String assigneeFilter) {
    projectAccessService.requireViewAccess(projectId, memberId, orgRole);

    if ("unassigned".equals(assigneeFilter)) {
      return taskRepository.findByProjectIdUnassigned(projectId, status, priority);
    }

    return taskRepository.findByProjectIdWithFilters(projectId, status, assigneeId, priority);
  }

  @Transactional(readOnly = true)
  public Task getTask(UUID taskId, UUID memberId, String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));
    projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);
    return task;
  }

  @Transactional
  public Task createTask(
      UUID projectId,
      String title,
      String description,
      String priority,
      String type,
      LocalDate dueDate,
      UUID createdBy,
      String orgRole) {
    projectAccessService.requireViewAccess(projectId, createdBy, orgRole);

    var task = new Task(projectId, title, description, priority, type, dueDate, createdBy);
    task = taskRepository.save(task);
    log.info("Created task {} in project {}", task.getId(), projectId);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("task.created")
            .entityType("task")
            .entityId(task.getId())
            .details(Map.of("title", task.getTitle(), "project_id", projectId.toString()))
            .build());

    return task;
  }

  @Transactional
  public Task updateTask(
      UUID taskId,
      String title,
      String description,
      String priority,
      String status,
      String type,
      LocalDate dueDate,
      UUID assigneeId,
      UUID memberId,
      String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    var access = projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    if (!access.canEdit() && !memberId.equals(task.getAssigneeId())) {
      throw new ForbiddenException(
          "Cannot update task", "You do not have permission to update task " + taskId);
    }

    if (assigneeId != null
        && !projectMemberRepository.existsByProjectIdAndMemberId(task.getProjectId(), assigneeId)) {
      throw new ResourceNotFoundException("ProjectMember", assigneeId);
    }

    String oldTitle = task.getTitle();
    String oldDescription = task.getDescription();
    String oldStatus = task.getStatus();
    String oldPriority = task.getPriority();
    UUID oldAssigneeId = task.getAssigneeId();
    LocalDate oldDueDate = task.getDueDate();
    String oldType = task.getType();

    task.update(title, description, priority, status, type, dueDate, assigneeId);
    task = taskRepository.save(task);

    var details = new LinkedHashMap<String, Object>();
    if (!Objects.equals(oldTitle, title)) {
      details.put("title",
          Map.of("from", oldTitle != null ? oldTitle : "", "to", title != null ? title : ""));
    }
    if (!Objects.equals(oldDescription, description)) {
      details.put("description",
          Map.of("from", oldDescription != null ? oldDescription : "",
              "to", description != null ? description : ""));
    }
    if (!Objects.equals(oldStatus, status)) {
      details.put("status",
          Map.of("from", oldStatus != null ? oldStatus : "", "to", status != null ? status : ""));
    }
    if (!Objects.equals(oldPriority, priority)) {
      details.put("priority",
          Map.of("from", oldPriority != null ? oldPriority : "",
              "to", priority != null ? priority : ""));
    }
    if (!Objects.equals(oldAssigneeId, assigneeId)) {
      details.put("assignee_id",
          Map.of("from", oldAssigneeId != null ? oldAssigneeId.toString() : "",
              "to", assigneeId != null ? assigneeId.toString() : ""));
    }
    if (!Objects.equals(oldDueDate, dueDate)) {
      details.put("due_date",
          Map.of("from", oldDueDate != null ? oldDueDate.toString() : "",
              "to", dueDate != null ? dueDate.toString() : ""));
    }
    if (!Objects.equals(oldType, type)) {
      details.put("type",
          Map.of("from", oldType != null ? oldType : "", "to", type != null ? type : ""));
    }

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("task.updated")
            .entityType("task")
            .entityId(task.getId())
            .details(details.isEmpty() ? null : details)
            .build());

    return task;
  }

  @Transactional
  public void deleteTask(UUID taskId, UUID memberId, String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    var access = projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    if (!access.canEdit()) {
      throw new ForbiddenException(
          "Cannot delete task", "You do not have permission to delete task " + taskId);
    }

    taskRepository.delete(task);
    log.info("Deleted task {} from project {}", taskId, task.getProjectId());

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("task.deleted")
            .entityType("task")
            .entityId(task.getId())
            .details(Map.of("title", task.getTitle(), "project_id", task.getProjectId().toString()))
            .build());
  }

  @Transactional
  public Task claimTask(UUID taskId, UUID memberId, String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    if (!projectMemberRepository.existsByProjectIdAndMemberId(task.getProjectId(), memberId)) {
      throw new ResourceNotFoundException("Task", taskId);
    }

    if (!"OPEN".equals(task.getStatus())) {
      throw new InvalidStateException(
          "Cannot claim task",
          "Task can only be claimed when status is OPEN. Current status: " + task.getStatus());
    }

    if (task.getAssigneeId() != null) {
      throw new InvalidStateException(
          "Cannot claim task", "Task is already assigned to another member");
    }

    task.claim(memberId);
    task = taskRepository.save(task);
    log.info("Task {} claimed by member {}", taskId, memberId);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("task.claimed")
            .entityType("task")
            .entityId(task.getId())
            .details(Map.of("assignee_id", memberId.toString()))
            .build());

    return task;
  }

  @Transactional
  public Task releaseTask(UUID taskId, UUID memberId, String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    if (task.getAssigneeId() == null) {
      throw new InvalidStateException("Cannot release task", "Task is not currently claimed");
    }

    var access = projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    boolean isAssignee = memberId.equals(task.getAssigneeId());
    if (!isAssignee && !access.canEdit()) {
      throw new ForbiddenException(
          "Cannot release task", "Only the current assignee or a lead/admin/owner can release");
    }

    UUID previousAssigneeId = task.getAssigneeId();

    task.release();
    task = taskRepository.save(task);
    log.info("Task {} released by member {}", taskId, memberId);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("task.released")
            .entityType("task")
            .entityId(task.getId())
            .details(Map.of("previous_assignee_id", previousAssigneeId.toString()))
            .build());

    return task;
  }
}
```

### Controller (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/task/TaskController.java)
```java
package io.b2mash.b2b.b2bstrawman.task;

import io.b2mash.b2b.b2bstrawman.member.Member;
import io.b2mash.b2b.b2bstrawman.member.MemberRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.net.URI;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TaskController {

  private final TaskService taskService;
  private final MemberRepository memberRepository;

  public TaskController(TaskService taskService, MemberRepository memberRepository) {
    this.taskService = taskService;
    this.memberRepository = memberRepository;
  }

  @PostMapping("/api/projects/{projectId}/tasks")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TaskResponse> createTask(
      @PathVariable UUID projectId, @Valid @RequestBody CreateTaskRequest request) {
    UUID createdBy = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var task =
        taskService.createTask(
            projectId,
            request.title(),
            request.description(),
            request.priority(),
            request.type(),
            request.dueDate(),
            createdBy,
            orgRole);

    var names = resolveNames(List.of(task));
    return ResponseEntity.created(URI.create("/api/tasks/" + task.getId()))
        .body(TaskResponse.from(task, names));
  }

  @GetMapping("/api/projects/{projectId}/tasks")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<List<TaskResponse>> listTasks(
      @PathVariable UUID projectId,
      @RequestParam(required = false) String status,
      @RequestParam(required = false) UUID assigneeId,
      @RequestParam(required = false) String priority,
      @RequestParam(required = false) String assigneeFilter) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var taskEntities =
        taskService.listTasks(
            projectId, memberId, orgRole, status, assigneeId, priority, assigneeFilter);
    var names = resolveNames(taskEntities);
    var tasks = taskEntities.stream().map(t -> TaskResponse.from(t, names)).toList();

    return ResponseEntity.ok(tasks);
  }

  @GetMapping("/api/tasks/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TaskResponse> getTask(@PathVariable UUID id) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var task = taskService.getTask(id, memberId, orgRole);
    var names = resolveNames(List.of(task));
    return ResponseEntity.ok(TaskResponse.from(task, names));
  }

  @PutMapping("/api/tasks/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TaskResponse> updateTask(
      @PathVariable UUID id, @Valid @RequestBody UpdateTaskRequest request) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var task =
        taskService.updateTask(
            id,
            request.title(),
            request.description(),
            request.priority(),
            request.status(),
            request.type(),
            request.dueDate(),
            request.assigneeId(),
            memberId,
            orgRole);

    var names = resolveNames(List.of(task));
    return ResponseEntity.ok(TaskResponse.from(task, names));
  }

  @DeleteMapping("/api/tasks/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<Void> deleteTask(@PathVariable UUID id) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    taskService.deleteTask(id, memberId, orgRole);
    return ResponseEntity.noContent().build();
  }

  @PostMapping("/api/tasks/{id}/claim")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TaskResponse> claimTask(@PathVariable UUID id) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var task = taskService.claimTask(id, memberId, orgRole);
    var names = resolveNames(List.of(task));
    return ResponseEntity.ok(TaskResponse.from(task, names));
  }

  @PostMapping("/api/tasks/{id}/release")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TaskResponse> releaseTask(@PathVariable UUID id) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var task = taskService.releaseTask(id, memberId, orgRole);
    var names = resolveNames(List.of(task));
    return ResponseEntity.ok(TaskResponse.from(task, names));
  }

  private Map<UUID, String> resolveNames(List<Task> tasks) {
    var ids =
        tasks.stream()
            .flatMap(t -> Stream.of(t.getAssigneeId(), t.getCreatedBy()))
            .filter(Objects::nonNull)
            .distinct()
            .toList();

    if (ids.isEmpty()) {
      return Map.of();
    }

    return memberRepository.findAllById(ids).stream()
        .collect(Collectors.toMap(Member::getId, Member::getName, (a, b) -> a));
  }

  // --- DTOs ---

  public record CreateTaskRequest(
      @NotBlank(message = "title is required")
          @Size(max = 500, message = "title must be at most 500 characters")
          String title,
      String description,
      @Size(max = 20, message = "priority must be at most 20 characters") String priority,
      @Size(max = 100, message = "type must be at most 100 characters") String type,
      LocalDate dueDate) {}

  public record UpdateTaskRequest(
      @NotBlank(message = "title is required")
          @Size(max = 500, message = "title must be at most 500 characters")
          String title,
      String description,
      @NotBlank(message = "priority is required")
          @Size(max = 20, message = "priority must be at most 20 characters")
          String priority,
      @NotBlank(message = "status is required")
          @Size(max = 20, message = "status must be at most 20 characters")
          String status,
      @Size(max = 100, message = "type must be at most 100 characters") String type,
      LocalDate dueDate,
      UUID assigneeId) {}

  public record TaskResponse(
      UUID id,
      UUID projectId,
      String title,
      String description,
      String status,
      String priority,
      String type,
      UUID assigneeId,
      String assigneeName,
      UUID createdBy,
      String createdByName,
      LocalDate dueDate,
      int version,
      Instant createdAt,
      Instant updatedAt) {

    public static TaskResponse from(Task task, Map<UUID, String> memberNames) {
      return new TaskResponse(
          task.getId(),
          task.getProjectId(),
          task.getTitle(),
          task.getDescription(),
          task.getStatus(),
          task.getPriority(),
          task.getType(),
          task.getAssigneeId(),
          task.getAssigneeId() != null ? memberNames.get(task.getAssigneeId()) : null,
          task.getCreatedBy(),
          memberNames.get(task.getCreatedBy()),
          task.getDueDate(),
          task.getVersion(),
          task.getCreatedAt(),
          task.getUpdatedAt());
    }
  }
}
```

### Integration Test (from backend/src/test/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryIntegrationTest.java)
```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import static org.hamcrest.Matchers.hasSize;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.JwtRequestPostProcessor;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TimeEntryIntegrationTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_timeentry_test";
  private static final String ORG_B_ID = "org_timeentry_test_b";

  @Autowired private MockMvc mockMvc;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;

  private String projectId;
  private String taskId;
  private String memberIdOwner;
  private String memberIdAdmin;
  private String memberIdMember;
  private String memberIdMember2;
  private String taskBId;

  @BeforeAll
  void provisionTenantsAndSeedData() throws Exception {
    // Provision tenant A with Pro plan
    provisioningService.provisionTenant(ORG_ID, "TimeEntry Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    // Provision tenant B with Pro plan
    provisioningService.provisionTenant(ORG_B_ID, "TimeEntry Test Org B");
    planSyncService.syncPlan(ORG_B_ID, "pro-plan");

    // Sync members for tenant A
    memberIdOwner = syncMember(ORG_ID, "user_te_owner", "te_owner@test.com", "TE Owner", "owner");
    memberIdAdmin = syncMember(ORG_ID, "user_te_admin", "te_admin@test.com", "TE Admin", "admin");
    memberIdMember =
        syncMember(ORG_ID, "user_te_member", "te_member@test.com", "TE Member", "member");
    memberIdMember2 =
        syncMember(ORG_ID, "user_te_member2", "te_member2@test.com", "TE Member2", "member");

    // Sync member for tenant B
    syncMember(ORG_B_ID, "user_te_tenant_b", "te_tenantb@test.com", "Tenant B User", "owner");

    // Create a project in tenant A (owner is auto-assigned as lead)
    var projectResult =
        mockMvc
            .perform(
                post("/api/projects")
                    .with(ownerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {"name": "TE Test Project", "description": "For time entry tests"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    projectId = extractIdFromLocation(projectResult);

    // Add admin, member, and member2 to the project
    mockMvc
        .perform(
            post("/api/projects/" + projectId + "/members")
                .with(ownerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {"memberId": "%s"}
                    """
                        .formatted(memberIdAdmin)))
        .andExpect(status().isCreated());

    mockMvc
        .perform(
            post("/api/projects/" + projectId + "/members")
                .with(ownerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {"memberId": "%s"}
                    """
                        .formatted(memberIdMember)))
        .andExpect(status().isCreated());

    mockMvc
        .perform(
            post("/api/projects/" + projectId + "/members")
                .with(ownerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {"memberId": "%s"}
                    """
                        .formatted(memberIdMember2)))
        .andExpect(status().isCreated());

    // Create a task in the project
    var taskResult =
        mockMvc
            .perform(
                post("/api/projects/" + projectId + "/tasks")
                    .with(ownerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {"title": "Time Entry Test Task", "priority": "HIGH"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    taskId = extractIdFromLocation(taskResult);

    // Create a project and task in tenant B
    var projectBResult =
        mockMvc
            .perform(
                post("/api/projects")
                    .with(tenantBOwnerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {"name": "Tenant B Project", "description": "B project"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    var projectBId = extractIdFromLocation(projectBResult);

    var taskBResult =
        mockMvc
            .perform(
                post("/api/projects/" + projectBId + "/tasks")
                    .with(tenantBOwnerJwt())
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {"title": "Tenant B Task"}
                        """))
            .andExpect(status().isCreated())
            .andReturn();
    taskBId = extractIdFromLocation(taskBResult);
  }

  @Test
  void shouldCreateTimeEntry() throws Exception {
    mockMvc
        .perform(
            post("/api/tasks/" + taskId + "/time-entries")
                .with(ownerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {
                      "date": "2026-02-10",
                      "durationMinutes": 90,
                      "billable": true,
                      "description": "Worked on feature"
                    }
                    """))
        .andExpect(status().isCreated())
        .andExpect(jsonPath("$.id").exists())
        .andExpect(jsonPath("$.taskId").value(taskId))
        .andExpect(jsonPath("$.memberId").value(memberIdOwner))
        .andExpect(jsonPath("$.memberName").value("TE Owner"))
        .andExpect(jsonPath("$.date").value("2026-02-10"))
        .andExpect(jsonPath("$.durationMinutes").value(90))
        .andExpect(jsonPath("$.billable").value(true))
        .andExpect(jsonPath("$.description").value("Worked on feature"))
        .andExpect(jsonPath("$.createdAt").exists())
        .andExpect(jsonPath("$.updatedAt").exists());
  }

  @Test
  void nonProjectMemberCannotCreateTimeEntry() throws Exception {
    mockMvc
        .perform(
            post("/api/tasks/" + taskId + "/time-entries")
                .with(tenantBOwnerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {
                      "date": "2026-02-10",
                      "durationMinutes": 60,
                      "billable": true
                    }
                    """))
        .andExpect(status().isNotFound());
  }

  @Test
  void timeEntriesAreIsolatedBetweenTenants() throws Exception {
    mockMvc
        .perform(
            post("/api/tasks/" + taskBId + "/time-entries")
                .with(tenantBOwnerJwt())
                .contentType(MediaType.APPLICATION_JSON)
                .content(
                    """
                    {
                      "date": "2026-02-10",
                      "durationMinutes": 120,
                      "billable": true,
                      "description": "Tenant B entry"
                    }
                    """))
        .andExpect(status().isCreated());

    mockMvc
        .perform(get("/api/tasks/" + taskBId + "/time-entries").with(ownerJwt()))
        .andExpect(status().isNotFound());
  }

  // --- Helpers ---

  private String createTimeEntry(
      JwtRequestPostProcessor jwt,
      String date,
      int durationMinutes,
      boolean billable,
      Integer rateCents,
      String description)
      throws Exception {
    var rateField = rateCents != null ? ", \"rateCents\": " + rateCents : "";
    var content =
        """
        {
          "date": "%s",
          "durationMinutes": %d,
          "billable": %s%s,
          "description": "%s"
        }
        """
            .formatted(date, durationMinutes, billable, rateField, description);

    var result =
        mockMvc
            .perform(
                post("/api/tasks/" + taskId + "/time-entries")
                    .with(jwt)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(content))
            .andExpect(status().isCreated())
            .andReturn();

    return JsonPath.read(result.getResponse().getContentAsString(), "$.id").toString();
  }

  private String extractIdFromLocation(MvcResult result) {
    String location = result.getResponse().getHeader("Location");
    return location.substring(location.lastIndexOf('/') + 1);
  }

  private String syncMember(
      String orgId, String clerkUserId, String email, String name, String orgRole)
      throws Exception {
    var result =
        mockMvc
            .perform(
                post("/internal/members/sync")
                    .header("X-API-KEY", API_KEY)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {
                          "clerkOrgId": "%s",
                          "clerkUserId": "%s",
                          "email": "%s",
                          "name": "%s",
                          "avatarUrl": null,
                          "orgRole": "%s"
                        }
                        """
                            .formatted(orgId, clerkUserId, email, name, orgRole)))
            .andExpect(status().isCreated())
            .andReturn();

    return JsonPath.read(result.getResponse().getContentAsString(), "$.memberId");
  }

  private JwtRequestPostProcessor ownerJwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_owner").claim("o", Map.of("id", ORG_ID, "rol", "owner")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
  }

  private JwtRequestPostProcessor adminJwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_admin").claim("o", Map.of("id", ORG_ID, "rol", "admin")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_ADMIN")));
  }

  private JwtRequestPostProcessor memberJwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_member").claim("o", Map.of("id", ORG_ID, "rol", "member")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_MEMBER")));
  }

  private JwtRequestPostProcessor member2Jwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_member2").claim("o", Map.of("id", ORG_ID, "rol", "member")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_MEMBER")));
  }

  private JwtRequestPostProcessor tenantBOwnerJwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_tenant_b").claim("o", Map.of("id", ORG_B_ID, "rol", "owner")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
  }
}
```

## Integration Points

### ProjectAccessService (`member/ProjectAccessService.java`)
```java
// Key methods:
ProjectAccess checkAccess(UUID projectId, UUID memberId, String orgRole)
ProjectAccess requireViewAccess(UUID projectId, UUID memberId, String orgRole) // throws ResourceNotFoundException
ProjectAccess requireEditAccess(UUID projectId, UUID memberId, String orgRole) // throws ForbiddenException
```

### ProjectAccess Record (`member/ProjectAccess.java`)
```java
public record ProjectAccess(
    boolean canView,
    boolean canEdit,
    boolean canManageMembers,
    boolean canDelete,
    String projectRole) {
  public static final ProjectAccess DENIED = new ProjectAccess(false, false, false, false, null);
}
```

**Role mapping:**
- Owner: `canView=true, canEdit=true, canManageMembers=true, canDelete=true`
- Admin: `canView=true, canEdit=true, canManageMembers=true, canDelete=false`
- Lead (project role): `canView=true, canEdit=true, canManageMembers=true, canDelete=false`
- Member (project role): `canView=true, canEdit=false, canManageMembers=false, canDelete=false`

**IMPORTANT**: `canEdit()` is true for lead, admin, AND owner. To distinguish admin/owner from lead (for "edit/delete others' comments"), check org role directly:
```java
boolean isOrgAdminOrOwner = Roles.ORG_ADMIN.equals(orgRole) || Roles.ORG_OWNER.equals(orgRole);
```

### AuditService (`audit/AuditService.java`)
```java
public interface AuditService {
  void log(AuditEventRecord record);
  Page<AuditEvent> findEvents(AuditEventFilter filter, Pageable pageable);
  List<AuditEventRepository.EventTypeCount> countEventsByType();
}
```

### AuditEventBuilder (`audit/AuditEventBuilder.java`)
```java
// Usage pattern:
auditService.log(
    AuditEventBuilder.builder()
        .eventType("comment.created")
        .entityType("comment")
        .entityId(comment.getId())
        .details(Map.of("body", body, "project_id", projectId.toString(), "entity_type", entityType))
        .build());
```
Auto-populates: `actorId` (from `RequestScopes.MEMBER_ID`), `actorType` ("USER"/"SYSTEM"), `source` ("API"/"INTERNAL"), `ipAddress`, `userAgent`.

### RequestScopes (`multitenancy/RequestScopes.java`)
```java
public static UUID requireMemberId()    // throws if not bound
public static String requireOrgId()     // throws if not bound
public static String getOrgRole()       // returns null if not bound
// ScopedValues:
public static final ScopedValue<String> TENANT_ID = ScopedValue.newInstance();
public static final ScopedValue<UUID> MEMBER_ID = ScopedValue.newInstance();
public static final ScopedValue<String> ORG_ROLE = ScopedValue.newInstance();
```

### ApplicationEventPublisher (Spring)
```java
// Injected via constructor:
private final ApplicationEventPublisher eventPublisher;

// Usage:
eventPublisher.publishEvent(new CommentCreatedEvent(
    "comment.created",
    "comment",
    comment.getId(),
    comment.getProjectId(),
    memberId,
    actorName,
    RequestScopes.TENANT_ID.isBound() ? RequestScopes.TENANT_ID.get() : null,
    Instant.now(),
    Map.of("body", body),
    entityType,
    entityId,
    visibility));
```

### MemberRepository (`member/MemberRepository.java`)
```java
public interface MemberRepository extends JpaRepository<Member, UUID> {
  Optional<Member> findByClerkUserId(String clerkUserId);
  void deleteByClerkUserId(String clerkUserId);
  boolean existsByClerkUserId(String clerkUserId);
}
// Inherited from JpaRepository: findAllById(Iterable<UUID> ids), findById(UUID id)
```

### Member Entity (key fields for name resolution)
```java
public UUID getId()
public String getName()
public String getAvatarUrl()
```

### TaskRepository (for entity existence check)
```java
@Query("SELECT t FROM Task t WHERE t.id = :id")
Optional<Task> findOneById(@Param("id") UUID id);
```

### DocumentRepository (for entity existence check)
```java
@Query("SELECT d FROM Document d WHERE d.id = :id")
Optional<Document> findOneById(@Param("id") UUID id);
```

### Roles Constants (`security/Roles.java`)
```java
public static final String ORG_OWNER = "owner";
public static final String ORG_ADMIN = "admin";
public static final String ORG_MEMBER = "member";
public static final String PROJECT_LEAD = "lead";
public static final String PROJECT_MEMBER = "member";
```

### Exception Classes (`exception/` package)
```java
// 404 — "not found" or security-by-obscurity for access denied
new ResourceNotFoundException("Comment", commentId)

// 403 — authenticated but insufficient permissions
new ForbiddenException("Cannot update comment", "You do not have permission to update comment " + commentId)

// 400 — invalid state or bad request
new InvalidStateException("Invalid entity type", "entityType must be TASK or DOCUMENT")
```

## Conventions

### Key Conventions (from backend/CLAUDE.md)

- Base package: `io.b2mash.b2b.b2bstrawman`
- Organize by **feature**, not by layer. Entity, repository, service, controller all in `comment/` package.
- Use Java records for DTOs, request/response objects — nested inside controller class.
- Prefer constructor injection (no `@Autowired`).
- Use `@PreAuthorize` annotations for role-based access control.
- Return `ResponseEntity` from controllers for explicit status codes.
- Use Spring's `ProblemDetail` (RFC 9457) for error responses.
- No Lombok.
- Services throw semantic exceptions from `exception/` package.
- Controllers are pure delegation with no error mapping.
- Use `RequestScopes.requireMemberId()` and `RequestScopes.getOrgRole()` in controllers.
- JPQL `findOneById()` required instead of `findById()` for Hibernate `@Filter` compliance.

### Anti-Patterns — NEVER Do This (VERBATIM from backend/CLAUDE.md)

- Never use `@Autowired` on fields — use constructor injection
- Never use Lombok — Java 25 records and pattern matching cover all cases
- Never trust client headers for tenant resolution — always derive from validated JWT
- Never use `org.springframework.boot.orm.jpa.HibernatePropertiesCustomizer` — it moved to `boot.hibernate.autoconfigure` in Spring Boot 4
- Never set `hibernate.multiTenancy` property — Hibernate 7 auto-detects from registered provider
- Never use `java -jar` for the Docker entry point — use `org.springframework.boot.loader.launch.JarLauncher`
- Never make `TestcontainersConfiguration` package-private — it must be `public` for `@Import` from subpackages
- Never use `@ActiveProfiles("local")` in tests — use `@ActiveProfiles("test")`. The "local" profile connects to Docker Compose Postgres. Tests must run against ephemeral Testcontainers only.
- Never use flat JWT claims (`org_id`, `org_role`) — Clerk JWT v2 nests org claims under `"o"`: `jwt.getClaim("o")` returns `Map<String, Object>` with keys `id`, `rol`, `slg`
- Never use `ThreadLocal` for request-scoped context — use `ScopedValue` via `RequestScopes` (guaranteed cleanup, virtual thread safe)
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first or accepting `NoSuchElementException`
- Never build `ProblemDetail` directly in controllers or services — throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" — throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers — use `RequestScopes.requireMemberId()` and the shared exception classes

### Spring Boot 4 / Hibernate 7 Gotchas

| Class | Old Package (Boot 3) | New Package (Boot 4) |
|-------|---------------------|---------------------|
| `HibernatePropertiesCustomizer` | `boot.orm.jpa` | `boot.hibernate.autoconfigure` |
| `AutoConfigureMockMvc` | `boot.test.autoconfigure.web.servlet` | `boot.webmvc.test.autoconfigure` |

### JWT Mocks in Tests (Clerk v2 format)
```java
private JwtRequestPostProcessor memberJwt() {
    return jwt()
        .jwt(j -> j.subject("user_member").claim("o", Map.of("id", ORG_ID, "rol", "member")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_MEMBER")));
}
```
**NOTE**: Spring Security Test `jwt()` mock does NOT invoke `ClerkJwtAuthenticationConverter` — set `.authorities()` explicitly.

### Integration Test Annotations
```java
@SpringBootTest
@AutoConfigureMockMvc  // from boot.webmvc.test.autoconfigure (NOT boot.test.autoconfigure.web.servlet)
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")  // NEVER "local"
@TestInstance(TestInstance.Lifecycle.PER_CLASS)  // Allows @BeforeAll on instance methods
```

### Multitenancy in Tests
```java
ScopedValue.where(RequestScopes.TENANT_ID, "tenant_test123").run(() -> {
    // perform operations — auto-cleans up when lambda exits
});
```

## ADR References

### ADR-034: Flat Comments with Threading-Ready Schema
- `parent_id` column exists but is ALWAYS NULL in Phase 6.5
- `CommentService.createComment()` does NOT accept a `parentId` parameter
- Frontend renders flat list ordered by `created_at ASC`
- Zero-migration path to threading later

### ADR-037: Comment Visibility Model
- Two-state enum: `INTERNAL` (default) / `SHARED`
- Any project member can create INTERNAL comments
- Only leads/admins/owners can set visibility to SHARED (`ProjectAccess.canEdit()`)
- Changing visibility is audited as `comment.visibility_changed`
- Default is INTERNAL — safe by default

## Build & Verify
All commands run from: cd /Users/rakheendama/Projects/2026/worktree-epic-59B/backend

**Step 1: Format**
  ./mvnw spotless:apply 2>&1 | tail -3

**Step 2: Silent full build (Pass 1)**
  ./mvnw clean verify -q > /tmp/mvn-epic-59B.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-59B.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-59B.log | head -20; fi; fi

**Step 3: Re-run ONLY failed tests with full output**
  ./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80

**Step 4: Silent re-verify after fixing**
  ./mvnw clean verify -q > /tmp/mvn-epic-59B.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-59B.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi

IMPORTANT: NEVER run ./mvnw clean verify without -q.

## Environment
- Postgres host: b2mash.local:5432
- LocalStack host: b2mash.local:4566
- Maven wrapper: ./mvnw from backend dir
