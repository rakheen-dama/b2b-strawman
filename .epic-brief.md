# Implementation Brief: Epic 57A — Portal Comments, Project Detail & Profile Endpoints

## Scope
Backend only

## Tasks

### 57.1 — Create PortalReadModelService
`customerbackend/service/PortalReadModelService.java`. `@Service`. Constructor injection of `PortalReadModelRepository`, `PortalContactRepository`, `CustomerRepository`. Methods:

- `getProjectDetail(UUID projectId, UUID customerId, String orgId)` — calls `readModelRepo.findProjectDetail()`, returns `PortalProjectView` or throws `ResourceNotFoundException`.
- `listProjectComments(UUID projectId, UUID customerId, String orgId)` — verifies customer linked to project via `readModelRepo.findProjectDetail()` (if no portal_project for this customer, they are not linked → 404), returns `readModelRepo.findCommentsByProject()`.
- `getProjectSummary(UUID projectId, UUID customerId, String orgId)` — verifies customer linked, returns `readModelRepo.findProjectSummary()` or empty stub.
- `getContactProfile(UUID customerId, String orgId)` — load `PortalContact` by customerId+orgId via `portalContactRepository.findByCustomerIdAndOrgId()`, load `Customer` by customerId via `customerRepository.findOneById()`, return contact details + customer name. Throw `ResourceNotFoundException` if not found.
- All `@Transactional(readOnly = true)`.

**Acceptance criteria:** All public methods have `@Transactional(readOnly = true)`. Access checks: customer must be linked to the project (verified via portal read-model existence). Constructor injection only.

### 57.2 — Add project detail endpoint to PortalProjectController
Modify `portal/PortalProjectController.java`. Add `GET /portal/projects/{id}`. Implementation:
```
UUID customerId = RequestScopes.requireCustomerId();
String orgId = RequestScopes.requireOrgId();
var project = portalReadModelService.getProjectDetail(id, customerId, orgId);
```
Return `PortalProjectDetailResponse(UUID id, String name, String status, String description, int documentCount, int commentCount, Instant createdAt)`. Inject `PortalReadModelService` alongside existing `PortalQueryService`.

**Acceptance criteria:** Returns 200 with correct fields, 404 if project not linked to customer, existing `GET /portal/projects` endpoint unchanged.

### 57.3 — Create PortalCommentController
`customerbackend/controller/PortalCommentController.java`. `@RestController`, `@RequestMapping("/portal/projects/{projectId}/comments")`. `GET` — reads `RequestScopes.requireCustomerId()` and `requireOrgId()`, calls `portalReadModelService.listProjectComments()`, maps to `PortalCommentResponse(UUID id, String authorName, String content, Instant createdAt)`.

**Acceptance criteria:** Returns 200 with list of comments, empty list for projects with no comments, 404 for projects not linked to customer.

### 57.4 — Create PortalProfileController
`customerbackend/controller/PortalProfileController.java`. `@RestController`, `@RequestMapping("/portal/me")`. `GET /portal/me` — reads `RequestScopes.requireCustomerId()` and `requireOrgId()`, calls `portalReadModelService.getContactProfile()`, maps to `PortalProfileResponse(UUID contactId, UUID customerId, String customerName, String email, String displayName, String role)`.

**Acceptance criteria:** Returns 200 with contact details + customer name, 401 for unauthenticated requests.

### 57.5 — Add integration tests
- `customerbackend/controller/PortalCommentControllerTest.java` (~5 tests): list comments for project with data, list comments for project with no comments (empty list), list comments for project not linked to customer (404), unauthenticated request returns 401, comments sorted by createdAt DESC.
- `customerbackend/controller/PortalProfileControllerTest.java` (~3 tests): get profile returns contact details, profile includes customer name, unauthenticated request returns 401.
- `portal/PortalProjectControllerTest.java` (~3 tests): get project detail returns correct fields, get project detail for unlinked project returns 404, project detail includes document and comment counts.
- **Total: ~11 tests.**
- **Seed data**: provision tenant, create customer, PortalContact, link to project, insert test data into portal schema via `PortalReadModelRepository` directly.

## File Plan

### Create
1. `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/service/PortalReadModelService.java`
2. `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/controller/PortalCommentController.java`
3. `backend/src/main/java/io/b2mash/b2b/b2bstrawman/customerbackend/controller/PortalProfileController.java`
4. `backend/src/test/java/io/b2mash/b2b/b2bstrawman/customerbackend/controller/PortalCommentControllerTest.java`
5. `backend/src/test/java/io/b2mash/b2b/b2bstrawman/customerbackend/controller/PortalProfileControllerTest.java`
6. `backend/src/test/java/io/b2mash/b2b/b2bstrawman/portal/PortalProjectControllerTest.java`

### Modify
1. `backend/src/main/java/io/b2mash/b2b/b2bstrawman/portal/PortalProjectController.java` — Add `GET /portal/projects/{id}` detail endpoint, inject `PortalReadModelService`

## Reference Patterns

### PortalProjectController (from `backend/src/main/java/.../portal/PortalProjectController.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import java.time.Instant;
import java.util.List;
import java.util.UUID;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Portal project endpoints. Lists projects linked to the authenticated customer. All endpoints are
 * read-only and require a valid portal JWT (enforced by CustomerAuthFilter).
 */
@RestController
@RequestMapping("/portal/projects")
public class PortalProjectController {

  private final PortalQueryService portalQueryService;

  public PortalProjectController(PortalQueryService portalQueryService) {
    this.portalQueryService = portalQueryService;
  }

  /** Lists projects linked to the authenticated customer. */
  @GetMapping
  public ResponseEntity<List<PortalProjectResponse>> listProjects() {
    UUID customerId = RequestScopes.requireCustomerId();
    var projects = portalQueryService.listCustomerProjects(customerId);

    var response =
        projects.stream()
            .map(
                p ->
                    new PortalProjectResponse(
                        p.getId(),
                        p.getName(),
                        p.getDescription(),
                        portalQueryService.countSharedProjectDocuments(p.getId()),
                        p.getCreatedAt()))
            .toList();

    return ResponseEntity.ok(response);
  }

  public record PortalProjectResponse(
      UUID id, String name, String description, long documentCount, Instant createdAt) {}
}
```

### PortalDocumentController — existing portal controller pattern (from `backend/src/main/java/.../portal/PortalDocumentController.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.document.Document;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import java.time.Instant;
import java.util.List;
import java.util.UUID;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/portal")
public class PortalDocumentController {

  private final PortalQueryService portalQueryService;

  public PortalDocumentController(PortalQueryService portalQueryService) {
    this.portalQueryService = portalQueryService;
  }

  @GetMapping("/projects/{projectId}/documents")
  public ResponseEntity<List<PortalDocumentResponse>> listProjectDocuments(
      @PathVariable UUID projectId) {
    UUID customerId = RequestScopes.requireCustomerId();
    var documents = portalQueryService.listProjectDocuments(projectId, customerId);
    var response = documents.stream().map(PortalDocumentResponse::from).toList();
    return ResponseEntity.ok(response);
  }

  @GetMapping("/documents")
  public ResponseEntity<List<PortalDocumentResponse>> listCustomerDocuments() {
    UUID customerId = RequestScopes.requireCustomerId();
    var documents = portalQueryService.listCustomerDocuments(customerId);
    var response = documents.stream().map(PortalDocumentResponse::from).toList();
    return ResponseEntity.ok(response);
  }

  @GetMapping("/documents/{documentId}/presign-download")
  public ResponseEntity<PortalPresignDownloadResponse> presignDownload(
      @PathVariable UUID documentId) {
    UUID customerId = RequestScopes.requireCustomerId();
    var result = portalQueryService.getPresignedDownloadUrl(documentId, customerId);
    return ResponseEntity.ok(
        new PortalPresignDownloadResponse(result.url(), result.expiresInSeconds()));
  }

  public record PortalDocumentResponse(
      UUID id,
      String fileName,
      String contentType,
      long size,
      String scope,
      String status,
      Instant createdAt) {

    public static PortalDocumentResponse from(Document document) {
      return new PortalDocumentResponse(
          document.getId(),
          document.getFileName(),
          document.getContentType(),
          document.getSize(),
          document.getScope(),
          document.getStatus().name(),
          document.getCreatedAt());
    }
  }

  public record PortalPresignDownloadResponse(String presignedUrl, long expiresInSeconds) {}
}
```

### RequestScopes (from `backend/src/main/java/.../multitenancy/RequestScopes.java`)
```java
package io.b2mash.b2b.b2bstrawman.multitenancy;

import io.b2mash.b2b.b2bstrawman.exception.MissingOrganizationContextException;
import java.util.UUID;

public final class RequestScopes {

  public static final ScopedValue<String> TENANT_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> MEMBER_ID = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ROLE = ScopedValue.newInstance();
  public static final ScopedValue<String> ORG_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> CUSTOMER_ID = ScopedValue.newInstance();
  public static final ScopedValue<UUID> PORTAL_CONTACT_ID = ScopedValue.newInstance();
  public static final String DEFAULT_TENANT = "public";

  public static UUID requireMemberId() {
    if (!MEMBER_ID.isBound()) {
      throw new MemberContextNotBoundException();
    }
    return MEMBER_ID.get();
  }

  public static String requireOrgId() {
    if (!ORG_ID.isBound()) {
      throw new MissingOrganizationContextException();
    }
    return ORG_ID.get();
  }

  public static String getOrgRole() {
    return ORG_ROLE.isBound() ? ORG_ROLE.get() : null;
  }

  public static UUID requireCustomerId() {
    if (!CUSTOMER_ID.isBound()) {
      throw new IllegalStateException("Customer context not available — CUSTOMER_ID not bound");
    }
    return CUSTOMER_ID.get();
  }

  public static UUID requirePortalContactId() {
    if (!PORTAL_CONTACT_ID.isBound()) {
      throw new IllegalStateException(
          "Portal contact context not available — PORTAL_CONTACT_ID not bound");
    }
    return PORTAL_CONTACT_ID.get();
  }

  private RequestScopes() {}
}
```

### PortalReadModelRepository — ALL methods (from `backend/src/main/java/.../customerbackend/repository/PortalReadModelRepository.java`)
```java
package io.b2mash.b2b.b2bstrawman.customerbackend.repository;

import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalCommentView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalDocumentView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalProjectSummaryView;
import io.b2mash.b2b.b2bstrawman.customerbackend.model.PortalProjectView;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.simple.JdbcClient;
import org.springframework.stereotype.Repository;

@Repository
public class PortalReadModelRepository {

  private final JdbcClient jdbc;

  public PortalReadModelRepository(@Qualifier("portalJdbcClient") JdbcClient jdbc) {
    this.jdbc = jdbc;
  }

  private static Timestamp toTimestamp(Instant instant) {
    return instant != null ? Timestamp.from(instant) : null;
  }

  // ── Upsert methods ──────────────────────────────────────────────────

  public void upsertPortalProject(
      UUID projectId,
      UUID customerId,
      String orgId,
      String name,
      String status,
      String description,
      Instant createdAt) {
    jdbc.sql(
            """
            INSERT INTO portal.portal_projects
                (id, customer_id, org_id, name, status, description, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, now())
            ON CONFLICT (id, customer_id)
            DO UPDATE SET name = EXCLUDED.name,
                          status = EXCLUDED.status,
                          description = EXCLUDED.description,
                          updated_at = now()
            """)
        .params(projectId, customerId, orgId, name, status, description, toTimestamp(createdAt))
        .update();
  }

  public void upsertPortalDocument(
      UUID documentId,
      String orgId,
      UUID customerId,
      UUID portalProjectId,
      String title,
      String contentType,
      Long size,
      String scope,
      String s3Key,
      Instant uploadedAt) {
    jdbc.sql(
            """
            INSERT INTO portal.portal_documents
                (id, org_id, customer_id, portal_project_id, title, content_type,
                 size, scope, s3_key, uploaded_at, synced_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, now())
            ON CONFLICT (id)
            DO UPDATE SET title = EXCLUDED.title,
                          content_type = EXCLUDED.content_type,
                          size = EXCLUDED.size,
                          scope = EXCLUDED.scope,
                          s3_key = EXCLUDED.s3_key,
                          synced_at = now()
            """)
        .params(
            documentId, orgId, customerId, portalProjectId, title, contentType,
            size, scope, s3Key, toTimestamp(uploadedAt))
        .update();
  }

  public void upsertPortalComment(
      UUID commentId,
      String orgId,
      UUID portalProjectId,
      String authorName,
      String content,
      Instant createdAt) {
    jdbc.sql(
            """
            INSERT INTO portal.portal_comments
                (id, org_id, portal_project_id, author_name, content, created_at, synced_at)
            VALUES (?, ?, ?, ?, ?, ?, now())
            ON CONFLICT (id)
            DO UPDATE SET author_name = EXCLUDED.author_name,
                          content = EXCLUDED.content,
                          synced_at = now()
            """)
        .params(commentId, orgId, portalProjectId, authorName, content, toTimestamp(createdAt))
        .update();
  }

  public void upsertPortalProjectSummary(
      UUID projectId,
      UUID customerId,
      String orgId,
      BigDecimal totalHours,
      BigDecimal billableHours,
      Instant lastActivityAt) {
    jdbc.sql(
            """
            INSERT INTO portal.portal_project_summaries
                (id, customer_id, org_id, total_hours, billable_hours, last_activity_at, synced_at)
            VALUES (?, ?, ?, ?, ?, ?, now())
            ON CONFLICT (id, customer_id)
            DO UPDATE SET total_hours = EXCLUDED.total_hours,
                          billable_hours = EXCLUDED.billable_hours,
                          last_activity_at = EXCLUDED.last_activity_at,
                          synced_at = now()
            """)
        .params(projectId, customerId, orgId, totalHours, billableHours, toTimestamp(lastActivityAt))
        .update();
  }

  public void updatePortalProjectDetails(
      UUID projectId, UUID customerId, String name, String status, String description) {
    jdbc.sql(
            """
            UPDATE portal.portal_projects
            SET name = ?, status = ?, description = ?, updated_at = now()
            WHERE id = ? AND customer_id = ?
            """)
        .params(name, status, description, projectId, customerId)
        .update();
  }

  // ── Delete methods ──────────────────────────────────────────────────

  public void deletePortalProject(UUID projectId, UUID customerId) {
    jdbc.sql("DELETE FROM portal.portal_projects WHERE id = ? AND customer_id = ?")
        .params(projectId, customerId).update();
  }

  public void deletePortalDocument(UUID documentId, String orgId) {
    jdbc.sql("DELETE FROM portal.portal_documents WHERE id = ? AND org_id = ?")
        .params(documentId, orgId).update();
  }

  public void deletePortalComment(UUID commentId, String orgId) {
    jdbc.sql("DELETE FROM portal.portal_comments WHERE id = ? AND org_id = ?")
        .params(commentId, orgId).update();
  }

  public void deletePortalProjectsByOrg(String orgId) {
    jdbc.sql("DELETE FROM portal.portal_projects WHERE org_id = ?").params(orgId).update();
  }

  public void deletePortalDocumentsByOrg(String orgId) {
    jdbc.sql("DELETE FROM portal.portal_documents WHERE org_id = ?").params(orgId).update();
  }

  public void deletePortalCommentsByOrg(String orgId) {
    jdbc.sql("DELETE FROM portal.portal_comments WHERE org_id = ?").params(orgId).update();
  }

  public void deletePortalProjectSummariesByOrg(String orgId) {
    jdbc.sql("DELETE FROM portal.portal_project_summaries WHERE org_id = ?").params(orgId).update();
  }

  // ── Count update methods ────────────────────────────────────────────

  public void setDocumentCount(UUID projectId, UUID customerId, int count) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET document_count = ?, updated_at = now()
        WHERE id = ? AND customer_id = ?
        """).params(count, projectId, customerId).update();
  }

  public void incrementDocumentCount(UUID projectId, UUID customerId) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET document_count = document_count + 1, updated_at = now()
        WHERE id = ? AND customer_id = ?
        """).params(projectId, customerId).update();
  }

  public void decrementDocumentCount(UUID projectId, UUID customerId) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET document_count = GREATEST(document_count - 1, 0), updated_at = now()
        WHERE id = ? AND customer_id = ?
        """).params(projectId, customerId).update();
  }

  public void incrementCommentCount(UUID projectId, UUID customerId) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET comment_count = comment_count + 1, updated_at = now()
        WHERE id = ? AND customer_id = ?
        """).params(projectId, customerId).update();
  }

  public void decrementCommentCount(UUID projectId, UUID customerId) {
    jdbc.sql("""
        UPDATE portal.portal_projects
        SET comment_count = GREATEST(comment_count - 1, 0), updated_at = now()
        WHERE id = ? AND customer_id = ?
        """).params(projectId, customerId).update();
  }

  // ── Lookup methods ──────────────────────────────────────────────────

  public Optional<PortalDocumentView> findPortalDocumentById(UUID documentId, String orgId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, portal_project_id, title, content_type,
               size, scope, s3_key, uploaded_at, synced_at
        FROM portal.portal_documents WHERE id = ? AND org_id = ?
        """).params(documentId, orgId).query(PortalDocumentView.class).optional();
  }

  public List<UUID> findCustomerIdsByProjectId(UUID projectId, String orgId) {
    return jdbc.sql("""
        SELECT customer_id FROM portal.portal_projects WHERE id = ? AND org_id = ?
        """).params(projectId, orgId)
        .query((rs, rowNum) -> rs.getObject("customer_id", UUID.class)).list();
  }

  // ── Query methods ───────────────────────────────────────────────────

  public List<PortalProjectView> findProjectsByCustomer(String orgId, UUID customerId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, name, status, description,
               document_count, comment_count, created_at, updated_at
        FROM portal.portal_projects
        WHERE org_id = ? AND customer_id = ?
        ORDER BY created_at DESC
        """).params(orgId, customerId).query(PortalProjectView.class).list();
  }

  public Optional<PortalProjectView> findProjectDetail(
      UUID projectId, UUID customerId, String orgId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, name, status, description,
               document_count, comment_count, created_at, updated_at
        FROM portal.portal_projects
        WHERE id = ? AND customer_id = ? AND org_id = ?
        """).params(projectId, customerId, orgId).query(PortalProjectView.class).optional();
  }

  public List<PortalDocumentView> findDocumentsByProject(UUID portalProjectId, String orgId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, portal_project_id, title, content_type,
               size, scope, s3_key, uploaded_at, synced_at
        FROM portal.portal_documents
        WHERE portal_project_id = ? AND org_id = ?
        ORDER BY uploaded_at DESC
        """).params(portalProjectId, orgId).query(PortalDocumentView.class).list();
  }

  public List<PortalDocumentView> findDocumentsByCustomer(String orgId, UUID customerId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, portal_project_id, title, content_type,
               size, scope, s3_key, uploaded_at, synced_at
        FROM portal.portal_documents
        WHERE org_id = ? AND customer_id = ?
        ORDER BY uploaded_at DESC
        """).params(orgId, customerId).query(PortalDocumentView.class).list();
  }

  public List<PortalCommentView> findCommentsByProject(UUID portalProjectId, String orgId) {
    return jdbc.sql("""
        SELECT id, org_id, portal_project_id, author_name, content, created_at, synced_at
        FROM portal.portal_comments
        WHERE portal_project_id = ? AND org_id = ?
        ORDER BY created_at DESC
        """).params(portalProjectId, orgId).query(PortalCommentView.class).list();
  }

  public Optional<PortalProjectSummaryView> findProjectSummary(
      UUID projectId, UUID customerId, String orgId) {
    return jdbc.sql("""
        SELECT id, org_id, customer_id, total_hours, billable_hours,
               last_activity_at, synced_at
        FROM portal.portal_project_summaries
        WHERE id = ? AND customer_id = ? AND org_id = ?
        """).params(projectId, customerId, orgId)
        .query(PortalProjectSummaryView.class).optional();
  }
}
```

### View Records (from `backend/src/main/java/.../customerbackend/model/`)

**PortalProjectView.java:**
```java
package io.b2mash.b2b.b2bstrawman.customerbackend.model;

import java.time.Instant;
import java.util.UUID;

public record PortalProjectView(
    UUID id,
    String orgId,
    UUID customerId,
    String name,
    String status,
    String description,
    int documentCount,
    int commentCount,
    Instant createdAt,
    Instant updatedAt) {}
```

**PortalCommentView.java:**
```java
package io.b2mash.b2b.b2bstrawman.customerbackend.model;

import java.time.Instant;
import java.util.UUID;

public record PortalCommentView(
    UUID id,
    String orgId,
    UUID portalProjectId,
    String authorName,
    String content,
    Instant createdAt,
    Instant syncedAt) {}
```

**PortalProjectSummaryView.java:**
```java
package io.b2mash.b2b.b2bstrawman.customerbackend.model;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

public record PortalProjectSummaryView(
    UUID id,
    String orgId,
    UUID customerId,
    BigDecimal totalHours,
    BigDecimal billableHours,
    Instant lastActivityAt,
    Instant syncedAt) {}
```

### CustomerAuthFilter — how portal auth works (from `backend/src/main/java/.../portal/CustomerAuthFilter.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.multitenancy.ScopedFilterChain;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantInfo;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class CustomerAuthFilter extends OncePerRequestFilter {

  private static final Logger log = LoggerFactory.getLogger(CustomerAuthFilter.class);
  private static final String BEARER_PREFIX = "Bearer ";

  private final PortalJwtService portalJwtService;
  private final OrgSchemaMappingRepository mappingRepository;
  private final PortalContactRepository portalContactRepository;

  public CustomerAuthFilter(
      PortalJwtService portalJwtService,
      OrgSchemaMappingRepository mappingRepository,
      PortalContactRepository portalContactRepository) {
    this.portalJwtService = portalJwtService;
    this.mappingRepository = mappingRepository;
    this.portalContactRepository = portalContactRepository;
  }

  @Override
  protected void doFilterInternal(
      HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {

    String authHeader = request.getHeader("Authorization");
    if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing or invalid Authorization");
      return;
    }

    String token = authHeader.substring(BEARER_PREFIX.length());
    PortalJwtService.PortalClaims claims;
    try {
      claims = portalJwtService.verifyToken(token);
    } catch (PortalAuthException e) {
      log.debug("Portal auth failed: {}", e.getMessage());
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
      return;
    }

    TenantInfo tenantInfo =
        mappingRepository.findTenantInfoByClerkOrgId(claims.clerkOrgId()).orElse(null);
    if (tenantInfo == null) {
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Organization not provisioned");
      return;
    }

    // Bind scoped values: CUSTOMER_ID, TENANT_ID, ORG_ID
    var carrier =
        ScopedValue.where(RequestScopes.CUSTOMER_ID, claims.customerId())
            .where(RequestScopes.TENANT_ID, tenantInfo.schemaName())
            .where(RequestScopes.ORG_ID, claims.clerkOrgId());

    // Attempt to resolve PortalContact and bind PORTAL_CONTACT_ID (backward compatible)
    try {
      var contact =
          ScopedValue.where(RequestScopes.TENANT_ID, tenantInfo.schemaName())
              .call(
                  () ->
                      portalContactRepository
                          .findByCustomerIdAndOrgId(claims.customerId(), claims.clerkOrgId())
                          .orElse(null));
      if (contact != null) {
        carrier = carrier.where(RequestScopes.PORTAL_CONTACT_ID, contact.getId());
      }
    } catch (Exception e) {
      log.warn(
          "Could not resolve portal contact for customer {}: {}",
          claims.customerId(), e.getMessage());
    }

    ScopedFilterChain.runScoped(carrier, filterChain, request, response);
  }

  @Override
  protected boolean shouldNotFilter(HttpServletRequest request) {
    String path = request.getRequestURI();
    if (!path.startsWith("/portal/")) {
      return true;
    }
    return path.startsWith("/portal/auth/");
  }
}
```

### PortalContact entity (from `backend/src/main/java/.../portal/PortalContact.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.*;
import java.time.Instant;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "portal_contacts")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class PortalContact implements TenantAware {

  public enum ContactRole { PRIMARY, BILLING, GENERAL }
  public enum ContactStatus { ACTIVE, SUSPENDED, ARCHIVED }

  @Id @GeneratedValue(strategy = GenerationType.UUID) private UUID id;
  @Column(name = "org_id", nullable = false, length = 255) private String orgId;
  @Column(name = "customer_id", nullable = false) private UUID customerId;
  @Column(name = "email", nullable = false, length = 255) private String email;
  @Column(name = "display_name", length = 255) private String displayName;
  @Enumerated(EnumType.STRING) @Column(name = "role", nullable = false, length = 20) private ContactRole role;
  @Enumerated(EnumType.STRING) @Column(name = "status", nullable = false, length = 20) private ContactStatus status;
  @Column(name = "tenant_id") private String tenantId;
  @Column(name = "created_at", nullable = false, updatable = false) private Instant createdAt;
  @Column(name = "updated_at", nullable = false) private Instant updatedAt;

  protected PortalContact() {}

  public PortalContact(String orgId, UUID customerId, String email, String displayName, ContactRole role) {
    this.orgId = orgId; this.customerId = customerId; this.email = email;
    this.displayName = displayName; this.role = role != null ? role : ContactRole.GENERAL;
    this.status = ContactStatus.ACTIVE; this.createdAt = Instant.now(); this.updatedAt = Instant.now();
  }

  // Getters: getId(), getOrgId(), getCustomerId(), getEmail(), getDisplayName(), getRole(), getStatus()
  public UUID getId() { return id; }
  public String getOrgId() { return orgId; }
  public UUID getCustomerId() { return customerId; }
  public String getEmail() { return email; }
  public String getDisplayName() { return displayName; }
  public ContactRole getRole() { return role; }
  public ContactStatus getStatus() { return status; }
  @Override public String getTenantId() { return tenantId; }
  @Override public void setTenantId(String tenantId) { this.tenantId = tenantId; }
  public Instant getCreatedAt() { return createdAt; }
  public Instant getUpdatedAt() { return updatedAt; }
}
```

### PortalContactRepository (from `backend/src/main/java/.../portal/PortalContactRepository.java`)
```java
package io.b2mash.b2b.b2bstrawman.portal;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PortalContactRepository extends JpaRepository<PortalContact, UUID> {

  @Query("SELECT pc FROM PortalContact pc WHERE pc.id = :id")
  Optional<PortalContact> findOneById(@Param("id") UUID id);

  @Query("SELECT pc FROM PortalContact pc WHERE pc.email = :email AND pc.orgId = :orgId")
  Optional<PortalContact> findByEmailAndOrgId(
      @Param("email") String email, @Param("orgId") String orgId);

  @Query("SELECT pc FROM PortalContact pc WHERE pc.customerId = :customerId")
  List<PortalContact> findByCustomerId(@Param("customerId") UUID customerId);

  boolean existsByEmailAndCustomerId(String email, UUID customerId);

  @Query("SELECT pc FROM PortalContact pc WHERE pc.customerId = :customerId AND pc.orgId = :orgId")
  Optional<PortalContact> findByCustomerIdAndOrgId(
      @Param("customerId") UUID customerId, @Param("orgId") String orgId);
}
```

### Customer entity (from `backend/src/main/java/.../customer/Customer.java`) — needed for profile endpoint
```java
// Key fields and methods for profile endpoint:
// getName() -> String
// getEmail() -> String
// getId() -> UUID
// getStatus() -> String ("ACTIVE", "ARCHIVED")
```

### CustomerRepository (from `backend/src/main/java/.../customer/CustomerRepository.java`)
```java
package io.b2mash.b2b.b2bstrawman.customer;

import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface CustomerRepository extends JpaRepository<Customer, UUID> {

  @Query("SELECT c FROM Customer c WHERE c.id = :id")
  Optional<Customer> findOneById(@Param("id") UUID id);

  Optional<Customer> findByEmail(String email);
  boolean existsByEmail(String email);
}
```

### ResourceNotFoundException (from `backend/src/main/java/.../exception/ResourceNotFoundException.java`)
```java
package io.b2mash.b2b.b2bstrawman.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.ErrorResponseException;

public class ResourceNotFoundException extends ErrorResponseException {

  public ResourceNotFoundException(String resourceType, Object id) {
    super(
        HttpStatus.NOT_FOUND,
        createProblem(
            resourceType + " not found",
            "No " + resourceType.toLowerCase() + " found with id " + id),
        null);
  }

  public static ResourceNotFoundException withDetail(String title, String detail) {
    return new ResourceNotFoundException(title, detail, HttpStatus.NOT_FOUND);
  }

  private ResourceNotFoundException(String title, String detail, HttpStatus status) {
    super(status, createProblem(title, detail), null);
  }

  private static ProblemDetail createProblem(String title, String detail) {
    var problem = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
    problem.setTitle(title);
    problem.setDetail(detail);
    return problem;
  }
}
```

### SecurityConfig — portal filter chain (from `backend/src/main/java/.../security/SecurityConfig.java`)
```java
@Bean
@Order(1)
public SecurityFilterChain portalFilterChain(HttpSecurity http) throws Exception {
  http.securityMatcher("/portal/**")
      .csrf(csrf -> csrf.disable())
      .sessionManagement(
          session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .authorizeHttpRequests(
          auth ->
              auth.requestMatchers("/portal/auth/**")
                  .permitAll()
                  .requestMatchers("/portal/**")
                  .permitAll())
      .addFilterBefore(customerAuthFilter, UsernamePasswordAuthenticationFilter.class);

  return http.build();
}
```
**IMPORTANT:** Portal endpoints under `/portal/**` are `permitAll()` in Spring Security. The `CustomerAuthFilter` handles actual authentication (extracts portal JWT, binds ScopedValues). New `/portal/projects/{id}/comments`, `/portal/me` etc. are automatically covered by the existing `securityMatcher("/portal/**")` and `CustomerAuthFilter`.

### PortalJwtService (from `backend/src/main/java/.../portal/PortalJwtService.java`)
```java
// Key methods for test setup:
public String issueToken(UUID customerId, String clerkOrgId)  // Issues 1-hour portal JWT
public PortalClaims verifyToken(String token)                  // Returns PortalClaims(customerId, clerkOrgId)
public record PortalClaims(UUID customerId, String clerkOrgId) {}
```

### Integration Test Pattern (from `backend/src/test/java/.../portal/PortalAuthIntegrationTest.java`)
```java
@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PortalAuthIntegrationTest {

  private static final String ORG_ID = "org_portal_test";
  private static final String API_KEY = "test-api-key";

  @Autowired private MockMvc mockMvc;
  @Autowired private MagicLinkService magicLinkService;
  @Autowired private PortalJwtService portalJwtService;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;
  @Autowired private CustomerService customerService;
  @Autowired private PortalContactService portalContactService;
  @Autowired private OrgSchemaMappingRepository orgSchemaMappingRepository;

  private UUID customerId;
  private String tenantSchema;

  @BeforeAll
  void setup() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "Portal Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    // Sync a member via internal API
    var syncResult = mockMvc.perform(
        post("/internal/members/sync")
            .header("X-API-KEY", API_KEY)
            .contentType(MediaType.APPLICATION_JSON)
            .content("""
                {"clerkOrgId": "%s", "clerkUserId": "user_portal_owner",
                 "email": "portal_owner@test.com", "name": "Portal Owner",
                 "avatarUrl": null, "orgRole": "owner"}
                """.formatted(ORG_ID)))
        .andExpect(status().isCreated()).andReturn();

    String memberIdStr = JsonPath.read(syncResult.getResponse().getContentAsString(), "$.memberId");
    UUID memberId = UUID.fromString(memberIdStr);

    tenantSchema = orgSchemaMappingRepository.findByClerkOrgId(ORG_ID).get().getSchemaName();

    ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
        .where(RequestScopes.ORG_ID, ORG_ID)
        .run(() -> {
          var customer = customerService.createCustomer(
              "Portal Customer", "portal-customer@test.com", null, null, null, memberId);
          customerId = customer.getId();

          portalContactService.createContact(
              ORG_ID, customerId, "portal-genverify@test.com",
              "Gen Verify Contact", PortalContact.ContactRole.PRIMARY);
        });
  }

  // Test using portal JWT:
  @Test
  void authenticatedPortalEndpointsAcceptValidPortalJwt() throws Exception {
    String portalToken = portalJwtService.issueToken(customerId, ORG_ID);
    var result = mockMvc
        .perform(get("/portal/projects").header("Authorization", "Bearer " + portalToken))
        .andReturn();
    assertThat(result.getResponse().getStatus()).isNotEqualTo(401);
  }
}
```

### EventProjectionIntegrationTest — test helper patterns (from `backend/src/test/java/.../customerbackend/EventProjectionIntegrationTest.java`)
```java
// Key helpers for test setup via staff API:

private String createProject(String name, String description) throws Exception {
  var result = mockMvc.perform(
      post("/api/projects").with(ownerJwt())
          .contentType(MediaType.APPLICATION_JSON)
          .content("""{"name": "%s", "description": "%s"}""".formatted(name, description)))
      .andExpect(status().isCreated()).andReturn();
  return extractIdFromLocation(result);
}

private String createCustomer(String name, String email) throws Exception {
  var result = mockMvc.perform(
      post("/api/customers").with(ownerJwt())
          .contentType(MediaType.APPLICATION_JSON)
          .content("""{"name": "%s", "email": "%s"}""".formatted(name, email)))
      .andExpect(status().isCreated()).andReturn();
  return extractIdFromLocation(result);
}

private String extractIdFromLocation(MvcResult result) {
  String location = result.getResponse().getHeader("Location");
  return location.substring(location.lastIndexOf('/') + 1);
}

private JwtRequestPostProcessor ownerJwt() {
  return jwt()
      .jwt(j -> j.subject("user_ep_owner").claim("o", Map.of("id", ORG_ID, "rol", "owner")))
      .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
}
```

## Conventions

### Naming
- Base package: `io.b2mash.b2b.b2bstrawman`
- Entities: domain name (e.g., `Project`, `Document`) -- no `Entity` suffix
- Repositories: `*Repository` extending `JpaRepository`
- Services: `*Service`
- Controllers: `*Controller`
- DTOs: nested records inside the controller

### Code Style
- Use Java records for DTOs, request/response objects
- Prefer constructor injection (no `@Autowired` on fields)
- Return `ResponseEntity` from controllers for explicit status codes
- Use Spring's `ProblemDetail` (RFC 9457) for error responses
- No Lombok -- Java 25 records and pattern matching cover most use cases

### Anti-Patterns -- NEVER Do This
- Never use `@Autowired` on fields -- use constructor injection
- Never use Lombok
- Never use `@ActiveProfiles("local")` in tests -- use `@ActiveProfiles("test")`
- Never build `ProblemDetail` directly in controllers or services -- throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" -- throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers -- use `RequestScopes.requireMemberId()` and shared exception classes
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first
- Never use `findById()` for JPA repos with `@Filter` -- use JPQL `findOneById()` instead
- `AutoConfigureMockMvc` import: `org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc` (NOT `boot.test.autoconfigure.web.servlet`)

### Test Conventions
- `@SpringBootTest` + `@AutoConfigureMockMvc` + `@Import(TestcontainersConfiguration.class)` + `@ActiveProfiles("test")`
- `@TestInstance(TestInstance.Lifecycle.PER_CLASS)` when using `@BeforeAll` non-static
- Portal auth: issue JWT via `portalJwtService.issueToken(customerId, orgId)`, pass as `Authorization: Bearer <token>`
- Staff auth: use `jwt()` post-processor with `.authorities()` set explicitly
- ScopedValue in tests: `ScopedValue.where(RequestScopes.TENANT_ID, schema).run(() -> { ... })`
- Provision tenant + sync plan in `@BeforeAll`: `provisioningService.provisionTenant(...)` + `planSyncService.syncPlan(orgId, "pro-plan")`

## Integration Points

### PortalReadModelService depends on:
- `PortalReadModelRepository` -- `findProjectDetail()`, `findCommentsByProject()`, `findProjectSummary()` (all querying portal schema)
- `PortalContactRepository` -- `findByCustomerIdAndOrgId()` (for profile endpoint, querying tenant schema)
- `CustomerRepository` -- `findOneById()` (for profile endpoint, querying tenant schema)

### Profile endpoint tenant context:
The `getContactProfile()` method queries JPA entities (`PortalContact`, `Customer`) which require tenant context. The `CustomerAuthFilter` binds `TENANT_ID` from the portal JWT's org claim. Since the method runs within a controller where `TENANT_ID` is already bound by the filter, Hibernate's tenant filter is active and will scope queries correctly. No manual `ScopedValue.where()` needed inside the service.

### Portal auth flow for all new endpoints:
1. Request hits `/portal/projects/{id}/comments`, `/portal/me`, or `/portal/projects/{id}`
2. `CustomerAuthFilter` extracts portal JWT, verifies via `PortalJwtService`, binds `CUSTOMER_ID`, `TENANT_ID`, `ORG_ID`, (optionally `PORTAL_CONTACT_ID`)
3. Controller reads `RequestScopes.requireCustomerId()` and `RequestScopes.requireOrgId()`
4. Service queries portal read-model schema (via `PortalReadModelRepository`) or tenant schema (via JPA repos)

### Response format (from architecture doc):

**GET /portal/projects/{id}:**
```json
{
  "id": "550e8400-...",
  "name": "Website Redesign",
  "status": "IN_PROGRESS",
  "description": "Full redesign of corporate website",
  "documentCount": 5,
  "commentCount": 3,
  "createdAt": "2026-01-15T10:00:00Z"
}
```

**GET /portal/projects/{id}/comments:**
```json
[
  {
    "id": "660e8400-...",
    "authorName": "Jane Doe",
    "content": "Draft v2 is ready for your review.",
    "createdAt": "2026-02-10T14:30:00Z"
  }
]
```

**GET /portal/me:**
```json
{
  "contactId": "770e8400-...",
  "customerId": "550e8400-...",
  "customerName": "Acme Corp",
  "email": "alice@acme.com",
  "displayName": "Alice Smith",
  "role": "PRIMARY"
}
```

## Test Data Seeding Strategy

For the 57A tests, seed data in `@BeforeAll`:

1. **Provision tenant**: `provisioningService.provisionTenant(ORG_ID, "...")` + `planSyncService.syncPlan(ORG_ID, "pro-plan")`
2. **Sync member**: POST `/internal/members/sync` with API key
3. **Create customer**: Use `CustomerService.createCustomer()` within tenant scope (or POST `/api/customers` via MockMvc)
4. **Create PortalContact**: Use `PortalContactService.createContact()` within tenant scope
5. **Seed portal read-model data**: Use `PortalReadModelRepository.upsertPortalProject()`, `upsertPortalComment()`, `upsertPortalProjectSummary()` directly -- these write to the portal schema and don't require tenant context
6. **Issue portal JWT**: `portalJwtService.issueToken(customerId, orgId)` -- use this for `Authorization: Bearer` header in test requests

**CRITICAL**: The portal read-model repository methods do NOT require tenant scoping (they use their own `JdbcClient` on the portal DataSource). Seed portal data directly via repo methods. However, `PortalContactRepository` and `CustomerRepository` queries DO require tenant scope -- wrap those in `ScopedValue.where(RequestScopes.TENANT_ID, schema).run(...)`.

## Build & Verify

All commands from: cd /Users/rakheendama/Projects/2026/worktree-epic-57A/backend

**Step 1: Format**
```bash
./mvnw spotless:apply 2>&1 | tail -3
```

**Step 2: Silent full build**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-57A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-57A.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-57A.log | head -20; fi; fi
```

**Step 3: Re-run failed tests (if any)**
```bash
./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80
```

**Step 4: Silent re-verify**
```bash
./mvnw clean verify -q > /tmp/mvn-epic-57A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-57A.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi
```

## Environment
- Postgres host: b2mash.local:5432
- Maven wrapper: ./mvnw from backend dir
- Java 25, Spring Boot 4.0.2
- spotless-maven-plugin 3.2.1+, google-java-format 1.28.0+
- `@ActiveProfiles("test")` for all tests (NEVER "local")
- `AutoConfigureMockMvc` from `org.springframework.boot.webmvc.test.autoconfigure` (NOT `boot.test.autoconfigure.web.servlet`)
