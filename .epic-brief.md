# Implementation Brief: Epic 69A — V20 Migration, TimeEntry Rate Snapshot Columns & Snapshot-on-Create

## Scope
Backend only

## Tasks

### 69.1 — Create V20 tenant migration for time_entry rate snapshot columns

**File**: `backend/src/main/resources/db/migration/tenant/V20__add_time_entry_rate_snapshots.sql`

ALTER TABLE `time_entries` to add four new columns:
- `billing_rate_snapshot DECIMAL(12,2)` — nullable
- `billing_rate_currency VARCHAR(3)` — nullable
- `cost_rate_snapshot DECIMAL(12,2)` — nullable
- `cost_rate_currency VARCHAR(3)` — nullable

CHECK constraints:
- `chk_billing_snapshot_currency`: both billing fields null or both non-null
- `chk_cost_snapshot_currency`: both cost fields null or both non-null

Index:
- `idx_time_entries_billing_currency ON time_entries (billing_rate_currency) WHERE billing_rate_currency IS NOT NULL`

Note: existing `rate_cents` column is NOT removed — deprecated only.

**Acceptance criteria**:
- Migration runs without error against existing tenant schemas
- Existing time entries are unaffected (all new columns are nullable)
- Constraints prevent partial snapshot (rate without currency or vice versa)

### 69.2 — Modify TimeEntry entity with rate snapshot fields

**File**: Modify `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntry.java`

Add fields:
- `BigDecimal billingRateSnapshot` (precision=12, scale=2, nullable, column `billing_rate_snapshot`)
- `String billingRateCurrency` (VARCHAR(3), nullable, column `billing_rate_currency`)
- `BigDecimal costRateSnapshot` (precision=12, scale=2, nullable, column `cost_rate_snapshot`)
- `String costRateCurrency` (VARCHAR(3), nullable, column `cost_rate_currency`)

Add `@Deprecated` annotation on existing `rateCents` field and its getter/setter.

Add methods:
- `snapshotBillingRate(BigDecimal rate, String currency)` — sets both billing fields
- `snapshotCostRate(BigDecimal rate, String currency)` — sets both cost fields
- `getBillableValue()` — computed: if `billable && billingRateSnapshot != null`, return `BigDecimal.valueOf(durationMinutes).divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP).multiply(billingRateSnapshot)`. Else return null.
- `getCostValue()` — computed: if `costRateSnapshot != null`, return `BigDecimal.valueOf(durationMinutes).divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP).multiply(costRateSnapshot)`. Else return null. Cost includes both billable AND non-billable entries.

**Acceptance criteria**:
- Entity compiles with all new fields properly mapped
- `@Deprecated` annotation on `rateCents` field, getter, setter
- Snapshot methods set both rate and currency atomically
- Computed getters derive values correctly from duration and snapshot

### 69.3 — Modify TimeEntryService to snapshot rates on create

**File**: Modify `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryService.java`

In `createTimeEntry()`, after task/project validation and before `timeEntryRepository.save()`:
1. Call `billingRateService.resolveRate(memberId, projectId, date)` — project ID comes from the looked-up task
2. If resolved, call `entry.snapshotBillingRate(rate.hourlyRate(), rate.currency())`
3. Call `costRateService.resolveCostRate(memberId, date)`
4. If resolved, call `entry.snapshotCostRate(rate.hourlyCost(), rate.currency())`

Inject `BillingRateService` and `CostRateService` as new constructor parameters.

Also add billing/cost snapshot details to the audit event for `time_entry.created`:
- Include `billing_rate_snapshot` and `billing_rate_currency` if present
- Include `cost_rate_snapshot` and `cost_rate_currency` if present

**Acceptance criteria**:
- New time entries auto-resolve and snapshot billing and cost rates
- Snapshot uses the time entry's `date` and the task's `projectId` for resolution
- Null snapshots when no rate is configured (no exception thrown)
- Audit event includes snapshot details

### 69.4 — Modify TimeEntryService to re-snapshot on date/project change

**File**: Modify `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryService.java`

In `updateTimeEntry()`:
1. Detect if `date` has changed (new date differs from old date)
2. If date changed, re-resolve billing and cost rates for the **new** date using existing projectId
3. Update snapshot fields on the entry
4. Capture old snapshot values before mutation; include delta in audit details: `{"billing_rate_snapshot": {"from": "150.00", "to": "175.00"}}`

If only `durationMinutes`, `description`, or `billable` changed — do NOT re-snapshot.

Note: taskId is immutable on update (not in UpdateTimeEntryRequest), so project context does not change via update. Only date changes trigger re-snapshot.

**Acceptance criteria**:
- Date change triggers re-snapshot with new date context
- Description/duration/billable-only changes do NOT re-snapshot
- Old vs new snapshot values captured in audit delta
- Null-to-value and value-to-null transitions handled correctly

### 69.5 — Add rate snapshot integration tests

**File**: `backend/src/test/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryRateSnapshotTest.java`

~7 tests:
1. Create time entry with configured billing rate — verify `billingRateSnapshot` and `billingRateCurrency` populated in response
2. Create entry with no rate configured — verify snapshot fields are null
3. Create entry with both billing and cost rates — verify both snapshots populated
4. Update entry date to different rate period — verify re-snapshot with new rate
5. Update entry description only — verify snapshot unchanged
6. Computed `billableValue` correct: `durationMinutes / 60 * billingRateSnapshot`
7. Entry with `billable=false` has null `billableValue` but non-null `costValue`

**Setup**: Provision tenant, sync members, create project+task, create billing rate, create cost rate.

**Acceptance criteria**:
- All 7 tests pass
- Tests use MockMvc integration test pattern (POST to create, GET to verify)
- Tests verify both JSON response fields and computed values

## File Plan

### Create
- `backend/src/main/resources/db/migration/tenant/V20__add_time_entry_rate_snapshots.sql`
- `backend/src/test/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryRateSnapshotTest.java`

### Modify
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntry.java` — Add 4 snapshot fields, snapshot methods, computed getters, deprecate rateCents
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryService.java` — Inject BillingRateService + CostRateService, snapshot on create, re-snapshot on date change
- `backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryController.java` — Add snapshot fields to TimeEntryResponse DTO, add billableValue/costValue computed fields

## Reference Patterns

### TimeEntry Entity (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntry.java)
```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAware;
import io.b2mash.b2b.b2bstrawman.multitenancy.TenantAwareEntityListener;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

@Entity
@Table(name = "time_entries")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
@EntityListeners(TenantAwareEntityListener.class)
public class TimeEntry implements TenantAware {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @Column(name = "task_id", nullable = false)
  private UUID taskId;

  @Column(name = "member_id", nullable = false)
  private UUID memberId;

  @Column(name = "date", nullable = false)
  private LocalDate date;

  @Column(name = "duration_minutes", nullable = false)
  private int durationMinutes;

  @Column(name = "billable", nullable = false)
  private boolean billable;

  @Column(name = "rate_cents")
  private Integer rateCents;

  @Column(name = "description", columnDefinition = "TEXT")
  private String description;

  @Column(name = "tenant_id")
  private String tenantId;

  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected TimeEntry() {}

  public TimeEntry(
      UUID taskId,
      UUID memberId,
      LocalDate date,
      int durationMinutes,
      boolean billable,
      Integer rateCents,
      String description) {
    this.taskId = taskId;
    this.memberId = memberId;
    this.date = date;
    this.durationMinutes = durationMinutes;
    this.billable = billable;
    this.rateCents = rateCents;
    this.description = description;
    this.createdAt = Instant.now();
    this.updatedAt = Instant.now();
  }

  public UUID getId() {
    return id;
  }

  public UUID getTaskId() {
    return taskId;
  }

  public UUID getMemberId() {
    return memberId;
  }

  public LocalDate getDate() {
    return date;
  }

  public int getDurationMinutes() {
    return durationMinutes;
  }

  public boolean isBillable() {
    return billable;
  }

  public Integer getRateCents() {
    return rateCents;
  }

  public String getDescription() {
    return description;
  }

  @Override
  public String getTenantId() {
    return tenantId;
  }

  @Override
  public void setTenantId(String tenantId) {
    this.tenantId = tenantId;
  }

  public Instant getCreatedAt() {
    return createdAt;
  }

  public Instant getUpdatedAt() {
    return updatedAt;
  }

  public void setDate(LocalDate date) {
    this.date = date;
  }

  public void setDurationMinutes(int durationMinutes) {
    this.durationMinutes = durationMinutes;
  }

  public void setBillable(boolean billable) {
    this.billable = billable;
  }

  public void setRateCents(Integer rateCents) {
    this.rateCents = rateCents;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public void setUpdatedAt(Instant updatedAt) {
    this.updatedAt = updatedAt;
  }
}
```

### TimeEntryService (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryService.java)
```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.member.ProjectAccessService;
import io.b2mash.b2b.b2bstrawman.task.TaskRepository;
import java.time.Instant;
import java.time.LocalDate;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class TimeEntryService {

  private static final Logger log = LoggerFactory.getLogger(TimeEntryService.class);

  private final TimeEntryRepository timeEntryRepository;
  private final TaskRepository taskRepository;
  private final ProjectAccessService projectAccessService;
  private final AuditService auditService;

  public TimeEntryService(
      TimeEntryRepository timeEntryRepository,
      TaskRepository taskRepository,
      ProjectAccessService projectAccessService,
      AuditService auditService) {
    this.timeEntryRepository = timeEntryRepository;
    this.taskRepository = taskRepository;
    this.projectAccessService = projectAccessService;
    this.auditService = auditService;
  }

  @Transactional
  public TimeEntry createTimeEntry(
      UUID taskId,
      LocalDate date,
      int durationMinutes,
      boolean billable,
      Integer rateCents,
      String description,
      UUID memberId,
      String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    if (durationMinutes <= 0) {
      throw new InvalidStateException(
          "Invalid duration", "Duration must be greater than 0 minutes");
    }

    if (rateCents != null && rateCents < 0) {
      throw new InvalidStateException("Invalid rate", "Rate cents must be non-negative");
    }

    var entry =
        new TimeEntry(taskId, memberId, date, durationMinutes, billable, rateCents, description);
    entry = timeEntryRepository.save(entry);
    log.info("Created time entry {} for task {} by member {}", entry.getId(), taskId, memberId);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("time_entry.created")
            .entityType("time_entry")
            .entityId(entry.getId())
            .details(
                Map.of(
                    "task_id",
                    taskId.toString(),
                    "duration_minutes",
                    durationMinutes,
                    "billable",
                    billable,
                    "project_id",
                    task.getProjectId().toString()))
            .build());

    return entry;
  }

  @Transactional(readOnly = true)
  public List<TimeEntry> listTimeEntriesByTask(UUID taskId, UUID memberId, String orgRole) {
    var task =
        taskRepository
            .findOneById(taskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", taskId));

    projectAccessService.requireViewAccess(task.getProjectId(), memberId, orgRole);

    return timeEntryRepository.findByTaskId(taskId);
  }

  @Transactional
  public TimeEntry updateTimeEntry(
      UUID timeEntryId,
      LocalDate date,
      Integer durationMinutes,
      Boolean billable,
      Integer rateCents,
      String description,
      UUID memberId,
      String orgRole) {
    var entry =
        timeEntryRepository
            .findOneById(timeEntryId)
            .orElseThrow(() -> new ResourceNotFoundException("TimeEntry", timeEntryId));

    requireEditPermission(entry, memberId, orgRole);

    UUID entryTaskId = entry.getTaskId();
    var task =
        taskRepository
            .findOneById(entryTaskId)
            .orElseThrow(() -> new ResourceNotFoundException("Task", entryTaskId));

    if (durationMinutes != null && durationMinutes <= 0) {
      throw new InvalidStateException(
          "Invalid duration", "Duration must be greater than 0 minutes");
    }

    if (rateCents != null && rateCents < 0) {
      throw new InvalidStateException("Invalid rate", "Rate cents must be non-negative");
    }

    // Capture old values before mutation
    LocalDate oldDate = entry.getDate();
    int oldDurationMinutes = entry.getDurationMinutes();
    boolean oldBillable = entry.isBillable();
    Integer oldRateCents = entry.getRateCents();
    String oldDescription = entry.getDescription();

    if (date != null) {
      entry.setDate(date);
    }
    if (durationMinutes != null) {
      entry.setDurationMinutes(durationMinutes);
    }
    if (billable != null) {
      entry.setBillable(billable);
    }
    if (rateCents != null) {
      entry.setRateCents(rateCents);
    }
    if (description != null) {
      entry.setDescription(description);
    }
    entry.setUpdatedAt(Instant.now());

    entry = timeEntryRepository.save(entry);
    log.info("Updated time entry {} by member {}", timeEntryId, memberId);

    // Build delta map -- only include fields that were provided AND actually changed
    var details = new LinkedHashMap<String, Object>();
    if (date != null && !Objects.equals(oldDate, date)) {
      details.put(
          "date", Map.of("from", oldDate != null ? oldDate.toString() : "", "to", date.toString()));
    }
    if (durationMinutes != null && oldDurationMinutes != durationMinutes) {
      details.put("duration_minutes", Map.of("from", oldDurationMinutes, "to", durationMinutes));
    }
    if (billable != null && oldBillable != billable) {
      details.put("billable", Map.of("from", oldBillable, "to", billable));
    }
    if (rateCents != null && !Objects.equals(oldRateCents, rateCents)) {
      details.put(
          "rate_cents", Map.of("from", oldRateCents != null ? oldRateCents : 0, "to", rateCents));
    }
    if (description != null && !Objects.equals(oldDescription, description)) {
      details.put(
          "description",
          Map.of("from", oldDescription != null ? oldDescription : "", "to", description));
    }

    details.put("project_id", task.getProjectId().toString());

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("time_entry.updated")
            .entityType("time_entry")
            .entityId(entry.getId())
            .details(details)
            .build());

    return entry;
  }

  @Transactional
  public void deleteTimeEntry(UUID timeEntryId, UUID memberId, String orgRole) {
    var entry =
        timeEntryRepository
            .findOneById(timeEntryId)
            .orElseThrow(() -> new ResourceNotFoundException("TimeEntry", timeEntryId));

    requireEditPermission(entry, memberId, orgRole);

    var task =
        taskRepository
            .findOneById(entry.getTaskId())
            .orElseThrow(() -> new ResourceNotFoundException("Task", entry.getTaskId()));

    timeEntryRepository.delete(entry);
    log.info("Deleted time entry {} by member {}", timeEntryId, memberId);

    auditService.log(
        AuditEventBuilder.builder()
            .eventType("time_entry.deleted")
            .entityType("time_entry")
            .entityId(entry.getId())
            .details(
                Map.of(
                    "task_id", entry.getTaskId().toString(),
                    "project_id", task.getProjectId().toString()))
            .build());
  }

  // --- Project time summary aggregation methods (Epic 46A) ---

  @Transactional(readOnly = true)
  public ProjectTimeSummaryProjection getProjectTimeSummary(
      UUID projectId, UUID memberId, String orgRole, LocalDate from, LocalDate to) {
    projectAccessService.requireViewAccess(projectId, memberId, orgRole);
    return timeEntryRepository.projectTimeSummary(projectId, from, to);
  }

  @Transactional(readOnly = true)
  public List<MemberTimeSummaryProjection> getProjectTimeSummaryByMember(
      UUID projectId, UUID memberId, String orgRole, LocalDate from, LocalDate to) {
    var access = projectAccessService.requireViewAccess(projectId, memberId, orgRole);
    if (!access.canEdit()) {
      throw new ForbiddenException(
          "Cannot view member breakdown",
          "Per-member time breakdown is restricted to project leads, org admins, and org owners");
    }
    return timeEntryRepository.projectTimeSummaryByMember(projectId, from, to);
  }

  @Transactional(readOnly = true)
  public List<TaskTimeSummaryProjection> getProjectTimeSummaryByTask(
      UUID projectId, UUID memberId, String orgRole, LocalDate from, LocalDate to) {
    projectAccessService.requireViewAccess(projectId, memberId, orgRole);
    return timeEntryRepository.projectTimeSummaryByTask(projectId, from, to);
  }

  /**
   * Checks that the caller has permission to edit/delete the given time entry. The creator can
   * always modify their own entries. Otherwise, the caller must have canEdit() access on the
   * entry's project (project lead, org admin, or org owner).
   */
  private void requireEditPermission(TimeEntry entry, UUID memberId, String orgRole) {
    if (entry.getMemberId().equals(memberId)) {
      return; // creator can always modify own entries
    }

    var task =
        taskRepository
            .findOneById(entry.getTaskId())
            .orElseThrow(() -> new ResourceNotFoundException("Task", entry.getTaskId()));

    var access = projectAccessService.checkAccess(task.getProjectId(), memberId, orgRole);
    if (!access.canEdit()) {
      throw new ForbiddenException(
          "Cannot modify time entry",
          "Only the creator or a project lead/admin/owner can modify this time entry");
    }
  }
}
```

### TimeEntryController (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryController.java)
```java
package io.b2mash.b2b.b2bstrawman.timeentry;

import io.b2mash.b2b.b2bstrawman.member.Member;
import io.b2mash.b2b.b2bstrawman.member.MemberRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.net.URI;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TimeEntryController {

  private final TimeEntryService timeEntryService;
  private final MemberRepository memberRepository;

  public TimeEntryController(TimeEntryService timeEntryService, MemberRepository memberRepository) {
    this.timeEntryService = timeEntryService;
    this.memberRepository = memberRepository;
  }

  @PostMapping("/api/tasks/{taskId}/time-entries")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TimeEntryResponse> createTimeEntry(
      @PathVariable UUID taskId, @Valid @RequestBody CreateTimeEntryRequest request) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var entry =
        timeEntryService.createTimeEntry(
            taskId,
            request.date(),
            request.durationMinutes(),
            request.billable() != null ? request.billable() : true,
            request.rateCents(),
            request.description(),
            memberId,
            orgRole);

    var names = resolveNames(List.of(entry));
    return ResponseEntity.created(URI.create("/api/time-entries/" + entry.getId()))
        .body(TimeEntryResponse.from(entry, names));
  }

  @GetMapping("/api/tasks/{taskId}/time-entries")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<List<TimeEntryResponse>> listTimeEntries(@PathVariable UUID taskId) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var entries = timeEntryService.listTimeEntriesByTask(taskId, memberId, orgRole);
    var names = resolveNames(entries);
    var response = entries.stream().map(e -> TimeEntryResponse.from(e, names)).toList();
    return ResponseEntity.ok(response);
  }

  @PutMapping("/api/time-entries/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<TimeEntryResponse> updateTimeEntry(
      @PathVariable UUID id, @Valid @RequestBody UpdateTimeEntryRequest request) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    var entry =
        timeEntryService.updateTimeEntry(
            id,
            request.date(),
            request.durationMinutes(),
            request.billable(),
            request.rateCents(),
            request.description(),
            memberId,
            orgRole);

    var names = resolveNames(List.of(entry));
    return ResponseEntity.ok(TimeEntryResponse.from(entry, names));
  }

  @DeleteMapping("/api/time-entries/{id}")
  @PreAuthorize("hasAnyRole('ORG_MEMBER', 'ORG_ADMIN', 'ORG_OWNER')")
  public ResponseEntity<Void> deleteTimeEntry(@PathVariable UUID id) {
    UUID memberId = RequestScopes.requireMemberId();
    String orgRole = RequestScopes.getOrgRole();

    timeEntryService.deleteTimeEntry(id, memberId, orgRole);
    return ResponseEntity.noContent().build();
  }

  /**
   * Batch-loads member names for all member IDs referenced by the given time entries. Returns a map
   * of member UUID to display name.
   */
  private Map<UUID, String> resolveNames(List<TimeEntry> entries) {
    var ids =
        entries.stream().map(TimeEntry::getMemberId).filter(Objects::nonNull).distinct().toList();

    if (ids.isEmpty()) {
      return Map.of();
    }

    return memberRepository.findAllById(ids).stream()
        .collect(Collectors.toMap(Member::getId, Member::getName, (a, b) -> a));
  }

  // --- DTOs ---

  public record CreateTimeEntryRequest(
      @NotNull(message = "date is required") LocalDate date,
      @NotNull(message = "durationMinutes is required")
          @Positive(message = "durationMinutes must be positive")
          Integer durationMinutes,
      Boolean billable,
      Integer rateCents,
      String description) {}

  public record UpdateTimeEntryRequest(
      LocalDate date,
      @Positive(message = "durationMinutes must be positive") Integer durationMinutes,
      Boolean billable,
      Integer rateCents,
      String description) {}

  public record TimeEntryResponse(
      UUID id,
      UUID taskId,
      UUID memberId,
      String memberName,
      LocalDate date,
      int durationMinutes,
      boolean billable,
      Integer rateCents,
      String description,
      Instant createdAt,
      Instant updatedAt) {

    public static TimeEntryResponse from(TimeEntry entry, Map<UUID, String> memberNames) {
      return new TimeEntryResponse(
          entry.getId(),
          entry.getTaskId(),
          entry.getMemberId(),
          memberNames.get(entry.getMemberId()),
          entry.getDate(),
          entry.getDurationMinutes(),
          entry.isBillable(),
          entry.getRateCents(),
          entry.getDescription(),
          entry.getCreatedAt(),
          entry.getUpdatedAt());
    }
  }
}
```

### BillingRateService — resolveRate method (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRateService.java)
```java
package io.b2mash.b2b.b2bstrawman.billingrate;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.customer.CustomerProjectRepository;
import io.b2mash.b2b.b2bstrawman.customer.CustomerRepository;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.InvalidStateException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceConflictException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.member.ProjectAccessService;
import io.b2mash.b2b.b2bstrawman.project.ProjectRepository;
import io.b2mash.b2b.b2bstrawman.security.Roles;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class BillingRateService {

  private static final Logger log = LoggerFactory.getLogger(BillingRateService.class);
  private static final LocalDate FAR_FUTURE = LocalDate.of(9999, 12, 31);

  private final BillingRateRepository billingRateRepository;
  private final CustomerProjectRepository customerProjectRepository;
  private final CustomerRepository customerRepository;
  private final ProjectRepository projectRepository;
  private final ProjectAccessService projectAccessService;
  private final AuditService auditService;

  public BillingRateService(
      BillingRateRepository billingRateRepository,
      CustomerProjectRepository customerProjectRepository,
      CustomerRepository customerRepository,
      ProjectRepository projectRepository,
      ProjectAccessService projectAccessService,
      AuditService auditService) {
    this.billingRateRepository = billingRateRepository;
    this.customerProjectRepository = customerProjectRepository;
    this.customerRepository = customerRepository;
    this.projectRepository = projectRepository;
    this.projectAccessService = projectAccessService;
    this.auditService = auditService;
  }

  /**
   * Resolved rate result containing the hourly rate, currency, resolution source, and the billing
   * rate ID that was matched.
   */
  public record ResolvedRate(
      BigDecimal hourlyRate, String currency, String source, UUID billingRateId) {}

  /**
   * Resolves the applicable billing rate for a member on a project at a given date using the
   * three-level cascade per ADR-039:
   * 1. Project override (member + project, no customer)
   * 2. Customer override (member + project's first customer, no project)
   * 3. Member default (member only, no project or customer)
   */
  @Transactional(readOnly = true)
  public Optional<ResolvedRate> resolveRate(UUID memberId, UUID projectId, LocalDate date) {
    // 1. Try project override
    var projectRates = billingRateRepository.findProjectOverride(memberId, projectId, date);
    if (!projectRates.isEmpty()) {
      var rate = projectRates.getFirst();
      return Optional.of(
          new ResolvedRate(
              rate.getHourlyRate(), rate.getCurrency(), "PROJECT_OVERRIDE", rate.getId()));
    }

    // 2. Try customer override via CustomerProject join
    var customerId = customerProjectRepository.findFirstCustomerByProjectId(projectId);
    if (customerId.isPresent()) {
      var customerRates =
          billingRateRepository.findCustomerOverride(memberId, customerId.get(), date);
      if (!customerRates.isEmpty()) {
        var rate = customerRates.getFirst();
        return Optional.of(
            new ResolvedRate(
                rate.getHourlyRate(), rate.getCurrency(), "CUSTOMER_OVERRIDE", rate.getId()));
      }
    }

    // 3. Try member default
    var defaultRates = billingRateRepository.findMemberDefault(memberId, date);
    if (!defaultRates.isEmpty()) {
      var rate = defaultRates.getFirst();
      return Optional.of(
          new ResolvedRate(
              rate.getHourlyRate(), rate.getCurrency(), "MEMBER_DEFAULT", rate.getId()));
    }

    return Optional.empty();
  }

  // ... createRate, updateRate, deleteRate, listRates, validation methods ...
}
```

### CostRateService — resolveCostRate method (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/costrate/CostRateService.java)
```java
package io.b2mash.b2b.b2bstrawman.costrate;

import io.b2mash.b2b.b2bstrawman.audit.AuditEventBuilder;
import io.b2mash.b2b.b2bstrawman.audit.AuditService;
import io.b2mash.b2b.b2bstrawman.exception.ForbiddenException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceConflictException;
import io.b2mash.b2b.b2bstrawman.exception.ResourceNotFoundException;
import io.b2mash.b2b.b2bstrawman.security.Roles;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CostRateService {

  private static final Logger log = LoggerFactory.getLogger(CostRateService.class);
  private static final LocalDate FAR_FUTURE = LocalDate.of(9999, 12, 31);

  private final CostRateRepository costRateRepository;
  private final AuditService auditService;

  /**
   * Resolved cost rate result containing the hourly cost, currency, and the cost rate ID that was
   * matched.
   */
  public record ResolvedCostRate(BigDecimal hourlyCost, String currency, UUID costRateId) {}

  public CostRateService(CostRateRepository costRateRepository, AuditService auditService) {
    this.costRateRepository = costRateRepository;
    this.auditService = auditService;
  }

  /**
   * Resolves the applicable cost rate for a member at a given date. Simple single-level lookup per
   * ADR-043 -- no project/customer hierarchy.
   */
  @Transactional(readOnly = true)
  public Optional<ResolvedCostRate> resolveCostRate(UUID memberId, LocalDate date) {
    var rates = costRateRepository.findByMemberIdAndDate(memberId, date);
    if (!rates.isEmpty()) {
      var rate = rates.getFirst();
      return Optional.of(
          new ResolvedCostRate(rate.getHourlyCost(), rate.getCurrency(), rate.getId()));
    }
    return Optional.empty();
  }

  // ... createCostRate, updateCostRate, deleteCostRate, listCostRates ...
}
```

### BillingRateResolutionTest — Integration Test Pattern (from backend/src/test/java/io/b2mash/b2b/b2bstrawman/billingrate/BillingRateResolutionTest.java)
```java
package io.b2mash.b2b.b2bstrawman.billingrate;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.jayway.jsonpath.JsonPath;
import io.b2mash.b2b.b2bstrawman.TestcontainersConfiguration;
import io.b2mash.b2b.b2bstrawman.customer.CustomerProjectRepository;
import io.b2mash.b2b.b2bstrawman.customer.CustomerProjectService;
import io.b2mash.b2b.b2bstrawman.customer.CustomerService;
import io.b2mash.b2b.b2bstrawman.multitenancy.OrgSchemaMappingRepository;
import io.b2mash.b2b.b2bstrawman.multitenancy.RequestScopes;
import io.b2mash.b2b.b2bstrawman.project.ProjectService;
import io.b2mash.b2b.b2bstrawman.provisioning.PlanSyncService;
import io.b2mash.b2b.b2bstrawman.provisioning.TenantProvisioningService;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.UUID;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class BillingRateResolutionTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_billing_rate_res_test";

  @Autowired private MockMvc mockMvc;
  @Autowired private BillingRateService billingRateService;
  @Autowired private BillingRateRepository billingRateRepository;
  @Autowired private CustomerService customerService;
  @Autowired private CustomerProjectService customerProjectService;
  @Autowired private CustomerProjectRepository customerProjectRepository;
  @Autowired private ProjectService projectService;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;
  @Autowired private OrgSchemaMappingRepository orgSchemaMappingRepository;

  private String tenantSchema;
  private UUID memberIdOwner;
  private UUID memberIdMember;
  private UUID projectId;
  private UUID customerId;

  @BeforeAll
  void setup() throws Exception {
    provisioningService.provisionTenant(ORG_ID, "BillingRate Resolution Test Org");
    planSyncService.syncPlan(ORG_ID, "pro-plan");

    memberIdOwner =
        UUID.fromString(
            syncMember(ORG_ID, "user_rate_res_owner", "rate_res_owner@test.com", "Owner", "owner"));
    memberIdMember =
        UUID.fromString(
            syncMember(
                ORG_ID, "user_rate_res_member", "rate_res_member@test.com", "Member", "member"));

    tenantSchema =
        orgSchemaMappingRepository.findByClerkOrgId(ORG_ID).orElseThrow().getSchemaName();

    // Create project, customer, and link within tenant scope
    ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
        .where(RequestScopes.MEMBER_ID, memberIdOwner)
        .where(RequestScopes.ORG_ROLE, "owner")
        .run(
            () -> {
              var customer =
                  customerService.createCustomer(
                      "Rate Test Customer",
                      "rate-customer@test.com",
                      null,
                      null,
                      null,
                      memberIdOwner);
              customerId = customer.getId();

              var project =
                  projectService.createProject(
                      "Rate Resolution Test Project", "Test", memberIdOwner);
              projectId = project.getId();

              customerProjectService.linkCustomerToProject(
                  customerId, projectId, memberIdOwner, memberIdOwner, "owner");
            });
  }

  @Test
  @Order(1)
  void resolveRate_returnsEmpty_whenNoRateConfigured() {
    runInTenant(
        () -> {
          var result = billingRateService.resolveRate(memberIdOwner, projectId, LocalDate.now());
          assertThat(result).isEmpty();
          return null;
        });
  }

  @Test
  @Order(2)
  void resolveRate_returnsMemberDefault_whenOnlyDefaultExists() {
    runInTenant(
        () -> {
          billingRateService.createRate(
              memberIdOwner,
              null,
              null,
              "USD",
              new BigDecimal("100.00"),
              LocalDate.of(2024, 1, 1),
              null,
              memberIdOwner,
              "owner");

          var result =
              billingRateService.resolveRate(memberIdOwner, projectId, LocalDate.of(2024, 6, 15));

          assertThat(result).isPresent();
          assertThat(result.get().source()).isEqualTo("MEMBER_DEFAULT");
          assertThat(result.get().hourlyRate()).isEqualByComparingTo("100.00");
          assertThat(result.get().currency()).isEqualTo("USD");
          return null;
        });
  }

  // ... more ordered tests follow the same pattern ...

  // --- Helpers ---

  private <T> T runInTenant(java.util.concurrent.Callable<T> callable) {
    try {
      return ScopedValue.where(RequestScopes.TENANT_ID, tenantSchema)
          .where(RequestScopes.MEMBER_ID, memberIdOwner)
          .where(RequestScopes.ORG_ROLE, "owner")
          .call(() -> callable.call());
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private String syncMember(
      String orgId, String clerkUserId, String email, String name, String orgRole)
      throws Exception {
    var result =
        mockMvc
            .perform(
                post("/internal/members/sync")
                    .header("X-API-KEY", API_KEY)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(
                        """
                        {
                          "clerkOrgId": "%s",
                          "clerkUserId": "%s",
                          "email": "%s",
                          "name": "%s",
                          "avatarUrl": null,
                          "orgRole": "%s"
                        }
                        """
                            .formatted(orgId, clerkUserId, email, name, orgRole)))
            .andExpect(status().isCreated())
            .andReturn();
    return JsonPath.read(result.getResponse().getContentAsString(), "$.memberId");
  }
}
```

### TimeEntryIntegrationTest — MockMvc Pattern (from backend/src/test/java/io/b2mash/b2b/b2bstrawman/timeentry/TimeEntryIntegrationTest.java)

Key patterns to follow for the new test:
```java
@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration.class)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TimeEntryIntegrationTest {

  private static final String API_KEY = "test-api-key";
  private static final String ORG_ID = "org_timeentry_test";

  @Autowired private MockMvc mockMvc;
  @Autowired private TenantProvisioningService provisioningService;
  @Autowired private PlanSyncService planSyncService;

  // JWT helper pattern:
  private JwtRequestPostProcessor ownerJwt() {
    return jwt()
        .jwt(j -> j.subject("user_te_owner").claim("o", Map.of("id", ORG_ID, "rol", "owner")))
        .authorities(List.of(new SimpleGrantedAuthority("ROLE_ORG_OWNER")));
  }

  // Create time entry helper:
  private String createTimeEntry(JwtRequestPostProcessor jwt, String date, int durationMinutes,
      boolean billable, Integer rateCents, String description) throws Exception {
    var content = """
        {"date": "%s", "durationMinutes": %d, "billable": %s, "description": "%s"}
        """.formatted(date, durationMinutes, billable, description);
    var result = mockMvc.perform(
        post("/api/tasks/" + taskId + "/time-entries")
            .with(jwt).contentType(MediaType.APPLICATION_JSON).content(content))
        .andExpect(status().isCreated()).andReturn();
    return JsonPath.read(result.getResponse().getContentAsString(), "$.id").toString();
  }

  // Extract ID from Location header:
  private String extractIdFromLocation(MvcResult result) {
    String location = result.getResponse().getHeader("Location");
    return location.substring(location.lastIndexOf('/') + 1);
  }
}
```

### Roles Constants (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/security/Roles.java)
```java
package io.b2mash.b2b.b2bstrawman.security;

public final class Roles {
  public static final String ORG_OWNER = "owner";
  public static final String ORG_ADMIN = "admin";
  public static final String ORG_MEMBER = "member";
  public static final String PROJECT_LEAD = "lead";
  public static final String PROJECT_MEMBER = "member";
  public static final String AUTHORITY_ORG_OWNER = "ROLE_ORG_OWNER";
  public static final String AUTHORITY_ORG_ADMIN = "ROLE_ORG_ADMIN";
  public static final String AUTHORITY_ORG_MEMBER = "ROLE_ORG_MEMBER";
  public static final String AUTHORITY_INTERNAL = "ROLE_INTERNAL_SERVICE";
  private Roles() {}
}
```

### AuditEventBuilder Usage (from backend/src/main/java/io/b2mash/b2b/b2bstrawman/audit/AuditEventBuilder.java)
```java
// Usage pattern:
auditService.log(
    AuditEventBuilder.builder()
        .eventType("time_entry.created")
        .entityType("time_entry")
        .entityId(entry.getId())
        .details(Map.of(
            "task_id", taskId.toString(),
            "duration_minutes", durationMinutes,
            "billable", billable,
            "project_id", task.getProjectId().toString()))
        .build());

// NOTE: Map.of() does NOT accept null values!
// Use LinkedHashMap when any value might be null.
```

## Conventions

### Code Style
- Use Java records for DTOs, request/response objects, and value objects
- Prefer constructor injection (no `@Autowired` on fields)
- Use `@PreAuthorize` annotations for role-based access control
- Return `ResponseEntity` from controllers for explicit status codes
- Use Spring's `ProblemDetail` (RFC 9457) for error responses
- No Lombok -- Java 25 records and pattern matching cover most use cases

### Naming
- Base package: `io.b2mash.b2b.b2bstrawman`
- Entities: domain name (no `Entity` suffix)
- Repositories: `*Repository` extending `JpaRepository`
- Services: `*Service`
- Controllers: `*Controller`
- DTOs: nested records inside the controller or in a `dto` sub-package if shared

### Anti-Patterns -- Never Do This (VERBATIM)
- Never use `@Autowired` on fields -- use constructor injection
- Never use Lombok -- Java 25 records and pattern matching cover all cases
- Never trust client headers for tenant resolution -- always derive from validated JWT
- Never use `org.springframework.boot.orm.jpa.HibernatePropertiesCustomizer` -- it moved to `boot.hibernate.autoconfigure` in Spring Boot 4
- Never set `hibernate.multiTenancy` property -- Hibernate 7 auto-detects from registered provider
- Never use `java -jar` for the Docker entry point -- use `org.springframework.boot.loader.launch.JarLauncher`
- Never make `TestcontainersConfiguration` package-private -- it must be `public` for `@Import` from subpackages
- Never use `@ActiveProfiles("local")` in tests -- use `@ActiveProfiles("test")`. The "local" profile connects to Docker Compose Postgres. Tests must run against ephemeral Testcontainers only.
- Never use flat JWT claims (`org_id`, `org_role`) -- Clerk JWT v2 nests org claims under `"o"`: `jwt.getClaim("o")` returns `Map<String, Object>` with keys `id`, `rol`, `slg`
- Never use `ThreadLocal` for request-scoped context -- use `ScopedValue` via `RequestScopes` (guaranteed cleanup, virtual thread safe)
- Never call `RequestScopes.TENANT_ID.get()` without checking `isBound()` first or accepting `NoSuchElementException`
- Never build `ProblemDetail` directly in controllers or services -- throw semantic exceptions from `exception/` package instead
- Never return `Optional` from services for "not found" or "access denied" -- throw `ResourceNotFoundException`
- Never duplicate error helper methods in controllers -- use `RequestScopes.requireMemberId()` and the shared exception classes

### Additional Rules
- Organize by **feature**, not by layer
- `AutoConfigureMockMvc` import: `org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc` (Spring Boot 4)
- Spring Security Test `jwt()` mock does NOT invoke `ClerkJwtAuthenticationConverter` -- must set `.authorities()` explicitly
- Use `ScopedValue.where(RequestScopes.TENANT_ID, schema).run(() -> {...})` in tests -- no cleanup needed

## Integration Points

### Services to inject into TimeEntryService
```java
// Existing
private final TimeEntryRepository timeEntryRepository;
private final TaskRepository taskRepository;
private final ProjectAccessService projectAccessService;
private final AuditService auditService;

// NEW for 69A
private final BillingRateService billingRateService;
private final CostRateService costRateService;
```

### Method signatures used from dependencies

```java
// BillingRateService
public Optional<ResolvedRate> resolveRate(UUID memberId, UUID projectId, LocalDate date)
// ResolvedRate record: (BigDecimal hourlyRate, String currency, String source, UUID billingRateId)

// CostRateService
public Optional<ResolvedCostRate> resolveCostRate(UUID memberId, LocalDate date)
// ResolvedCostRate record: (BigDecimal hourlyCost, String currency, UUID costRateId)

// Task entity (used to get projectId from taskId)
task.getProjectId() // returns UUID
```

### TimeEntryController -- Response DTO changes

The existing `TimeEntryResponse` record must be updated to include:
- `billingRateSnapshot` (BigDecimal, nullable)
- `billingRateCurrency` (String, nullable)
- `costRateSnapshot` (BigDecimal, nullable)
- `costRateCurrency` (String, nullable)
- `billableValue` (BigDecimal, nullable -- computed)
- `costValue` (BigDecimal, nullable -- computed)

The `from()` factory method must map these from the entity.

Keep `rateCents` in the response for backward compatibility (marked `@Deprecated` in entity).

## Migration Notes

### V20__add_time_entry_rate_snapshots.sql

The architecture doc specifies this exact SQL (Section 11.7.2):

```sql
-- V20: Add rate snapshot columns to time_entries
-- Phase 8 -- Point-in-time rate snapshotting for billable/cost valuation

ALTER TABLE time_entries
    ADD COLUMN IF NOT EXISTS billing_rate_snapshot DECIMAL(12,2),
    ADD COLUMN IF NOT EXISTS billing_rate_currency VARCHAR(3),
    ADD COLUMN IF NOT EXISTS cost_rate_snapshot    DECIMAL(12,2),
    ADD COLUMN IF NOT EXISTS cost_rate_currency    VARCHAR(3);

-- Constraint: if billing_rate_snapshot is set, currency must also be set (and vice versa)
-- Using a check constraint rather than NOT NULL because existing rows will have NULLs
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'chk_billing_snapshot_currency'
    AND table_name = 'time_entries'
  ) THEN
    ALTER TABLE time_entries
      ADD CONSTRAINT chk_billing_snapshot_currency
        CHECK (
          (billing_rate_snapshot IS NULL AND billing_rate_currency IS NULL)
          OR
          (billing_rate_snapshot IS NOT NULL AND billing_rate_currency IS NOT NULL)
        );
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'chk_cost_snapshot_currency'
    AND table_name = 'time_entries'
  ) THEN
    ALTER TABLE time_entries
      ADD CONSTRAINT chk_cost_snapshot_currency
        CHECK (
          (cost_rate_snapshot IS NULL AND cost_rate_currency IS NULL)
          OR
          (cost_rate_snapshot IS NOT NULL AND cost_rate_currency IS NOT NULL)
        );
  END IF;
END $$;

-- Index for profitability aggregation queries
CREATE INDEX IF NOT EXISTS idx_time_entries_billing_currency
    ON time_entries (billing_rate_currency)
    WHERE billing_rate_currency IS NOT NULL;

-- Note: The existing rate_cents column is NOT removed in this migration.
-- It is deprecated and will be removed in a future migration once all
-- consumers have migrated to billing_rate_snapshot.
```

## Implementation Guidance

### Step-by-step for TimeEntry entity modification

1. Add four new `@Column` fields after the `rateCents` field:
```java
@Column(name = "billing_rate_snapshot", precision = 12, scale = 2)
private BigDecimal billingRateSnapshot;

@Column(name = "billing_rate_currency", length = 3)
private String billingRateCurrency;

@Column(name = "cost_rate_snapshot", precision = 12, scale = 2)
private BigDecimal costRateSnapshot;

@Column(name = "cost_rate_currency", length = 3)
private String costRateCurrency;
```

2. Add `@Deprecated` on `rateCents`:
```java
@Deprecated
@Column(name = "rate_cents")
private Integer rateCents;
```

3. Add snapshot methods:
```java
public void snapshotBillingRate(BigDecimal rate, String currency) {
    this.billingRateSnapshot = rate;
    this.billingRateCurrency = currency;
}

public void snapshotCostRate(BigDecimal rate, String currency) {
    this.costRateSnapshot = rate;
    this.costRateCurrency = currency;
}
```

4. Add computed getters (import `java.math.BigDecimal` and `java.math.RoundingMode`):
```java
/**
 * Computed billable value: (durationMinutes / 60) * billingRateSnapshot.
 * Returns null if not billable or no billing rate snapshot.
 */
public BigDecimal getBillableValue() {
    if (!billable || billingRateSnapshot == null) {
        return null;
    }
    return BigDecimal.valueOf(durationMinutes)
        .divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP)
        .multiply(billingRateSnapshot);
}

/**
 * Computed cost value: (durationMinutes / 60) * costRateSnapshot.
 * Returns null if no cost rate snapshot. Includes both billable and non-billable.
 */
public BigDecimal getCostValue() {
    if (costRateSnapshot == null) {
        return null;
    }
    return BigDecimal.valueOf(durationMinutes)
        .divide(BigDecimal.valueOf(60), 4, RoundingMode.HALF_UP)
        .multiply(costRateSnapshot);
}
```

5. Add standard getters for new fields:
```java
public BigDecimal getBillingRateSnapshot() {
    return billingRateSnapshot;
}

public String getBillingRateCurrency() {
    return billingRateCurrency;
}

public BigDecimal getCostRateSnapshot() {
    return costRateSnapshot;
}

public String getCostRateCurrency() {
    return costRateCurrency;
}
```

### Step-by-step for TimeEntryService modification

1. Add constructor parameters:
```java
private final BillingRateService billingRateService;
private final CostRateService costRateService;

public TimeEntryService(
    TimeEntryRepository timeEntryRepository,
    TaskRepository taskRepository,
    ProjectAccessService projectAccessService,
    AuditService auditService,
    BillingRateService billingRateService,
    CostRateService costRateService) {
  this.timeEntryRepository = timeEntryRepository;
  this.taskRepository = taskRepository;
  this.projectAccessService = projectAccessService;
  this.auditService = auditService;
  this.billingRateService = billingRateService;
  this.costRateService = costRateService;
}
```

2. In `createTimeEntry()`, after constructing the `TimeEntry` and before `save()`:
```java
var entry = new TimeEntry(taskId, memberId, date, durationMinutes, billable, rateCents, description);

// Snapshot billing rate (ADR-040)
var billingRate = billingRateService.resolveRate(memberId, task.getProjectId(), date);
billingRate.ifPresent(r -> entry.snapshotBillingRate(r.hourlyRate(), r.currency()));

// Snapshot cost rate
var costRate = costRateService.resolveCostRate(memberId, date);
costRate.ifPresent(r -> entry.snapshotCostRate(r.hourlyCost(), r.currency()));

entry = timeEntryRepository.save(entry);
```

3. Update the audit event details in `createTimeEntry()` to include snapshot info (use LinkedHashMap because values might be null):
```java
var auditDetails = new LinkedHashMap<String, Object>();
auditDetails.put("task_id", taskId.toString());
auditDetails.put("duration_minutes", durationMinutes);
auditDetails.put("billable", billable);
auditDetails.put("project_id", task.getProjectId().toString());
if (entry.getBillingRateSnapshot() != null) {
    auditDetails.put("billing_rate_snapshot", entry.getBillingRateSnapshot().toString());
    auditDetails.put("billing_rate_currency", entry.getBillingRateCurrency());
}
if (entry.getCostRateSnapshot() != null) {
    auditDetails.put("cost_rate_snapshot", entry.getCostRateSnapshot().toString());
    auditDetails.put("cost_rate_currency", entry.getCostRateCurrency());
}

auditService.log(
    AuditEventBuilder.builder()
        .eventType("time_entry.created")
        .entityType("time_entry")
        .entityId(entry.getId())
        .details(auditDetails)
        .build());
```

4. In `updateTimeEntry()`, capture old snapshot values and re-snapshot on date change:
```java
// Capture old values before mutation (add to existing captures)
BigDecimal oldBillingRateSnapshot = entry.getBillingRateSnapshot();
String oldBillingRateCurrency = entry.getBillingRateCurrency();
BigDecimal oldCostRateSnapshot = entry.getCostRateSnapshot();
String oldCostRateCurrency = entry.getCostRateCurrency();

// ... existing field mutations ...

// Re-snapshot if date changed (ADR-040: re-resolve on context change)
boolean dateChanged = date != null && !Objects.equals(oldDate, date);
if (dateChanged) {
    LocalDate effectiveDate = entry.getDate(); // already set to new date above
    var billingRate = billingRateService.resolveRate(entry.getMemberId(), task.getProjectId(), effectiveDate);
    if (billingRate.isPresent()) {
        entry.snapshotBillingRate(billingRate.get().hourlyRate(), billingRate.get().currency());
    } else {
        entry.snapshotBillingRate(null, null);
    }

    var costRate = costRateService.resolveCostRate(entry.getMemberId(), effectiveDate);
    if (costRate.isPresent()) {
        entry.snapshotCostRate(costRate.get().hourlyCost(), costRate.get().currency());
    } else {
        entry.snapshotCostRate(null, null);
    }
}

// ... existing save and audit code ...

// Add snapshot deltas to audit details (after existing delta code, before the auditService.log call)
if (dateChanged) {
    if (!Objects.equals(oldBillingRateSnapshot, entry.getBillingRateSnapshot())) {
        details.put("billing_rate_snapshot", Map.of(
            "from", oldBillingRateSnapshot != null ? oldBillingRateSnapshot.toString() : "",
            "to", entry.getBillingRateSnapshot() != null ? entry.getBillingRateSnapshot().toString() : ""));
    }
    if (!Objects.equals(oldBillingRateCurrency, entry.getBillingRateCurrency())) {
        details.put("billing_rate_currency", Map.of(
            "from", oldBillingRateCurrency != null ? oldBillingRateCurrency : "",
            "to", entry.getBillingRateCurrency() != null ? entry.getBillingRateCurrency() : ""));
    }
    if (!Objects.equals(oldCostRateSnapshot, entry.getCostRateSnapshot())) {
        details.put("cost_rate_snapshot", Map.of(
            "from", oldCostRateSnapshot != null ? oldCostRateSnapshot.toString() : "",
            "to", entry.getCostRateSnapshot() != null ? entry.getCostRateSnapshot().toString() : ""));
    }
}
```

### Step-by-step for TimeEntryController Response DTO update

Update `TimeEntryResponse` to include new fields:
```java
public record TimeEntryResponse(
    UUID id,
    UUID taskId,
    UUID memberId,
    String memberName,
    LocalDate date,
    int durationMinutes,
    boolean billable,
    Integer rateCents,
    BigDecimal billingRateSnapshot,
    String billingRateCurrency,
    BigDecimal costRateSnapshot,
    String costRateCurrency,
    BigDecimal billableValue,
    BigDecimal costValue,
    String description,
    Instant createdAt,
    Instant updatedAt) {

  public static TimeEntryResponse from(TimeEntry entry, Map<UUID, String> memberNames) {
    return new TimeEntryResponse(
        entry.getId(),
        entry.getTaskId(),
        entry.getMemberId(),
        memberNames.get(entry.getMemberId()),
        entry.getDate(),
        entry.getDurationMinutes(),
        entry.isBillable(),
        entry.getRateCents(),
        entry.getBillingRateSnapshot(),
        entry.getBillingRateCurrency(),
        entry.getCostRateSnapshot(),
        entry.getCostRateCurrency(),
        entry.getBillableValue(),
        entry.getCostValue(),
        entry.getDescription(),
        entry.getCreatedAt(),
        entry.getUpdatedAt());
  }
}
```

Import `java.math.BigDecimal` in the controller.

### Test implementation guidance

The `TimeEntryRateSnapshotTest` should use a **hybrid approach**:
- Use MockMvc for creating time entries (POST) and reading responses (verifying JSON fields)
- Inject `BillingRateService` and `CostRateService` directly to create rates in `@BeforeAll`
- Use `ScopedValue.where()` pattern from `BillingRateResolutionTest` for direct service calls

**Unique ORG_ID**: Use `"org_timeentry_snapshot_test"` -- must be unique across all test classes.

**Setup seeds** (in `@BeforeAll`):
1. Provision tenant, sync Pro plan
2. Sync 2 members (owner, member) via MockMvc `/internal/members/sync`
3. Look up tenantSchema from `OrgSchemaMappingRepository`
4. Inside `ScopedValue.where()` block: create project via `ProjectService`, create task via MockMvc or `TaskService`
5. Inside `ScopedValue.where()` block: create billing rate for owner (member default, $200/hr USD, effective 2024-01-01, no end) via `BillingRateService.createRate()`
6. Inside `ScopedValue.where()` block: create cost rate for owner ($120/hr USD, effective 2024-01-01, no end) via `CostRateService.createCostRate()`
7. Inside `ScopedValue.where()` block: create a second billing rate for owner for a DIFFERENT date range (e.g. $250/hr, effective 2025-07-01 to 2025-12-31) -- used for re-snapshot test

**Test verification**: Use `jsonPath("$.billingRateSnapshot").value(200.00)` etc. for MockMvc response assertions. For computed values, verify `billableValue` matches expected computation.

**Important**: When creating time entries via MockMvc POST, the JWT mock must match the member who has rates configured (the owner).

## Build & Verify

All commands run from: cd /Users/rakheendama/Projects/2026/worktree-epic-69A/backend

**Step 1: Format**
  ./mvnw spotless:apply 2>&1 | tail -3

**Step 2: Silent full build (Pass 1)**
  ./mvnw clean verify -q > /tmp/mvn-epic-69A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-69A.log | tail -1; else echo "BUILD FAILED (exit $MVN_EXIT)"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); if [ -n "$FAILED" ]; then echo "FAILED TESTS: $FAILED"; else grep -E '\[ERROR\]' /tmp/mvn-epic-69A.log | head -20; fi; fi

**Step 3: Re-run ONLY failed tests with full output (only if Pass 1 failed)**
  ./mvnw verify -Dit.test="{FAILED_CLASSES}" -Dtest="{FAILED_CLASSES}" 2>&1 | tail -80

**Step 4: Silent re-verify after fixing (Pass 2)**
  ./mvnw clean verify -q > /tmp/mvn-epic-69A.log 2>&1; MVN_EXIT=$?; if [ $MVN_EXIT -eq 0 ]; then echo "BUILD SUCCESS"; grep 'Tests run:' /tmp/mvn-epic-69A.log | tail -1; else echo "STILL FAILING"; FAILED=$(grep -rl 'failures="[1-9]\|errors="[1-9]' target/surefire-reports/TEST-*.xml target/failsafe-reports/TEST-*.xml 2>/dev/null | sed 's|.*/TEST-||;s|\.xml||' | paste -sd,); echo "FAILED: $FAILED"; fi

IMPORTANT: NEVER run ./mvnw clean verify without -q.

## Environment
- Postgres host: b2mash.local:5432
- LocalStack host: b2mash.local:4566
- Maven wrapper: ./mvnw from backend dir

## Key Architecture Decisions (from ADR-040)

1. **Point-in-time snapshot**: When a time entry is created, billing and cost rates are resolved and frozen. This ensures historical financial accuracy.
2. **Null snapshots = no rate configured**: Entries with null snapshots contribute to hour summaries but not monetary calculations.
3. **Re-snapshot on date change**: When a time entry's date changes, rates are re-resolved for the new date context. Description/duration/billable-only changes do NOT trigger re-snapshot.
4. **Computed values not stored**: `billableValue` and `costValue` are derived on read (`duration * rate`), not stored as columns.
5. **rateCents deprecated, not removed**: Existing field stays for backward compatibility. Annotated `@Deprecated`. New code uses snapshot fields exclusively.
6. **Billing and cost currencies may differ**: Billing rate might be in client currency (EUR), cost rate in org currency (USD). This is intentional per ADR-041.

## Gotchas

- **Import `java.math.BigDecimal` and `java.math.RoundingMode`** in TimeEntry.java for computed getters.
- **`Map.of()` does not accept null values** -- use `LinkedHashMap` when building audit details that might contain nulls.
- **`@Deprecated` on a record component** -- put it on the constructor parameter in the record definition.
- **Existing tests may break** if the `TimeEntryResponse` shape changes -- the `TimeEntryIntegrationTest` asserts specific fields. Adding new nullable fields to the response should not break existing tests (new fields are just additional), but verify by running the full test suite.
- **Task has `getProjectId()`** -- this is how you get the project context from a task ID for rate resolution.
- **`BigDecimal` comparison in assertions**: Use `isEqualByComparingTo("200.00")` from AssertJ, not `isEqualTo()`, because BigDecimal scale may differ (e.g., `200.00` vs `200.0000`).
- **JSON number serialization**: Jackson serializes `BigDecimal` as a number, so `jsonPath("$.billingRateSnapshot").value(200.00)` works. But for exact matching, prefer `.value(org.hamcrest.Matchers.closeTo(200.00, 0.01))` if scale issues arise.
