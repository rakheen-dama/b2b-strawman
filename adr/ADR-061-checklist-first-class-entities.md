# ADR-061: Checklist Engine — First-Class Entities

**Status**: Accepted

**Context**: Phase 14 introduces an onboarding checklist system. Checklists have templates (the recipe: "what verification steps are required for individual customers?"), instances (instantiated for a specific customer when they start onboarding), and items (individual steps: "Verify identity document", "Upload proof of address"). The question is how to model this data: as first-class relational entities (4 tables), as a JSONB blob on the Customer entity, as an extension of the existing Task entity, or as a hybrid two-table approach (templates and instances as tables, items as JSONB arrays).

The answer affects queryability (can we query for all checklists with incomplete identity verification steps?), audit trail (who verified identity? when?), referential integrity (can we link a checklist item to a specific Document upload?), and the separation of templates (reusable recipes) from instances (per-customer execution state).

**Options Considered**:

1. **First-class entities (ChecklistTemplate, ChecklistTemplateItem, ChecklistInstance, ChecklistInstanceItem) — 4 tables** — Dedicate a relational table to each concept. Templates and instances are separate tables. Template items and instance items are separate tables. Items have FKs to their parent (template or instance) and to related entities (Document uploads).
   - Pros:
     - Full queryability: "Show me all customers with incomplete identity verification items" = `SELECT DISTINCT ci.customer_id FROM checklist_instance_items cii JOIN checklist_instances ci ON cii.instance_id = ci.id WHERE cii.name LIKE '%identity%' AND cii.status != 'COMPLETED'`. Cannot do this with JSONB without expensive JSONB array unnesting and pattern matching.
     - Per-item audit trail: Each `ChecklistInstanceItem` has `completed_at`, `completed_by`, and `notes`. An auditor can see exactly who verified identity on 2025-02-10 at 14:32 and what notes they added. JSONB stores this as nested objects — harder to query, no FK to the Member who completed it.
     - Referential integrity: `ChecklistInstanceItem.document_id FK -> documents` ensures the linked document exists and is tenant-scoped. The checklist item cannot point to a non-existent or cross-tenant document. JSONB stores a UUID string — no FK, no referential integrity.
     - Dependency enforcement: `ChecklistInstanceItem.depends_on_item_id FK -> checklist_instance_items` enforces linear dependencies between items (e.g., "Upload ID document" must be completed before "Verify ID document"). The service layer queries this FK to check whether dependencies are met before allowing item completion. JSONB stores a reference by UUID string — must deserialize, find the dependency item, check its status. No relational guarantee that the dependency exists.
     - Template/instance separation: Templates are defined once and reused for many customers. Instances are snapshots created from templates at a point in time. If the template changes (new item added, old item removed), in-progress instances are not affected. This is critical for compliance: the verification requirements that applied when onboarding started are the requirements that must be met. The 4-table model separates templates from instances cleanly — they are independent tables with their own lifecycle.
     - Standard relational patterns: Developers understand `findByInstanceId()`, `existsByInstanceIdAndStatus()`, `countByCustomerIdAndRequired()`. These are JPQL queries with type-safe parameters. JSONB queries require native SQL with JSONB path operators (`@>`, `->`, `->>`), which are less familiar and harder to test.
     - Test assertions are simpler: `assertThat(repository.findByInstanceId(id)).hasSize(3)` vs. `assertThat(customer.getCustomFields().get("checklist").get("items")).hasSize(3)` (with null checks, JSONB deserialization, and type casting).
   - Cons:
     - 4 tables is more complex than a single JSONB column. Schema change (migration V29) adds 4 new tables with indexes and constraints.
     - Querying a complete checklist (instance + all items) requires a join: `SELECT ci, cii FROM ChecklistInstance ci LEFT JOIN ChecklistInstanceItem cii ON ci.id = cii.instance_id WHERE ci.id = ?`. JSONB stores the entire checklist in one row — no join needed. However, this is a minor cost (one indexed FK join) for the queryability and integrity benefits.
     - Data duplication: When a template is instantiated, every `ChecklistTemplateItem` is copied into a `ChecklistInstanceItem` (name, description, sort order, required flag, document requirement, dependency references). If a template has 10 items and 100 customers instantiate it, there are 1,000 instance item rows. JSONB would store 100 blobs (one per customer). However, instance items track individual completion state (`status`, `completed_by`, `completed_at`, `notes`, `document_id`) — this is not duplication, it is per-customer execution state.

2. **JSONB blob on Customer — store checklist state as a JSON object on the Customer entity** — Add a `checklist_state JSONB` column to the Customer table. Store the entire checklist structure (templates instantiated, items, completion state) as a nested JSON object: `{templates: [{templateId, name, items: [{itemId, name, status, completedBy, completedAt, notes, documentId}]}]}`.
   - Pros:
     - Minimal schema change: one column added to the Customer table. No new tables, no new indexes.
     - Single-row fetch: `SELECT checklist_state FROM customers WHERE id = ?` retrieves the entire checklist in one query. No joins, no N+1 queries.
     - Flexible schema: if the checklist structure changes (new fields added, e.g., "approval_required"), JSONB can accommodate this without a migration. Just add the key to the JSON object.
   - Cons:
     - No per-item queryability: "Find all customers with incomplete identity verification" requires scanning all customer rows, unnesting the JSONB array, and pattern-matching item names. This is `SELECT c.id FROM customers c, jsonb_array_elements(c.checklist_state->'templates') AS tpl, jsonb_array_elements(tpl->'items') AS item WHERE item->>'name' LIKE '%identity%' AND item->>'status' != 'COMPLETED'`. This is slow (full table scan + JSONB unnesting) and complex (lateral joins, JSONB path operators).
     - No referential integrity: `documentId` is a UUID string stored in JSONB. There is no FK to the `documents` table. The checklist item can point to a non-existent document, a document in the wrong tenant, or a deleted document. No database-level guarantee.
     - No per-item audit trail: `completedBy` is a UUID string in JSONB. There is no FK to the `members` table. No relational query for "all checklist items completed by Alice." Must scan all customers, unnest JSONB, filter by `completedBy`. Cannot join to Member to get name/email.
     - Template/instance separation is lost: The JSONB blob mixes template metadata (what items are defined) with instance state (which items are completed). If a template is updated, there is no clean way to distinguish "this customer is using template v1" from "this customer is using template v2." The blob does not track `template_id` or `instantiated_at` as first-class fields.
     - Snapshot behaviour is manual: When a template changes, the service layer must manually ensure in-progress checklists are not affected. With relational tables, the snapshot happens at instantiation (copy template items into instance items). With JSONB, the snapshot is implicit (the blob does not change when the template changes) but there is no audit trail of which template version was used.
     - Testing is harder: Asserting that a checklist item is in a specific state requires deserializing JSONB, navigating nested objects, and checking string values. No type safety, no IDE autocomplete.

3. **Generic task/workflow engine — extend the existing Task entity to serve as checklist items** — Reuse the `tasks` table (Phase 4 entity). Add a `task_type` column (`WORK_ITEM` vs. `CHECKLIST_ITEM`) and a `checklist_template_id` nullable FK. Checklist items are tasks with a special type.
   - Pros:
     - Reuses existing infrastructure: The Task entity already has `status`, `assignee`, `created_at`, `completed_at`. These fields map to checklist item semantics.
     - Single table for all "to-do items": Work tasks and checklist items are both things that need to be completed. A unified table simplifies the mental model.
     - Fewer new tables: Only `ChecklistTemplate` and `ChecklistInstance` are new. Items are represented as Task rows.
   - Cons:
     - Semantic mismatch: A Task is work to be done (design a feature, fix a bug). A checklist item is a verification step (confirm identity, upload document). Work tasks are assigned to members and have deadlines. Checklist items are not assigned (any admin can complete them) and have no deadlines (they are blocking requirements, not scheduled work). Overloading the Task entity with two different semantics creates confusion.
     - Task filtering is polluted: "Show me all open tasks for this customer" now includes checklist items, which are not work tasks. The UI must filter by `task_type` everywhere. The query complexity increases (`WHERE task_type = 'WORK_ITEM'` added to every task query).
     - Checklist-specific fields do not belong on Task: `requires_document`, `required_document_label`, `depends_on_item_id` (linear dependency, not subtask hierarchy). Adding these fields to the Task table pollutes it with checklist semantics. They are nullable for work tasks, required for checklist items — the schema cannot enforce this distinction.
     - Template/instance separation is unclear: Tasks are work items tied to a project. Checklist items are verification steps tied to a template and instantiated for a customer. A Task has `project_id`; a checklist item has `instance_id`. The FK relationships are different. Forcing both into the Task table requires making `project_id` nullable, which weakens referential integrity for work tasks.
     - No template concept: The Task entity has no equivalent to `ChecklistTemplate` (the recipe). Templates define reusable verification steps; tasks are individual work items. The two are fundamentally different. Extending Task to support templates (via `checklist_template_id`) is a hack — it stores template metadata (sort order, required flag, document requirement) on Task rows that are not yet instantiated, which is confusing.

4. **Two-table approach — ChecklistTemplate (with items as JSONB array) + ChecklistInstance (with items as JSONB array)** — Store templates and instances as relational tables, but store items as JSONB arrays on the template/instance: `ChecklistTemplate.items JSONB` = `[{name, description, sortOrder, required, requiresDocument, dependsOnItemId}]`, `ChecklistInstance.items JSONB` = `[{name, status, completedBy, completedAt, notes, documentId}]`.
   - Pros:
     - Fewer tables: 2 instead of 4. Simpler schema.
     - Template/instance separation is preserved: Templates and instances are separate tables. Changing a template does not affect in-progress instances.
     - Single-row fetch for a checklist: `SELECT * FROM checklist_instances WHERE id = ?` retrieves the instance and all items in one query.
   - Cons:
     - No per-item queryability: "Find all customers with incomplete identity verification items" requires unnesting the JSONB array and pattern-matching. Same complexity as Option 2.
     - No referential integrity for document links: `documentId` is a UUID string in JSONB. No FK, no guarantee the document exists or is in the correct tenant.
     - No per-item audit trail: `completedBy` is a UUID string in JSONB. No FK to Member. Cannot query "all items completed by Alice" without scanning all instances and unnesting JSONB.
     - Dependency enforcement is manual: `dependsOnItemId` is a UUID string in JSONB. The service layer must deserialize the JSONB array, find the dependency item by UUID, and check its status. No relational FK to guarantee the dependency exists.
     - Testing is harder: Asserting item completion state requires JSONB deserialization and nested object navigation. No type safety.

**Decision**: First-class entities (ChecklistTemplate, ChecklistTemplateItem, ChecklistInstance, ChecklistInstanceItem) — 4 tables (Option 1).

**Rationale**: The checklist is the core value proposition of Phase 14. It is not a side feature — it is the mechanism by which orgs ensure compliance before activating customers. Each item must have an individual audit trail (who verified identity? when? what notes did they add?), document linking (FK to the uploaded ID document), and completion tracking. These requirements demand relational integrity and queryability.

JSONB (Options 2 and 4) sacrifices queryability, referential integrity, and audit trail for the sake of schema simplicity. The cost is too high. Compliance auditing requires per-item queries ("show me all identity verifications completed by Alice in February") and FK guarantees (the linked document must exist and be tenant-scoped). JSONB cannot provide this without expensive unnesting and manual integrity checks.

Extending the Task entity (Option 3) was rejected because tasks and checklist items have different semantics. A task is work to be done; a checklist item is a verification step. Overloading the Task entity with two different meanings pollutes the task queries and weakens referential integrity. The Task entity has `project_id`; checklist items have `instance_id`. The FK relationships are incompatible.

The 4-table model is more complex than JSONB, but the complexity is justified by the queryability, integrity, and audit trail benefits. The join cost (fetching a checklist instance + all items) is minimal (one indexed FK join). The data "duplication" (copying template items into instance items) is not duplication — it is snapshotting, which is required for compliance (in-progress checklists must not be affected by template changes).

**Consequences**:
- Four new tables in migration V29: `checklist_templates`, `checklist_template_items`, `checklist_instances`, `checklist_instance_items`.
- `ChecklistTemplateItem.template_id FK -> checklist_templates` (cascade delete: deleting a template deletes its items).
- `ChecklistInstanceItem.instance_id FK -> checklist_instances` (cascade delete: deleting an instance deletes its items).
- `ChecklistInstanceItem.template_item_id FK -> checklist_template_items` (preserved for audit trail: which template item was this based on?).
- `ChecklistInstanceItem.document_id FK -> documents` (nullable, required if `requires_document = true` and `status = COMPLETED`).
- `ChecklistInstanceItem.depends_on_item_id FK -> checklist_instance_items` (nullable, linear dependency: this item cannot progress until the dependency is completed).
- Snapshot behaviour: When a `ChecklistTemplate` is instantiated (customer transitions to `ONBOARDING`), every `ChecklistTemplateItem` is copied into a `ChecklistInstanceItem`. The copy includes `name`, `description`, `sort_order`, `required`, `requires_document`, `required_document_label`, and `depends_on_item_id`. The `template_item_id` FK is set for audit trail, but runtime behaviour uses the snapshotted fields (not a live reference to the template item). Template changes do not affect in-progress instances.
- Completion logic: An instance item transitions to `COMPLETED` when an admin marks it complete (sets `status`, `completed_by`, `completed_at`, `notes`, and optionally `document_id`). If all `required = true` items in an instance are `COMPLETED`, the instance automatically transitions to `COMPLETED`. If all active instances for a customer are `COMPLETED` and the customer is in `ONBOARDING`, the lifecycle status transitions to `ACTIVE`.
- Query patterns: `findByInstanceId(UUID instanceId)` fetches all items for an instance. `existsByInstanceIdAndStatusNot(UUID instanceId, ItemStatus status)` checks for incomplete items. `countByCustomerIdAndRequired(UUID customerId, boolean required)` counts required items for a customer's checklists.
- Repository interfaces: `ChecklistTemplateRepository`, `ChecklistTemplateItemRepository`, `ChecklistInstanceRepository`, `ChecklistInstanceItemRepository` — standard Spring Data JPA repositories with custom query methods.
- Service layer: `ChecklistTemplateService` (create/update templates and items), `ChecklistInstanceService` (instantiate templates, complete items, transition instances), `ChecklistInstantiationService` (auto-instantiation when a customer transitions to `ONBOARDING`).
- Frontend: `ChecklistTemplateList` (manage templates), `ChecklistTemplateForm` (create/edit templates and items), `ChecklistInstancePanel` (view/complete items for a customer), `ChecklistInstanceItemRow` (per-item completion UI with document upload and notes).
