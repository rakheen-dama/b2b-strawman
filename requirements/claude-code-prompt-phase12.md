You are a senior SaaS architect working on an existing multi-tenant "DocTeams" style platform.

The current system already has:

- Organizations as tenants (via Clerk Organizations), with Starter (shared schema) and Pro (schema-per-tenant) tiers.
- Projects, Customers, Tasks, TimeEntries, and Documents (with org/project/customer scopes).
- Internal staff users authenticated via Clerk, with org-scoped RBAC (admin, owner, member).
- Neon Postgres + S3 + Spring Boot 4 backend + Next.js 16 frontend, running on ECS/Fargate.
- **Time tracking** (Phase 5): `TimeEntry` entity with member, task, project, date, duration, and notes. Project time rollups and "My Work" cross-project dashboard.
- **Audit event infrastructure** (Phase 6): domain mutation logging with queryable API.
- **Comments, notifications, and activity feeds** (Phase 6.5): in-app notification system with `ApplicationEvent`-based fan-out, notification preferences, comment system on tasks/documents, project activity feed.
- **Customer portal backend** (Phase 7): magic links, read-model schema, portal contacts, portal APIs.
- **Rate cards, budgets & profitability** (Phase 8): `BillingRate` (3-level hierarchy: org-default -> project-override -> customer-override), `CostRate`, `ProjectBudget`, `OrgSettings` (default currency). Time entries have `billable` flag, `billing_rate_snapshot`, `cost_rate_snapshot`. Profitability reports.
- **Operational dashboards** (Phase 9): company dashboard, project overview, personal dashboard, health scoring.
- **Invoicing & billing from time** (Phase 10): Invoice/InvoiceLine entities, draft-to-paid lifecycle, unbilled time management, PSP adapter seam, HTML invoice preview via Thymeleaf.
- **Tags, custom fields & views** (Phase 11): `FieldDefinition`, `FieldGroup`, `Tag`, `EntityTag`, `SavedView` entities. JSONB custom field values on projects, tasks, and customers. Platform-shipped field packs with per-tenant seeding. Saved filtered views with custom column selection.

For **Phase 12**, I want to add **Document Templates & Generation** — a system for generating professional documents (engagement letters, statements of work, project summaries, cover letters) from Thymeleaf templates merged with entity data, custom fields, and org branding, rendered as downloadable PDFs.

***

## Objective of Phase 12

Design and specify:

1. **DocumentTemplate entity** — template definitions with Thymeleaf content, categorized by purpose (engagement letter, SOW, NDA, etc.) and scoped to a primary entity type (project, customer, invoice) that determines where the "Generate" button appears.
2. **Rich rendering context** — a data assembly layer that builds a nested context object from the primary entity and all reachable related entities (customer, project, org settings, members, custom fields), so templates can reference any data in the graph.
3. **PDF generation** — server-side HTML-to-PDF conversion using OpenHTMLToPDF, producing downloadable PDFs that can optionally be saved as project/customer documents in S3.
4. **Org branding** — extension of OrgSettings with logo (S3 upload), brand color, and document footer text, injected into every template render.
5. **Template packs** — platform-shipped seed templates (similar to field packs in Phase 11), with fork-friendly vertical packs. Orgs can clone and customize platform templates.
6. **Template management UI** — browse templates by category, preview with live entity data, generate for a specific entity, manage org-customized templates.
7. **Generated document tracking** — record of generated documents with metadata (template used, entity context, generated by, timestamp), linked to the project/customer document system.

***

## Constraints and assumptions

1. **Architecture/stack constraints**

- Keep the existing stack:
    - Spring Boot 4 / Java 25.
    - Neon Postgres (existing tenancy model).
    - Next.js 16 frontend with Shadcn UI.
- Do not introduce:
    - Headless Chrome / Puppeteer for PDF generation — use OpenHTMLToPDF (pure Java, no external process).
    - A separate template engine — Thymeleaf is already in use for invoice HTML preview (Phase 10, Epic 85B). Reuse the same engine.
    - WYSIWYG rich-text editor (TipTap, Plate.js, etc.) — template editing is direct HTML/Thymeleaf for v1. A visual editor is a future phase.
    - Client-side PDF generation (jsPDF, etc.) — all rendering is server-side.
- Template content is stored in the database (not filesystem or S3) for tenant-scoped access and versioning.
- OpenHTMLToPDF handles the HTML → PDF conversion. Templates must use CSS compatible with OpenHTMLToPDF's rendering subset (CSS 2.1 + some CSS3 properties — no flexbox/grid in PDFs, use tables for layout). The architecture doc should note this constraint.

2. **Tenancy**

- All new entities (`DocumentTemplate`, `GeneratedDocument`) follow the same tenant isolation model as existing entities:
    - Pro orgs: dedicated schema.
    - Starter orgs: `tenant_shared` schema with `tenant_id` column + Hibernate `@Filter` + RLS.
- All new entities must include Flyway migrations for both tenant and shared schemas.
- Template packs are seeded per-tenant during tenant provisioning (same pattern as field packs in Phase 11).

3. **Permissions model**

- Template management (create, edit, delete, clone templates):
    - Org admins and owners only.
- Template usage (generate a document from a template):
    - Any member who has access to the primary entity. If you can view the project, you can generate a document from a project-scoped template.
- Generated document management (view, download, delete generated documents):
    - Same permissions as the parent entity (project or customer). If you can view the project, you can view its generated documents.
- Org branding settings (logo upload, brand color, footer text):
    - Org admins and owners only (same as existing OrgSettings).

4. **Relationship to existing entities**

- **OrgSettings**: Extended with `logoUrl` (VARCHAR, nullable — S3 key for uploaded logo), `brandColor` (VARCHAR(7), nullable — hex color), `documentFooterText` (TEXT, nullable — custom footer for generated docs). These fields are injected into every template rendering context.
- **Document**: Generated PDFs can optionally be saved as Documents (existing entity), linked to a project or customer. The generated document retains a reference to its source template and generation context.
- **Invoice**: Invoice-scoped templates extend the existing HTML preview system. The invoice preview (Phase 10) already uses Thymeleaf — invoice templates are a superset that adds branding, custom layouts, and PDF output.
- **Custom Fields** (Phase 11): Template variables include all custom field values from the primary entity and related entities. Templates reference custom fields via `${entity.customFields.slug}` syntax.
- **S3**: Logo uploads use the existing S3 integration. Generated PDFs are stored in S3 with the same key pattern as document uploads.
- **AuditEvent**: Template lifecycle events (created, updated, deleted, cloned) and document generation events are audited.

5. **Out of scope for Phase 12**

- WYSIWYG template editor (visual drag-and-drop). Template editing is HTML/Thymeleaf source in a code editor component.
- AI-assisted template creation from uploaded Word/PDF documents (future AI phase).
- E-signature integration (DocuSign, HelloSign). The generated PDF is a static document.
- Template versioning history (edit-by-edit changelog). Templates have a single current version per record.
- Conditional template sections based on data (e.g., "show this paragraph only if customer has field X"). Thymeleaf natively supports `th:if` — document this as a template authoring capability but don't build UI for conditional logic.
- Batch document generation (generate the same template for multiple entities at once).
- Email delivery of generated documents (generate + auto-email to customer). Documents are downloaded or saved to the document system.
- Template sharing across orgs or a public template marketplace.
- Multi-language template support (templates are single-language; the org writes them in their preferred language).
- Document merge (combining multiple templates into a single PDF).

***

## What I want you to produce

Produce a **self-contained markdown document** that can be added as `architecture/phase12-document-templates.md`, plus ADRs for key decisions.

### 1. DocumentTemplate entity

Design the **DocumentTemplate** entity:

1. **Data model**

    - `DocumentTemplate` entity:
        - `id` (UUID).
        - `tenant_id` (for shared-schema isolation).
        - `name` (VARCHAR(200) — human-readable template name, e.g., "Standard Engagement Letter," "Project Summary Report").
        - `slug` (VARCHAR(200) — machine-readable key, auto-generated from name, e.g., "standard-engagement-letter").
        - `description` (TEXT, nullable — describes when to use this template).
        - `category` (ENUM: `ENGAGEMENT_LETTER`, `STATEMENT_OF_WORK`, `COVER_LETTER`, `PROJECT_SUMMARY`, `NDA`, `PROPOSAL`, `REPORT`, `OTHER` — broad categorization for browsing/filtering).
        - `primary_entity_type` (ENUM: `PROJECT`, `CUSTOMER`, `INVOICE` — determines where the "Generate" button appears and what the root context object is).
        - `content` (TEXT — Thymeleaf template content, HTML with `th:*` attributes and `${variable}` expressions).
        - `css` (TEXT, nullable — optional custom CSS for this template. Merged with default document styles at render time).
        - `source` (ENUM: `PLATFORM`, `ORG_CUSTOM` — whether this is a platform-shipped template or an org-created/cloned template).
        - `source_template_id` (UUID, nullable, FK -> document_templates — if this is a clone of a platform template, references the original. Null for platform templates and org-created-from-scratch templates).
        - `pack_id` (VARCHAR, nullable — template pack this definition originated from, e.g., "common-templates". Same pattern as field packs in Phase 11).
        - `pack_template_key` (VARCHAR, nullable — template's key within its pack).
        - `active` (BOOLEAN, default true — soft-delete flag).
        - `sort_order` (INTEGER — display order within category).
        - `created_at`, `updated_at` timestamps.
    - Constraints:
        - `(tenant_id, slug)` is unique — no duplicate template slugs within an org.
        - `slug` must match pattern `[a-z][a-z0-9-]*` (lowercase, hyphen-separated).
        - `pack_id` and `pack_template_key` are both null or both non-null.
    - Indexes:
        - `(tenant_id, category, active)` for listing templates by category.
        - `(tenant_id, primary_entity_type, active)` for finding templates applicable to a specific entity.
        - `(tenant_id, slug)` unique.
        - `(tenant_id, pack_id)` for finding all templates from a specific pack.

2. **Template content structure**

    Templates are full HTML documents (not fragments) with Thymeleaf expressions:

    ```html
    <!DOCTYPE html>
    <html xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8"/>
        <style th:inline="text">
            /* Default styles + org brand color */
            :root { --brand-color: [[${org.brandColor ?: '#1a1a2e'}]]; }
            body { font-family: 'Helvetica Neue', Arial, sans-serif; margin: 40px; color: #333; }
            .header { border-bottom: 3px solid var(--brand-color); padding-bottom: 20px; margin-bottom: 30px; }
            .logo { max-height: 60px; }
            .footer { margin-top: 40px; border-top: 1px solid #ddd; padding-top: 10px; font-size: 11px; color: #666; }
        </style>
    </head>
    <body>
        <div class="header">
            <img th:if="${org.logoUrl}" th:src="${org.logoUrl}" class="logo" alt="Logo"/>
            <h1 th:text="${org.name}">Organization Name</h1>
        </div>

        <h2>Engagement Letter</h2>

        <p>Dear <span th:text="${customer.name}">Customer Name</span>,</p>

        <p>We are pleased to confirm our engagement regarding
           <span th:text="${project.name}">Project Name</span>.</p>

        <p th:if="${customer.customFields?.tax_number}">
            Tax Reference: <span th:text="${customer.customFields.tax_number}">TAX123</span>
        </p>

        <div class="footer">
            <p th:text="${org.documentFooterText}">Organization Address | Phone | Email</p>
        </div>
    </body>
    </html>
    ```

    Document the full set of available template variables for each primary entity type (see Section 2).

### 2. Rendering context assembly

Design the data assembly layer that builds the template context:

1. **Context object structure by primary entity type**

    - **PROJECT-scoped templates** — context includes:
        - `project` — project fields: id, name, status, description, createdAt, updatedAt, customFields (map)
        - `customer` — the project's linked customer (if any): id, name, email, customFields
        - `lead` — the project lead member: id, name, email
        - `members` — list of project members: [{id, name, email, role}]
        - `org` — org settings: name, defaultCurrency, logoUrl, brandColor, documentFooterText
        - `budget` — project budget (if any): hours, amount, currency, status
        - `tags` — project tags: [{name, color}]
        - `generatedAt` — ISO timestamp of generation
        - `generatedBy` — member who triggered generation: name, email

    - **CUSTOMER-scoped templates** — context includes:
        - `customer` — customer fields: id, name, email, customFields
        - `projects` — list of customer's projects: [{id, name, status}]
        - `org` — same as above
        - `tags` — customer tags
        - `generatedAt`, `generatedBy`

    - **INVOICE-scoped templates** — context includes:
        - `invoice` — invoice fields: id, invoiceNumber, status, issueDate, dueDate, subtotal, taxAmount, total, currency, notes
        - `lines` — invoice lines: [{description, quantity, unitPrice, amount}]
        - `customer` — the invoice's customer: id, name, email, customFields
        - `project` — the invoice's project: id, name, customFields
        - `org` — same as above
        - `generatedAt`, `generatedBy`

2. **Context assembly service**

    - A `TemplateContextBuilder` service that takes a primary entity type + entity ID and assembles the full context map.
    - Each entity in the context is loaded via its existing service layer (respecting tenant isolation and access control).
    - Custom field values from Phase 11 are included as nested maps: `customer.customFields.tax_number`, `project.customFields.case_number`.
    - The builder returns a `Map<String, Object>` that is passed to the Thymeleaf template engine.
    - If a related entity doesn't exist (e.g., project has no customer), that context variable is null — templates use `th:if` to handle optional data gracefully.

3. **Logo URL resolution**

    - The `org.logoUrl` in the context must be a data URI (base64-encoded image) or an absolute URL accessible to OpenHTMLToPDF during rendering. S3 pre-signed URLs work for this purpose.
    - The context builder resolves the S3 key to a pre-signed URL (short TTL — 5 minutes, only needed during rendering).

### 3. PDF generation

Design the PDF generation pipeline:

1. **Rendering pipeline**

    - Step 1: **Context assembly** — `TemplateContextBuilder` loads all entity data into a context map.
    - Step 2: **Thymeleaf rendering** — process the template content + context → produces a complete HTML string.
    - Step 3: **CSS merging** — merge the template's custom CSS (if any) with default document styles (page size, margins, font imports).
    - Step 4: **HTML → PDF** — pass the HTML string to OpenHTMLToPDF, which produces PDF bytes.
    - Step 5: **Storage** — if the user chose "Save to Documents," upload the PDF to S3 and create a Document entity linked to the project/customer.
    - Step 6: **Tracking** — create a `GeneratedDocument` record capturing the generation metadata.

2. **OpenHTMLToPDF configuration**

    - Page size: A4 (default), with option for US Letter in template CSS via `@page { size: letter; }`.
    - Margins: 20mm all sides (default).
    - Font embedding: embed default fonts (Helvetica/Arial equivalent) for consistent rendering across environments.
    - Image handling: support external images via URL (pre-signed S3 URLs for logos).
    - CSS support notes: document which CSS properties are supported (CSS 2.1 baseline, selected CSS3). Explicitly note: no flexbox, no grid — use tables or floats for multi-column layouts.

3. **Preview endpoint**

    - A preview endpoint that returns the rendered HTML (not PDF) for browser preview before generation.
    - This allows users to verify the output before committing to PDF generation.
    - The preview uses the same rendering pipeline (steps 1-2) but returns HTML directly instead of converting to PDF.

4. **Maven dependency**

    - `com.openhtmltopdf:openhtmltopdf-pdfbox` — the core PDF rendering library.
    - `com.openhtmltopdf:openhtmltopdf-svg-support` — if SVG logo support is needed.

### 4. Org branding (OrgSettings extension)

Design the branding additions to OrgSettings:

1. **New fields on OrgSettings entity**

    - `logoUrl` (VARCHAR(500), nullable) — S3 object key for the org's uploaded logo. Not a full URL — resolved at render time.
    - `brandColor` (VARCHAR(7), nullable) — hex color code (e.g., "#1a1a2e"). Used as accent color in document headers, borders, etc.
    - `documentFooterText` (TEXT, nullable) — free-text footer line rendered at the bottom of every generated document. Typically contains firm address, phone, email, registration numbers.

2. **Logo upload endpoint**

    - `POST /api/settings/logo` — multipart file upload. Accepts PNG, JPG, SVG (max 2MB). Stores in S3 under `{tenantId}/branding/logo.{ext}`. Returns the S3 key.
    - `DELETE /api/settings/logo` — remove the logo. Deletes from S3 and clears `logoUrl`.
    - The existing OrgSettings `PUT /api/settings` endpoint is extended to accept `brandColor` and `documentFooterText`.

3. **Frontend branding settings**

    - Add a "Branding" section to the org settings page (or a new tab).
    - Logo upload with preview (drag-and-drop or file picker).
    - Brand color picker (hex input or color wheel).
    - Footer text textarea.
    - Live preview showing how the branding appears in a sample document header/footer.

### 5. Template packs

Design the seed template mechanism:

1. **Pack definition format**

    - Template packs are defined as directories under `src/main/resources/template-packs/`:
        ```
        template-packs/
            common/
                pack.json
                engagement-letter.html
                project-summary.html
                invoice-cover-letter.html
        ```
    - `pack.json` defines the pack metadata and template list:
        ```json
        {
            "packId": "common",
            "name": "Common Templates",
            "description": "Standard business document templates",
            "templates": [
                {
                    "key": "engagement-letter",
                    "name": "Engagement Letter",
                    "description": "Standard client engagement / service agreement letter",
                    "category": "ENGAGEMENT_LETTER",
                    "primaryEntityType": "PROJECT",
                    "contentFile": "engagement-letter.html",
                    "sortOrder": 1
                },
                {
                    "key": "project-summary",
                    "name": "Project Summary Report",
                    "description": "Overview of project status, team, budget, and time spent",
                    "category": "PROJECT_SUMMARY",
                    "primaryEntityType": "PROJECT",
                    "contentFile": "project-summary.html",
                    "sortOrder": 2
                },
                {
                    "key": "invoice-cover-letter",
                    "name": "Invoice Cover Letter",
                    "description": "Cover letter to accompany an invoice",
                    "category": "COVER_LETTER",
                    "primaryEntityType": "INVOICE",
                    "contentFile": "invoice-cover-letter.html",
                    "sortOrder": 3
                }
            ]
        }
        ```
    - Template content files are separate `.html` files (not inlined in JSON) for readability and editor support.

2. **Seeding mechanism**

    - Same pattern as field packs (Phase 11): seeded during tenant provisioning.
    - The provisioning service reads all pack directories from the classpath, creates tenant-scoped `DocumentTemplate` records with `source = PLATFORM`, `pack_id`, and `pack_template_key` set.
    - Pack versioning and update tracking follow the same model as field packs.

3. **Platform-shipped packs (v1)**

    Ship one default pack:

    - `common`: Engagement Letter (PROJECT), Project Summary Report (PROJECT), Invoice Cover Letter (INVOICE).

    Vertical forks add their own packs (not shipped with core):
    - `legal`: Matter Engagement Letter, Power of Attorney template, Court Filing Cover Sheet.
    - `accounting`: Audit Engagement Letter, Tax Return Cover Letter.
    - `agency`: Statement of Work, Creative Brief Summary.

4. **Template cloning (customization)**

    - When an org wants to customize a platform template, they "clone" it: a new `ORG_CUSTOM` record is created with `source_template_id` pointing to the original.
    - The org's clone takes precedence when listing available templates (platform original is hidden if an org clone exists for the same `pack_template_key`).
    - Cloning copies the content and CSS — the org can then freely edit their version.
    - A "Reset to Default" action deletes the org clone, restoring the platform template.

### 6. GeneratedDocument tracking

Design the tracking entity for generated documents:

1. **Data model**

    - `GeneratedDocument` entity:
        - `id` (UUID).
        - `tenant_id`.
        - `template_id` (UUID, FK -> document_templates — which template was used).
        - `primary_entity_type` (ENUM: `PROJECT`, `CUSTOMER`, `INVOICE`).
        - `primary_entity_id` (UUID — the entity the document was generated for).
        - `document_id` (UUID, nullable, FK -> documents — if the PDF was saved to the document system).
        - `file_name` (VARCHAR — the generated PDF filename, e.g., "engagement-letter-acme-corp-2026-02-15.pdf").
        - `s3_key` (VARCHAR — S3 storage key for the generated PDF).
        - `file_size` (BIGINT — PDF file size in bytes).
        - `generated_by` (UUID — member who triggered the generation).
        - `generated_at` (TIMESTAMP).
        - `context_snapshot` (JSONB, nullable — optional snapshot of key context values at generation time for audit trail, e.g., `{ customerName, projectName, invoiceNumber }`). Not the full context — just human-readable identifiers.
    - Constraints:
        - Standard tenant isolation (tenant_id + @Filter).
    - Indexes:
        - `(tenant_id, primary_entity_type, primary_entity_id)` for "list generated documents for this entity."
        - `(tenant_id, template_id)` for "how many times has this template been used."
        - `(tenant_id, generated_by)` for "my generated documents."

2. **Retention**

    - Generated documents are retained indefinitely (same as uploaded documents).
    - If the source template is deleted (soft-delete), existing generated documents remain accessible.

### 7. Frontend — template management and generation

Design the frontend components:

1. **Template management page** (`/org/[slug]/settings/templates`)

    - Admin/owner only.
    - List all templates grouped by category, with toggle for active/inactive.
    - Each template card shows: name, description, category badge, primary entity type badge, source badge (Platform / Custom).
    - Actions per template:
        - **Preview** — opens a dialog showing the template rendered with sample/placeholder data.
        - **Edit** (ORG_CUSTOM only) — opens a template editor view.
        - **Clone** (PLATFORM only) — creates an org-custom copy for editing.
        - **Reset to Default** (ORG_CUSTOM with source_template_id) — deletes the custom version.
        - **Deactivate/Activate** — soft-delete toggle.
    - "Create Template" button — for creating templates from scratch (ORG_CUSTOM, no source_template_id).

2. **Template editor page** (`/org/[slug]/settings/templates/[id]/edit`)

    - Admin/owner only.
    - Form fields: name, description, category (dropdown), primary entity type (dropdown).
    - Template content: code editor component (monospace textarea or a lightweight code editor like CodeMirror/Monaco — but keep it simple, a styled textarea is fine for v1).
    - Custom CSS: optional textarea.
    - **Variable reference panel** — a sidebar or collapsible section listing all available template variables for the selected primary entity type. Organized by context object (project, customer, org, etc.). Click to insert `${variable.path}` at cursor position.
    - **Live preview** — a preview pane (or preview tab) that renders the template with sample data. Fetches from the preview endpoint.
    - Save button.

3. **Generate document flow** (on entity detail pages)

    - **Project detail page**: a "Generate Document" button (or dropdown) in the actions area. Shows available project-scoped templates. Selecting a template opens a generation dialog.
    - **Customer detail page**: same pattern with customer-scoped templates.
    - **Invoice detail page**: same pattern with invoice-scoped templates. This extends the existing invoice preview with template-based PDF generation.

    - **Generation dialog**:
        - Shows the template name and description.
        - Preview of the rendered document (HTML preview fetched from backend).
        - Options:
            - **Download PDF** — generates and downloads immediately.
            - **Save to Documents** — generates, uploads to S3, creates a Document record, and links it to the project/customer.
        - Generated filename follows a pattern: `{template-slug}-{entity-name}-{date}.pdf` (e.g., `engagement-letter-acme-corp-2026-02-15.pdf`).

4. **Generated documents list**

    - On project and customer detail pages, a "Generated Documents" section (or tab) listing previously generated documents.
    - Each row: document name, template used, generated by, generated at, file size.
    - Actions: download, delete.
    - This is separate from the existing Documents section (which shows uploaded files).

### 8. API endpoints summary

Full endpoint specification:

1. **Document templates**

    - `GET /api/templates` — list active templates. Optional query params: `category`, `primaryEntityType`. Returns all active templates (platform + org custom, with org custom taking precedence over platform originals).
    - `GET /api/templates/{id}` — get a single template with full content.
    - `POST /api/templates` — create a new template (ORG_CUSTOM). Admin/owner only. Body: `{ name, description, category, primaryEntityType, content, css? }`.
    - `PUT /api/templates/{id}` — update a template. Admin/owner only. Only ORG_CUSTOM templates can be edited.
    - `DELETE /api/templates/{id}` — soft-delete (set active=false). Admin/owner only.
    - `POST /api/templates/{id}/clone` — clone a platform template to create an org-custom version. Admin/owner only. Returns the new template.
    - `POST /api/templates/{id}/reset` — delete an org-custom clone, restoring the platform original. Admin/owner only.

2. **Template preview and generation**

    - `POST /api/templates/{id}/preview` — render a template with real entity data and return HTML. Body: `{ entityId }`. Used for the preview pane before PDF generation.
    - `POST /api/templates/{id}/generate` — render a template and generate PDF. Body: `{ entityId, saveToDocuments?: boolean }`. Returns the PDF as a binary download, or if `saveToDocuments` is true, returns the created GeneratedDocument metadata.

3. **Generated documents**

    - `GET /api/generated-documents?entityType=PROJECT&entityId={id}` — list generated documents for a specific entity.
    - `GET /api/generated-documents/{id}/download` — download the generated PDF from S3.
    - `DELETE /api/generated-documents/{id}` — delete a generated document (removes from S3 and DB).

4. **Org branding**

    - `POST /api/settings/logo` — upload org logo (multipart). Admin/owner only.
    - `DELETE /api/settings/logo` — remove org logo. Admin/owner only.
    - Existing `PUT /api/settings` and `GET /api/settings` endpoints extended with `brandColor` and `documentFooterText` fields.

For each endpoint specify:
- Auth requirement (valid Clerk JWT, appropriate role).
- Tenant scoping.
- Permission checks.
- Request/response DTOs.

### 9. Notification integration

- **DOCUMENT_GENERATED**: Notify the project lead (or customer contact, if applicable) when a document is generated and saved to the document system. Not triggered for download-only generation.
- No notification for template management actions (admin activity, low value).

### 10. Audit integration

Publish audit events for:
- `TEMPLATE_CREATED` — new template created (includes template name, category, entity type).
- `TEMPLATE_UPDATED` — template modified (includes changed fields).
- `TEMPLATE_DELETED` — template deactivated.
- `TEMPLATE_CLONED` — platform template cloned to org-custom.
- `DOCUMENT_GENERATED` — document generated from template (includes template name, entity type, entity id, generated by, file size). This is the high-value audit event — it records what was produced and for whom.

### 11. ADRs for key decisions

Add ADR-style sections for:

1. **PDF engine selection: OpenHTMLToPDF vs alternatives**:
    - Why OpenHTMLToPDF (pure Java, no external dependencies, good CSS support, active maintenance) vs alternatives (Flying Saucer — older, less maintained; wkhtmltopdf/Chrome headless — external process dependency; iText — restrictive licensing).
    - CSS rendering constraints and how templates should be authored to stay within the supported subset.
    - Performance characteristics: typical render times, memory usage, thread safety.

2. **Template storage: database vs filesystem vs S3**:
    - Why template content is stored in the database (tenant-scoped access, transactional consistency with metadata, no filesystem dependency in containerized deployment) vs S3 (better for large templates but adds latency and complexity) vs filesystem (not viable in containerized/multi-instance deployment).
    - The trade-off of storing HTML content as TEXT in Postgres — acceptable for template sizes (typically 5-50KB).

3. **Rendering context assembly pattern**:
    - Why a builder-pattern service assembles a flat `Map<String, Object>` rather than passing JPA entities directly to Thymeleaf.
    - Benefits: decouples template variables from entity structure, prevents lazy-loading issues, allows data enrichment (e.g., resolving S3 URLs, formatting dates), explicit control over what data templates can access.
    - The serialization boundary: entity → DTO/Map at the service layer, not in the template.

4. **Template customization: clone-and-edit vs in-place override**:
    - Why cloning (creating a separate ORG_CUSTOM record) rather than allowing orgs to edit PLATFORM records directly.
    - Benefits: platform updates don't break org customizations, "Reset to Default" is a simple delete, clear audit trail of what's platform vs custom.
    - Trade-off: slight data duplication (cloned template content) — acceptable given template sizes.

Use the same ADR format as previous phases (Status, Context, Options, Decision, Rationale, Consequences).

***

## Style and boundaries

- Keep the design **generic and industry-agnostic**. The template system is a platform primitive — it knows nothing about legal engagement letters or agency SOWs. Domain-specific templates live in template packs (seed data), not in platform code.
- Template packs follow the same architecture as field packs (Phase 11): classpath resources, seeded per-tenant, fork-friendly. A vertical fork adds its template pack directory and it's automatically picked up.
- Thymeleaf is already proven in the codebase (invoice preview). Reuse the existing Thymeleaf configuration and extend it with the document template rendering context. Do not create a separate template engine abstraction.
- OpenHTMLToPDF is a mature, well-maintained library with no external process dependencies. It runs in the JVM, supports enough CSS for professional documents, and handles images via URL. It is the right choice for this scale (generating individual documents on-demand, not batch processing thousands).
- The rendering context builder is the key architectural component. It must be well-tested — a template that renders correctly with one customer but fails with another (due to null custom fields, missing customer, etc.) is a bad user experience. Null-safety in the context is critical.
- Generated PDFs should look professional with minimal effort from the org. The default platform templates + org branding (logo, color, footer) should produce documents that a small firm would be proud to send to clients. Default CSS should be clean, modern, and print-friendly.
- All new entities follow the existing tenant isolation model. No exceptions.
- Frontend additions use the existing Shadcn UI component library and olive design system. The template editor is a functional code editor (styled textarea), not a WYSIWYG builder — that's a future phase.
- The template management UI is admin-only. The document generation UI (the "Generate" button on entity detail pages) is available to any member with entity access — this is the primary user-facing feature.

Return a single markdown document as your answer, ready to be added as `architecture/phase12-document-templates.md` and ADRs.
